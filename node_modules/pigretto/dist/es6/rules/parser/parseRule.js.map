{"version":3,"sources":["../../../../src/rules/parser/parseRule.js"],"names":["declarativeFactory","isArray","ORedRule","RegexRule","ExactRule","REGEX_STRING_TOKEN","regexRule","regex","exactRule","property","parseSingle","ruleToParse","factoryParam","factory","RegExp","initialRegexStringToken","indexOf","lastRegexStringToken","lastIndexOf","stringLiteralRegex","substring","flags","parseMultiple","rulesToParse","rules","rule","push","parseRule","parse"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAOA,kBAAP,MAA+B,qBAA/B;AACA,SAASC,OAAT,QAAwB,QAAxB;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,SAAP,MAAsB,cAAtB;AACA,OAAOC,SAAP,MAAsB,cAAtB;AAEA,MAAMC,kBAAkB,GAAG,GAA3B;;AAEA,MAAMC,SAAS,GAAGC,KAAK,IAAI,IAAIJ,SAAJ,CAAcI,KAAd,CAA3B;;AAEA,MAAMC,SAAS,GAAGC,QAAQ,IAAI,IAAIL,SAAJ,CAAcK,QAAd,CAA9B;;AAEA,MAAMC,WAAW,GAAGC,WAAW,IAAI;AACjC,MAAIC,YAAY,GAAGD,WAAnB;AACA,QAAME,OAAO,GAAGb,kBAAkB,CAAC,CACjC,CAAC,MAAMW,WAAW,YAAYG,MAA9B,EAAsCR,SAAtC,CADiC,EAEjC,CACE,MAAM;AACJ,QAAI,OAAOK,WAAP,KAAuB,QAA3B,EAAqC;AACnC,aAAO,KAAP;AACD;;AACD,UAAMI,uBAAuB,GAAGJ,WAAW,CAACK,OAAZ,CAAoBX,kBAApB,CAAhC;AACA,UAAMY,oBAAoB,GAAGN,WAAW,CAACO,WAAZ,CAC3Bb,kBAD2B,CAA7B;;AAGA,QAAIU,uBAAuB,KAAK,CAA5B,IAAiCE,oBAAoB,GAAG,CAA5D,EAA+D;AAC7D,YAAME,kBAAkB,GAAGR,WAAW,CAACS,SAAZ,CACzB,CADyB,EAEzBH,oBAFyB,CAA3B;AAIA,YAAMI,KAAK,GACTV,WAAW,CAACS,SAAZ,CAAsBH,oBAAoB,GAAG,CAA7C,KAAmD,KAAK,CAD1D;AAEAL,MAAAA,YAAY,GAAG,IAAIE,MAAJ,CAAWK,kBAAX,EAA+BE,KAA/B,CAAf;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD,GApBH,EAqBEf,SArBF,CAFiC,EAyBjCE,SAzBiC,CAAD,CAAlC;AA2BA,SAAOK,OAAO,CAACD,YAAD,CAAd;AACD,CA9BD;;AAgCA,MAAMU,aAAa,GAAGC,YAAY,IAAI;AACpC,QAAMC,KAAK,GAAG,EAAd;;AACA,OAAK,MAAMb,WAAX,IAA0BY,YAA1B,EAAwC;AACtC,UAAME,IAAI,GAAGf,WAAW,CAACC,WAAD,CAAxB;AACAa,IAAAA,KAAK,CAACE,IAAN,CAAWD,IAAX;AACD;;AACD,SAAO,IAAIvB,QAAJ,CAAasB,KAAb,CAAP;AACD,CAPD;;AASA,eAAe,SAASG,SAAT,CAAmBF,IAAnB,EAAyB;AACtC,QAAMG,KAAK,GAAG5B,kBAAkB,CAAC,CAC/B,CAACC,OAAO,CAACwB,IAAD,CAAR,EAAgBH,aAAhB,CAD+B,EAE/BZ,WAF+B,CAAD,CAAhC;AAIA,SAAOkB,KAAK,CAACH,IAAD,CAAZ;AACD","sourcesContent":["/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport declarativeFactory from \"declarative-factory\";\nimport { isArray } from \"js-utl\";\nimport ORedRule from \"../ORedRule\";\nimport RegexRule from \"../RegexRule\";\nimport ExactRule from \"../ExactRule\";\n\nconst REGEX_STRING_TOKEN = \"/\";\n\nconst regexRule = regex => new RegexRule(regex);\n\nconst exactRule = property => new ExactRule(property);\n\nconst parseSingle = ruleToParse => {\n  let factoryParam = ruleToParse;\n  const factory = declarativeFactory([\n    [() => ruleToParse instanceof RegExp, regexRule],\n    [\n      () => {\n        if (typeof ruleToParse !== \"string\") {\n          return false;\n        }\n        const initialRegexStringToken = ruleToParse.indexOf(REGEX_STRING_TOKEN);\n        const lastRegexStringToken = ruleToParse.lastIndexOf(\n          REGEX_STRING_TOKEN\n        );\n        if (initialRegexStringToken === 0 && lastRegexStringToken > 0) {\n          const stringLiteralRegex = ruleToParse.substring(\n            1,\n            lastRegexStringToken\n          );\n          const flags =\n            ruleToParse.substring(lastRegexStringToken + 1) || void 0;\n          factoryParam = new RegExp(stringLiteralRegex, flags);\n          return true;\n        }\n        return false;\n      },\n      regexRule\n    ],\n    exactRule\n  ]);\n  return factory(factoryParam);\n};\n\nconst parseMultiple = rulesToParse => {\n  const rules = [];\n  for (const ruleToParse of rulesToParse) {\n    const rule = parseSingle(ruleToParse);\n    rules.push(rule);\n  }\n  return new ORedRule(rules);\n};\n\nexport default function parseRule(rule) {\n  const parse = declarativeFactory([\n    [isArray(rule), parseMultiple],\n    parseSingle\n  ]);\n  return parse(rule);\n}\n"],"file":"parseRule.js"}