{"version":3,"sources":["../../../src/builtin/lazyObject.js"],"names":["pigretto","call","set","get","escapeStringRegexp","lazyObject","target","onceCallback","ignoredTypes","Object","interceptConstructor","propertiesToIgnore","pointcuts","hasCall","hasGet","hasSet","rules","propertiesMap","constructorsToIgnore","map","Type","prototype","constructor","current","currentIsProto","includes","properties","Reflect","ownKeys","property","isMethod","getPrototypeOf","propertyToIgnore","pointcut","keys","firstOperation","callback","args","apply","escape","names","regex","escapedNames","RegExp","join","addRule","push","before","methodNames","filter","escapedMethodNames","propertyNames","escapedPropertyNames","pigrettarget"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport pigretto from \"../pigretto\";\nimport call from \"../pointcuts/shorthands/call\";\nimport set from \"../pointcuts/shorthands/set\";\nimport get from \"../pointcuts/shorthands/get\";\nimport escapeStringRegexp from \"escape-string-regexp\";\n\n/**\n * Builtin function using pigretto's API to implement lazy loading for objects.\n *\n * @param {Object} target A target object to lazy load. Lazy loading in this case means deferring an operation on the object\n *                        when it is used for the very first time by the client code.\n * @param {Object} options The options of the lazy loading.\n * @param {Function} onceCallback The callback to execute only once before performing the very first operation on the given \"target\"\n *                                when the given \"target\" is used for the very first time.\n *                                This callback is mandatory (otherwise it doesn't make sense to use \"lazy()\" at all)\n *                                and allows e.g. to perform a heavy initialization operation lazily on the underlying target object.\n * @param {Object} [options.ignoredTypes] The types which prototypes to ignore when going up the prototype chain in order to identify\n *                                        which prototypes to intercept when lazy loading.\n *                                        By default, only the properties set on the \"Object\" prototype will be ignored.\n *                                        This option can be used e.g. to avoid the performance of a heavy lazy initialization\n *                                        when calling the methods of a parent class of the given \"target\" object.\n * @param {boolean} [options.interceptConstructor] Whether or not to intercept the getting/setting of the \"constructor\" property.\n *                                                 Defaults to \"false\", meaning that when getting/setting \"target.constructor\",\n *                                                 this operation will not trigger the underlying lazy loading.\n * @param {string[]} [options.propertiesToIgnore] Property names or method names to ignore for lazy loading.\n * @param {Array} [options.pointcuts] Array of pointcut shorthands to use for interception and lazy loading.\n *                                    By default, only \"call\", \"get\" and \"set\" pointcuts will be used.\n *                                    Other pointcut shorthands (e.g. \"apply\", \"construct\") will be ignored, if passed.\n * @return {Proxy} A new proxy object for the given target which supports this builtin feature.\n */\nexport default function lazyObject(\n  target,\n  {\n    onceCallback,\n    ignoredTypes = [Object],\n    interceptConstructor = false,\n    propertiesToIgnore = [],\n    pointcuts = [call, get, set],\n  } = {}\n) {\n  let hasCall = false,\n    hasGet = false,\n    hasSet = false;\n  const rules = [];\n  const propertiesMap = {};\n  const constructorsToIgnore = ignoredTypes.map(\n    Type => Type.prototype.constructor\n  );\n\n  let current = target;\n  let currentIsProto = false;\n  while (current) {\n    const constructor = current.constructor;\n    if (!currentIsProto || !constructorsToIgnore.includes(constructor)) {\n      const properties = Reflect.ownKeys(current);\n      properties.map(\n        property =>\n          (propertiesMap[property] = {\n            isMethod:\n              property !== \"constructor\" &&\n              typeof target[property] === \"function\",\n          })\n      );\n    }\n    current = Object.getPrototypeOf(current);\n    currentIsProto = true;\n  }\n  propertiesToIgnore.map(\n    propertyToIgnore => delete propertiesMap[propertyToIgnore]\n  );\n  !interceptConstructor && delete propertiesMap[\"constructor\"];\n\n  pointcuts.map(pointcut => {\n    if (pointcut === call) {\n      hasCall = true;\n    } else if (pointcut === get) {\n      hasGet = true;\n    } else if (pointcut === set) {\n      hasSet = true;\n    }\n  });\n\n  const properties = Object.keys(propertiesMap);\n  let firstOperation = true;\n  const callback = function (...args) {\n    if (firstOperation) {\n      firstOperation = false;\n      onceCallback.apply(this, args);\n    }\n  };\n  const escape = names => names.map(escapeStringRegexp);\n  const regex = escapedNames => new RegExp(`^(${escapedNames.join(\"|\")})$`);\n  const addRule = regex => pointcut =>\n    rules.push([regex, pointcut().before(callback)]);\n  if (hasCall) {\n    const methodNames = properties.filter(\n      property => propertiesMap[property].isMethod\n    );\n    const escapedMethodNames = escape(methodNames);\n    addRule(regex(escapedMethodNames))(call);\n  }\n  if (hasGet || hasSet) {\n    const propertyNames = properties.filter(\n      property => !propertiesMap[property].isMethod\n    );\n    const escapedPropertyNames = escape(propertyNames);\n    hasGet && addRule(regex(escapedPropertyNames))(get);\n    hasSet && addRule(regex(escapedPropertyNames))(set);\n  }\n\n  const pigrettarget = pigretto(target, rules);\n  return pigrettarget;\n}\n"],"file":"lazyObject.js"}