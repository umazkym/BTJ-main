{"version":3,"sources":["../../../src/trap/Trap.js"],"names":["declarativeFactory","MethodCallPointcut","PropertyGettingPointcut","PropertySettingPointcut","FunctionCallPointcut","ObjectConstructionPointcut","ExactRule","applyRule","constructRule","apply","construct","BeforeAdvice","AroundAdvice","CallTrapExecutor","GetTrapExecutor","SetTrapExecutor","ApplyTrapExecutor","ConstructTrapExecutor","isUndefined","Trap","call","get","set","before","around","after","Map","hasAtLeastOneAdviceOfPointcutType","pointcutType","advices","length","addAdvices","rule","map","advice","push","lazilyDistributeAdvices","distributedAdvices","subKey","lazilyMatchAdvices","property","matchedDistributedAdvices","has","node","beforeAdvices","aroundAdvices","afterAdvices","match","key","matches","addPointcutRule","pointcut","isImplicitBeforeAdvice","isImplicit","hasGets","hasSets","hasApplies","hasConstructs","target","receiver","getBefore","getAround","getAfter","propertyValue","trapExecutors","execute","callBefore","callAround","callAfter","returnValue","value","thisArg","argumentsList","newTarget"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport declarativeFactory from \"declarative-factory\";\nimport MethodCallPointcut from \"../pointcuts/MethodCallPointcut\";\nimport PropertyGettingPointcut from \"../pointcuts/PropertyGettingPointcut\";\nimport PropertySettingPointcut from \"../pointcuts/PropertySettingPointcut\";\nimport FunctionCallPointcut from \"../pointcuts/FunctionCallPointcut\";\nimport ObjectConstructionPointcut from \"../pointcuts/ObjectConstructionPointcut\";\nimport ExactRule from \"../rules/ExactRule\";\nimport applyRule from \"../rules/applyRule\";\nimport constructRule from \"../rules/constructRule\";\nimport apply from \"../pointcuts/shorthands/apply\";\nimport construct from \"../pointcuts/shorthands/construct\";\nimport BeforeAdvice from \"../advices/BeforeAdvice\";\nimport AroundAdvice from \"../advices/AroundAdvice\";\nimport CallTrapExecutor from \"./executors/CallTrapExecutor\";\nimport GetTrapExecutor from \"./executors/GetTrapExecutor\";\nimport SetTrapExecutor from \"./executors/SetTrapExecutor\";\nimport ApplyTrapExecutor from \"./executors/ApplyTrapExecutor\";\nimport ConstructTrapExecutor from \"./executors/ConstructTrapExecutor\";\nimport { isUndefined } from \"js-utl\";\n\nexport default class Trap {\n  advices = {\n    // Requires matching (get trap). Requires distribution.\n    call: [],\n\n    // Requires matching (get trap). Requires distribution.\n    get: [],\n\n    // Requires matching (set trap). Requires distribution.\n    set: [],\n\n    // Does not require matching (apply trap). Requires distribution.\n    apply: [],\n\n    // Does not require matching (construct trap). Requires distribution.\n    construct: []\n  };\n\n  distributedAdvices = {\n    call: { before: void 0, around: void 0, after: void 0 },\n    get: { before: void 0, around: void 0, after: void 0 },\n    set: { before: void 0, around: void 0, after: void 0 },\n    apply: { before: void 0, around: void 0, after: void 0 },\n    construct: { before: void 0, around: void 0, after: void 0 }\n  };\n\n  matchedDistributedAdvices = {\n    call: new Map(),\n    get: new Map(),\n    set: new Map()\n  };\n\n  trapExecutors = {\n    call: new CallTrapExecutor(),\n    get: new GetTrapExecutor(),\n    set: new SetTrapExecutor(),\n    apply: new ApplyTrapExecutor(),\n    construct: new ConstructTrapExecutor()\n  };\n\n  /**\n   * @private\n   */\n  hasAtLeastOneAdviceOfPointcutType(pointcutType) {\n    return !!this.advices[pointcutType].length;\n  }\n\n  /**\n   * @private\n   */\n  addAdvices(pointcutType, rule, advices = []) {\n    advices.map(advice =>\n      this.advices[pointcutType].push({\n        rule,\n        advice\n      })\n    );\n  }\n\n  /**\n   * @private\n   */\n  lazilyDistributeAdvices(pointcutType) {\n    if (isUndefined(this.distributedAdvices[pointcutType].before)) {\n      this.distributedAdvices[pointcutType].before = [];\n      this.distributedAdvices[pointcutType].around = [];\n      this.distributedAdvices[pointcutType].after = [];\n      for (const { rule, advice } of this.advices[pointcutType]) {\n        const subKey = declarativeFactory([\n          [() => advice instanceof BeforeAdvice, \"before\"],\n          [() => advice instanceof AroundAdvice, \"around\"],\n          \"after\"\n        ]);\n        this.distributedAdvices[pointcutType][subKey].push({ rule, advice });\n      }\n    }\n  }\n\n  /**\n   * For \"call\", \"get\" and \"set\" advices.\n   *\n   * @private\n   */\n  lazilyMatchAdvices(pointcutType, property) {\n    this.lazilyDistributeAdvices(pointcutType);\n    const map = this.matchedDistributedAdvices[pointcutType];\n    if (!map.has(property)) {\n      const node = {\n        before: [],\n        around: [],\n        after: []\n      };\n      map.set(property, node);\n      const beforeAdvices = this.distributedAdvices[pointcutType].before;\n      const aroundAdvices = this.distributedAdvices[pointcutType].around;\n      const afterAdvices = this.distributedAdvices[pointcutType].after;\n      const match = advices => key => {\n        for (const { rule, advice } of advices) {\n          const matches = rule.matches(property);\n          if (matches) {\n            node[key].push({ rule, advice });\n          }\n        }\n      };\n      match(beforeAdvices)(\"before\");\n      match(aroundAdvices)(\"around\");\n      match(afterAdvices)(\"after\");\n    }\n  }\n\n  /**\n   * Adds a pointcut and its associated rule to this trap.\n   * If a pointcut is of an unknown type, it will be ignored.\n   *\n   * @param {Pointcut|Function} pointcut The pointcut or a function (for implicit apply and construct pointcuts).\n   * @param {Rule} rule The rule.\n   * @return {Trap} This trap object.\n   */\n  addPointcutRule(pointcut, rule) {\n    const isImplicitBeforeAdvice = () =>\n      typeof pointcut === \"function\" && rule instanceof ExactRule;\n    const pointcutType = declarativeFactory([\n      [() => pointcut instanceof MethodCallPointcut, \"call\"],\n      [() => pointcut instanceof PropertyGettingPointcut, \"get\"],\n      [() => pointcut instanceof PropertySettingPointcut, \"set\"],\n      [\n        () => {\n          const isImplicit =\n            isImplicitBeforeAdvice() && rule.property === applyRule;\n          if (isImplicit || pointcut instanceof FunctionCallPointcut) {\n            if (isImplicit) {\n              pointcut = apply().before(pointcut);\n            }\n            return true;\n          }\n          return false;\n        },\n        \"apply\"\n      ],\n      [\n        () => {\n          const isImplicit =\n            isImplicitBeforeAdvice() && rule.property === constructRule;\n          if (isImplicit || pointcut instanceof ObjectConstructionPointcut) {\n            if (isImplicit) {\n              pointcut = construct().before(pointcut);\n            }\n            return true;\n          }\n          return false;\n        },\n        \"construct\"\n      ]\n    ]);\n    if (pointcutType) {\n      const { advices } = pointcut;\n      this.addAdvices(pointcutType, rule, advices);\n    }\n    return this;\n  }\n\n  hasGets() {\n    return (\n      this.hasAtLeastOneAdviceOfPointcutType(\"call\") ||\n      this.hasAtLeastOneAdviceOfPointcutType(\"get\")\n    );\n  }\n\n  hasSets() {\n    return this.hasAtLeastOneAdviceOfPointcutType(\"set\");\n  }\n\n  hasApplies() {\n    return this.hasAtLeastOneAdviceOfPointcutType(\"apply\");\n  }\n\n  hasConstructs() {\n    return this.hasAtLeastOneAdviceOfPointcutType(\"construct\");\n  }\n\n  get(target, property, receiver) {\n    // Method call and property access (getting) advices.\n    this.lazilyMatchAdvices(\"get\", property);\n    this.lazilyMatchAdvices(\"call\", property);\n    const {\n      before: getBefore,\n      around: getAround,\n      after: getAfter\n    } = this.matchedDistributedAdvices.get.get(property);\n    const propertyValue = this.trapExecutors.get.execute(\n      [target, property, receiver],\n      getBefore,\n      getAround,\n      getAfter\n    );\n\n    const {\n      before: callBefore,\n      around: callAround,\n      after: callAfter\n    } = this.matchedDistributedAdvices.call.get(property);\n    const returnValue = this.trapExecutors.call.execute(\n      [target, property, receiver, propertyValue],\n      callBefore,\n      callAround,\n      callAfter\n    );\n\n    return returnValue;\n  }\n\n  set(target, property, value, receiver) {\n    // Property access (setting) advices.\n    this.lazilyMatchAdvices(\"set\", property);\n    const { before, around, after } = this.matchedDistributedAdvices.set.get(\n      property\n    );\n    return this.trapExecutors.set.execute(\n      [target, property, value, receiver],\n      before,\n      around,\n      after\n    );\n  }\n\n  apply(target, thisArg, argumentsList) {\n    // Function call advices.\n    this.lazilyDistributeAdvices(\"apply\");\n    const { before, around, after } = this.distributedAdvices.apply;\n    return this.trapExecutors.apply.execute(\n      [target, thisArg, argumentsList],\n      before,\n      around,\n      after\n    );\n  }\n\n  construct(target, argumentsList, newTarget) {\n    // Object construction via the \"new\" keyword advices.\n    this.lazilyDistributeAdvices(\"construct\");\n    const { before, around, after } = this.distributedAdvices.construct;\n    return this.trapExecutors.construct.execute(\n      [target, argumentsList, newTarget],\n      before,\n      around,\n      after\n    );\n  }\n}\n"],"file":"Trap.js"}