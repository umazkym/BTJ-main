{"version":3,"sources":["../src/hooks/useNestedDataCallback.js"],"names":["useCallback","shallowEqual","ImmutableLinkedOrderedMap","useFactory","usePrevious","declarativeFactory","visitor","isPrimitiveOfType","dataGetKey","data","key","get","mapTraverseFactory","traverse","weakMapTraverseFactory","immutableLinkedOrderedMapTraverseFactory","propTraverseFactory","yesVisitorKeyFactory","visit","noVisitorKeyFactory","finalKey","useNestedDataCallback","pathCopy","prevData","finalDataFactory","Map","WeakMap","isMap","finalData","callback","keys","effectiveKeys","flat","depth","currentData","path","pathData","traverseFactory","visitorFactory","concat","push","length"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2022 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport { useCallback } from \"react\";\nimport { shallowEqual } from \"js-utl\";\nimport ImmutableLinkedOrderedMap from \"immutable-linked-ordered-map\";\nimport useFactory from \"./useFactory\";\nimport usePrevious from \"./usePrevious\";\nimport declarativeFactory from \"declarative-factory\";\nimport visitor from \"../primitives/visitor\";\nimport isPrimitiveOfType from \"../primitives/predicates/isPrimitiveOfType\";\n\nconst dataGetKey = (data, key) => data.get(key);\n\n/**\n * @type {Object}\n */\nconst mapTraverseFactory = {\n  traverse: dataGetKey,\n};\n\n/**\n * @type {Object}\n */\nconst weakMapTraverseFactory = {\n  traverse: dataGetKey,\n};\n\n/**\n * @type {Object}\n */\nconst immutableLinkedOrderedMapTraverseFactory = {\n  traverse: dataGetKey,\n};\n\n/**\n * @type {Object}\n */\nconst propTraverseFactory = {\n  traverse: (data, key) => data[key],\n};\n\n/**\n * @type {Object}\n */\nconst yesVisitorKeyFactory = visitor => ({\n  key: () => visitor.key,\n  visit: (...args) => visitor.visit(...args),\n});\n\n/**\n * @type {Object}\n */\nconst noVisitorKeyFactory = finalKey => ({\n  key: () => finalKey,\n  visit: () => {},\n});\n\n/**\n * Hook returning a callback to traverse nested data.\n *\n * @param {Array|Object|Map|WeakMap|ImmutableLinkedOrderedMap} data The data. Can be any of the specified types which in turn have nested data\n *                                                                  of any of the specified types.\n * @param {Object} [obj] An optional object with further parameters.\n * @param {boolean} [obj.pathCopy] Whether or not to create a copy of the current path and the data forming the path when traversing the nested data\n *                                 instead of pushing to a single path array.\n *                                 This parameter should be set to false only when the nested data is very deep and performance issues are experienced when using\n *                                 this hook for the given data.\n *                                 In case this parameter is set to false, eventual visitors (explained below) will receive an object where\n *                                 the \"path\" and \"pathData\" properties will refer to the same arrays for every visitor.\n * @return {(keys: Array) => *} The nested data callback which receives the keys and if called returns the nested data for the given keys, if any, or undefined.\n *                              The nested data callback takes an array of keys as argument. Note that the array is flattened (only its first dimension)\n *                              and therefore the following arrays will be treated as being the same array of keys:\n *\n *                                  import { useNestedDataCallback } from \"react-js-utl/hooks\";\n *\n *                                  // Inside functional component:\n *                                  useNestedDataCallback(data)([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n *                                  useNestedDataCallback(data)([\"a\", \"b\", [\"c\", \"d\"], \"e\"]); // Same as above.\n *\n *                              Each element represents a nested key of the given data.\n *\n *                              An element can also be a visitor primitive returned by the \"visitor\" primitive function:\n *\n *                                  import { useNestedDataCallback } from \"react-js-utl/hooks\";\n *                                  import { visitor } from \"react-js-utl/primitives\";\n *\n *                                  // Inside functional component:\n *                                  useNestedDataCallback(data)([\n *                                      \"a\",\n *                                      visitor(\"b\", ({\n *                                          currentData,\n *                                          depth,\n *                                          key,\n *                                          path,\n *                                          pathData,\n *                                          data,\n *                                      }) => {\n *                                          // Called when visiting the nested data (\"currentData\") for the \"b\" key (depth 1)\n *                                          // if the data for the \"b\" key is not \"undefined\".\n *                                      }),\n *                                      \"c\",\n *                                      \"d\",\n *                                      \"e\"\n *                                  ]);\n *\n *                              The visitor function allows to perform a custom behaviour when visiting the nested data.\n *                              Note that the visitor function will only be called if the underlying visited data for a given nested key\n *                              is not \"undefined\".\n */\nexport default function useNestedDataCallback(data, { pathCopy = true } = {}) {\n  const prevData = usePrevious(data);\n  const finalDataFactory = useFactory(\n    () => [\n      [\n        data instanceof Map ||\n          data instanceof WeakMap ||\n          ImmutableLinkedOrderedMap.isMap(data),\n        () => (prevData === data ? prevData : data),\n      ],\n      () => (shallowEqual(prevData, data) ? prevData : data),\n    ],\n    [data]\n  );\n\n  const finalData = finalDataFactory();\n  const callback = useCallback(\n    keys => {\n      const data = finalData;\n      const effectiveKeys = keys.flat();\n      let depth = 0;\n      let currentData = data;\n      let path = [];\n      let pathData = [];\n      for (const key of effectiveKeys) {\n        if (!currentData) {\n          break;\n        }\n        const traverseFactory = declarativeFactory([\n          [() => currentData instanceof Map, mapTraverseFactory],\n          [() => currentData instanceof WeakMap, weakMapTraverseFactory],\n          [\n            () => ImmutableLinkedOrderedMap.isMap(currentData),\n            immutableLinkedOrderedMapTraverseFactory,\n          ],\n          propTraverseFactory,\n        ]);\n        const visitorFactory = declarativeFactory([\n          [() => isPrimitiveOfType(key, visitor), yesVisitorKeyFactory(key)],\n          noVisitorKeyFactory(key),\n        ]);\n        const finalKey = visitorFactory.key();\n        currentData = traverseFactory.traverse(currentData, finalKey);\n        if (pathCopy) {\n          path = path.concat(finalKey);\n          pathData = pathData.concat(currentData);\n        } else {\n          path.push(finalKey);\n          pathData.push(currentData);\n        }\n        if (typeof currentData !== \"undefined\") {\n          visitorFactory.visit({\n            currentData,\n            depth,\n            key: finalKey,\n            path,\n            pathData,\n            data,\n          });\n        }\n        depth++;\n      }\n      return depth === effectiveKeys.length ? currentData : void 0;\n    },\n    [finalData, pathCopy]\n  );\n  return callback;\n}\n"],"file":"useNestedDataCallback.js"}