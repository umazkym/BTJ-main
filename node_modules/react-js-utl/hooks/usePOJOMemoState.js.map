{"version":3,"sources":["../src/hooks/usePOJOMemoState.js"],"names":["useRef","useMemo","useEffect","usePOJOState","usePOJOMemoState","POJO","originalPOJO","rehidrateStateRef","current","setState"],"mappings":";;;;;;;;;;;;AAAA,SAASA,MAAT,EAAiBC,OAAjB,EAA0BC,SAA1B,QAA2C,OAA3C;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,gBAAT,CAA0BC,IAA1B,EAAgC;AAC7C,MAAMC,YAAY,GAAGD,IAArB;AAEA,MAAME,iBAAiB,GAAGP,MAAM,CAAC,KAAD,CAAhC;AACAK,EAAAA,IAAI,GAAGJ,OAAO,CAAC,YAAM;AACnBM,IAAAA,iBAAiB,CAACC,OAAlB,GAA4B,IAA5B;AACA,WAAOF,YAAP;AACD,GAHa,EAGX,CAACA,YAAD,CAHW,CAAd;AAKA,MAAIG,QAAJ;;AAT6C,sBAU1BN,YAAY,CAACE,IAAD,CAVc;;AAAA;;AAU5CA,EAAAA,IAV4C;AAUtCI,EAAAA,QAVsC;AAY7CP,EAAAA,SAAS,CAAC,YAAM;AACd,QAAIK,iBAAiB,CAACC,OAAtB,EAA+B;AAC7BD,MAAAA,iBAAiB,CAACC,OAAlB,GAA4B,KAA5B;AACAC,MAAAA,QAAQ,CAACH,YAAD,CAAR;AACD;AACF,GALQ,EAKN,CAACA,YAAD,EAAeG,QAAf,CALM,CAAT;AAOA,SAAO,CAACJ,IAAD,EAAOI,QAAP,CAAP;AACD","sourcesContent":["import { useRef, useMemo, useEffect } from \"react\";\nimport usePOJOState from \"./usePOJOState\";\n\n/**\n * Hook to use a POJO state which merges values of the previous state with the next one\n * if the partial state update of the next state is not the same as the previous state\n * for the same keys depending on the POJO passed as parameter.\n *\n * The difference from the \"usePOJOState\" hook is that as soon as the POJO passed as parameter changes\n * (i.e. its reference points to another object), the state is reinitialized.\n *\n * Another difference is that this hook doesn't accept a function returning a POJO as its initial state because\n * it doesn't make sense in this context as the POJO itself is needed to be passed as parameter to this hook\n * in order to determine if it changed since the last rendering.\n *\n * @param {Object} POJO A POJO (Plain Old JavaScript Object).\n * @return {Array} A tuple of two values, current state POJO and callback to set state,\n *                 like the one returned by the \"useState\" hook.\n *\n *                 The callback to set state may receive an updater function which will receive\n *                 the previous POJO state as argument and must return the next partial POJO state\n *                 update or \"null\" (to bail out of the state update, read below).\n *\n *                 If the updater function returns \"null\" or a partial POJO state update which\n *                 has the same values for the same keys as the current POJO state, the update will be\n *                 bailed out as for the \"useState\" hook.\n */\nexport default function usePOJOMemoState(POJO) {\n  const originalPOJO = POJO;\n\n  const rehidrateStateRef = useRef(false);\n  POJO = useMemo(() => {\n    rehidrateStateRef.current = true;\n    return originalPOJO;\n  }, [originalPOJO]);\n\n  let setState;\n  [POJO, setState] = usePOJOState(POJO);\n\n  useEffect(() => {\n    if (rehidrateStateRef.current) {\n      rehidrateStateRef.current = false;\n      setState(originalPOJO);\n    }\n  }, [originalPOJO, setState]);\n\n  return [POJO, setState];\n}\n"],"file":"usePOJOMemoState.js"}