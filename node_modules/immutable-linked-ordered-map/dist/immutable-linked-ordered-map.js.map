{"version":3,"file":"immutable-linked-ordered-map.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;AAEjC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,YAAY,GAAG;AACf;AACA;AACe;AACf;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAO;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACk8B;AACjtB;AACjK;AACgC;AACwhB;AAC/f;AAC1E;AACmK;AAC9J;AACL;AACiB;AACnC;AACgD;AAC9C;AACyL;AACzJ;AACwI;AAC1K;AAC8D;AACjB;AAC9C;AACqB;AACH;AAC9D;;;;;;;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,YAAY;AACZ;AACO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,OAAO;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,GAAG;AACf;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,GAAG;AACf;;AAEO;AACP;AACA;AACA;AACA,SAAS,2BAA2B;AACpC;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,YAAY,GAAG;AACf;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,kBAAkB;AAC9B;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,kBAAkB;AAC9B;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,YAAY,UAAU;AACtB;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;;AAEO;AACP;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACqC;AACrC;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,YAAY,UAAU;AACtB;;AAEO;AACP;AACA;AACA,KAAK,kDAAW;AAChB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,YAAY,UAAU;AACtB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAC8D;AACnB;AAC3C;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAgB;AACxC,MAAM;AACN;AACA,8BAA8B;AAC9B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;;AAEO;AACP;;AAEA;AACA;AACA;;AAEA,eAAe,wDAAgB,SAAS;;AAExC;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;;AAEA;AACA;AACA,8CAA8C,mCAAmC;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEO;AACP;;AAEA;AACA;AACA;;AAEA,2BAA2B,wDAAgB,iBAAiB;;AAE5D;AACA;AACA;AACA;AACA,IAAI;;;AAGJ,SAAS,+CAAQ;;AAEjB;AACA;AACA,8CAA8C,mCAAmC;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;;AAEO;AACP;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;;AAEO;AACP;AACA;;AAEA;AACA,SAAS,mDAAY;AACrB,MAAM,mDAAY;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;;AAEO;AACP;AACA;;AAEA;AACA;AACA,wBAAwB,wDAAgB;AACxC,MAAM;AACN,sBAAsB,kBAAkB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;;AAGJ,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxFA,2CAA2C,gCAAgC,oCAAoC,oDAAoD,sBAAsB,0CAA0C,iEAAiE,KAAK,kCAAkC;;AAE3U,iCAAiC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,4CAA4C,KAAK,6CAA6C,6EAA6E,OAAO,iDAAiD,mFAAmF,OAAO;;AAEtgB,4CAA4C,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;;AAEpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AACjB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA,8DAA8D;AAC9D;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA,kDAAkD;AAClD;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;;AAEO;AACP,gBAAgB,qBAAM,mBAAmB,qBAAM;AAC/C;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY,GAAG;AACf;;AAEO;AACP;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,YAAY;AACZ;;AAEO;AACP;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,YAAY;AACZ;;AAEO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,YAAY,GAAG;AACf;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,YAAY;AACZ;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,YAAY,GAAG;AACf;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,GAAG;AACf;;AAEO;AACP;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO;AAC3F;AACA;AACA,mBAAmB;AACnB,6BAA6B,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,aAAa;AACtF,8BAA8B,MAAM,GAAG,MAAM,GAAG,OAAO;AACvD;AACA;AACA,8BAA8B,OAAO;AACrC,+CAA+C;AAC/C;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,GAAG;AACf;;AAEO;AACP,kDAAkD;AAClD;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEO,uEAAuE;AAC9E;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,YAAY;AACZ;;AAEO;AACP;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;;AAEO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,MAAM;;;AAGN,mCAAmC,QAAQ;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,GAAG;AACf;;AAEO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,SAAS;AACrB;AACA;AACA;;AAEO;AACP,SAAS,sDAAY;AACrB;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA,YAAY;AACZ;AACA;;AAEA,MAAM,sDAAY;AAClB;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA,SAAS,yDAAe;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA,SAAS,yDAAe;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACA,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA,sHAAsH;AACtH;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA,CAAC,IAAI;AACL;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;;AAEO;AACP;AACA;AACA,EAAE,IAAI;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,oBAAoB;AAC/B,YAAY;AACZ;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO,6CAA6C;AACpD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA,KAAK,IAAI,GAAG;;AAEZ;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;ACpwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CA,2CAA2C,gCAAgC,oCAAoC,oDAAoD,sBAAsB,0CAA0C,iEAAiE,KAAK,kCAAkC;;AAE3U,iCAAiC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,4CAA4C,KAAK,6CAA6C,6EAA6E,OAAO,iDAAiD,mFAAmF,OAAO;;AAEtgB,4CAA4C,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;;AAEpM,sDAAsD,+BAA+B,8DAA8D,YAAY,oCAAoC,6DAA6D,YAAY,6BAA6B,OAAO,2BAA2B,0CAA0C,wEAAwE,+BAA+B;;AAE5d,2DAA2D,+BAA+B,iBAAiB,sCAAsC,YAAY,YAAY,uBAAuB,OAAO,qBAAqB,0CAA0C,6BAA6B;;AAEnS,+BAA+B,uCAAuC;;AAEtE,qCAAqC,+DAA+D,sCAAsC,0BAA0B,+CAA+C,yCAAyC,uEAAuE;;AAEnU;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACgD;AACL;AAC3C;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEO;AACP;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA,WAAW,kBAAkB;AAC7B;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,iCAAiC;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+BAA+B,wBAAwB;;AAEvD;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;;AAEA,WAAW,oDAAa;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA,YAAY,UAAU;AACtB;AACA;;AAEO;AACP;AACA;AACA;;AAEA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA,YAAY,UAAU;AACtB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,YAAY,UAAU;AACtB;AACA;;AAEO,qFAAqF,QAAQ;AACpG;AACA,CAAC,KAAK;AACN;AACA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,UAAU;AACtB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY,UAAU;AACtB;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,YAAY;AACvB;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,8CAA8C;AAC1D;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,YAAY,mEAAmE;AAC/E;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,YAAY,8CAA8C;AAC1D;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;;AAEO;AACP;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;;AAEO;AACP,6DAA6D,8CAAO,sDAAsD,wDAAgB;AAC1I;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,OAAO;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,GAAG;AACf;;AAEO;AACP;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;;AAEO;AACP;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA,YAAY,UAAU;AACtB;AACA;;;AAGO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;AC5kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,0BAA0B;AACrC,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACO;AACP;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,gBAAgB;AAC9B;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,YAAY,QAAQ;AACpB;;AAEO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,YAAY,QAAQ;AACpB;;AAEO;AACP;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA,YAAY,0DAA0D;AACtE;AACA;AACA;;AAEO;AACP;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,wBAAwB;AACnC;AACA,WAAW,SAAS;AACpB;AACA,YAAY,GAAG;AACf;;;AAGO;AACP;AACA;AACA,EAAE,IAAI;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA,yEAAyE;;AAEzE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAC2C;AAC3C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;;AAEO;AACP;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA,uBAAuB;AACvB;AACA,EAAE,IAAI;AACN,2BAA2B,+CAAQ;AACnC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA,YAAY,UAAU;AACtB;AACA;AACA;;AAEO;AACP;AACA;;AAEA,QAAQ,8CAAO;AACf;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;;AAEA,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;;;AAGO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAC4C;AACT;AACnC;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,QAAQ;AACpB;;AAEO;AACP,SAAS,0CAAG;AACZ;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,QAAQ;AACpB;;AAEO;AACP,iBAAiB,gDAAQ;AACzB,sBAAsB,6CAAM;AAC5B,SAAS,4CAAK;AACd;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,kCAAkC;AAC9C;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,kCAAkC;AAC9C;AACA;;AAEO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACiC;AACjC;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,YAAY,QAAQ;AACpB;;AAEO,2DAA2D;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;;AAEA;AACA,QAAQ,8CAAO;AACf;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,kCAAkC;AAC7C;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;;AAEA;AACA,UAAU,8CAAO;AACjB;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP,0GAA0G,IAAI,EAAE,EAAE;AAClH;AACA;;;;;;;;;;;;;;;;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACgF;AAChF;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA,kFAAkF,UAAU,GAAG,IAAI;AACnG,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;;;AAGO;AACP;AACA,uCAAuC;;AAEvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY,UAAU;AACtB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEO;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;;AAGT,kCAAkC,yDAAsB;AACxD;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B;AACA,YAAY;AACZ;;AAEO;AACP;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;;AAEA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,kBAAkB;AAC9B;;AAEO;AACP;AACA,qCAAqC;;AAErC,kBAAkB,eAAe;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA,YAAY,QAAQ;AACpB;;AAEO;AACP,gCAAgC,+CAAQ;AACxC,mCAAmC,+DAA4B;AAC/D;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,qBAAqB;AACjC;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA,4CAA4C;;AAE5C,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC;;AAEpC,6CAA6C;;AAE7C,gFAAgF;;AAEhF;AACA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA,sDAAsD,cAAc,eAAe,kBAAkB,oBAAoB,eAAe;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY;AACZ;;;AAGO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY,GAAG;AACf;;AAEO;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;;AAEO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,YAAY,GAAG;AACf;;AAEO;AACP;;AAEA,OAAO,8CAAO;AACd;;AAEA,QAAQ,mDAAY;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,SAAS;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC,aAAa;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA;;AAEA,oBAAoB,iBAAiB;AACrC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,UAAU,oDAAa;AACvB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;;AAEO;AACP,YAAY;;AAEZ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,YAAY,WAAW;AACvB;;AAEO;AACP;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA,kBAAkB,wBAAwB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;;AAEO;AACP;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;;AAEO;AACP;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;ACz0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8B;AACf,0BAA0B,+CAAM;AAC/C;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8B;AACf,2BAA2B,+CAAM;AAChD;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8B;AACf,2BAA2B,+CAAM;AAChD;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACa;AACF;AACA;AACQ;AACtD;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB;AACA;AACA,YAAY,OAAO;AACnB;;AAEe;AACf;AACA;AACA;AACA;AACA,eAAe,kEAAI,EAAE,iEAAG,EAAE,iEAAG;AAC7B,EAAE,IAAI;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,kEAAI;AACzB;AACA,MAAM,sBAAsB,iEAAG;AAC/B;AACA,MAAM,sBAAsB,iEAAG;AAC/B;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,6DAAkB;;AAEtD,gDAAgD,uBAAuB;;AAEvE;;AAEA;AACA;AACA;AACA,uCAAuC,kEAAI;AAC3C;;AAEA;AACA;AACA;AACA,mDAAmD,iEAAG;AACtD,mDAAmD,iEAAG;AACtD;;AAEA,uBAAuB,qDAAQ;AAC/B;AACA;AACA;;;;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AAC9D;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;;AAEe;AACf,kBAAkB,qEAAmB;AACrC;AACA;AACA;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;;AAEe;AACf,kBAAkB,mEAAc;AAChC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACiB;AACF;AACE;AACpC,mCAAmC,iDAAQ;AAC1D;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA,cAAc,sBAAsB;AACpC;AACA;AACA,0BAA0B,6DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;;;AAGA;AACA,0BAA0B,4DAAW;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;;;AAGA;AACA,0BAA0B,6DAAY;AACtC;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACiB;AACF;AACE;AACpC,iCAAiC,iDAAQ;AACxD;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA,cAAc,oBAAoB;AAClC;AACA;AACA,0BAA0B,6DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;;;AAGA;AACA,0BAA0B,4DAAW;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;;;AAGA;AACA,0BAA0B,6DAAY;AACtC;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACiB;AACF;AACE;AACpC,yCAAyC,iDAAQ;AAChE;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA,cAAc,4BAA4B;AAC1C;AACA;AACA,0BAA0B,6DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C;;;AAGA;AACA,0BAA0B,4DAAW;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C;;;AAGA;AACA,0BAA0B,6DAAY;AACtC;AACA;;AAEA;AACA;;;;;;;;;;;;;;AC1EA,4CAA4C,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;;AAEpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACiB;AACF;AACE;AACpC,sCAAsC,iDAAQ;AAC7D;AACA;AACA;AACA,aAAa,UAAU;AACvB,cAAc,yBAAyB;AACvC;AACA;AACA,0BAA0B,6DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA,cAAc,yBAAyB;AACvC;;;AAGA;AACA,0BAA0B,4DAAW;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;;;AAGA;AACA,0BAA0B,6DAAY;AACtC;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACiB;AACF;AACE;AACpC,sCAAsC,iDAAQ;AAC7D;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA,cAAc,yBAAyB;AACvC;AACA;AACA,0BAA0B,6DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA,cAAc,yBAAyB;AACvC;;;AAGA;AACA,0BAA0B,4DAAW;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;;;AAGA;AACA,0BAA0B,6DAAY;AACtC;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AAC3D;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;;AAEe;AACf,aAAa,6DAAoB;AACjC;AACA;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACvD;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;;AAEe;AACf,aAAa,2DAAkB;AAC/B;AACA;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuE;AACvE;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;;AAEe;AACf,aAAa,mEAA0B;AACvC;AACA;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiE;AACjE;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;;AAEe;AACf,aAAa,gEAAuB;AACpC;AACA;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiE;AACjE;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;;AAEe;AACf,aAAa,gEAAuB;AACpC;AACA;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;AACX,wBAAwB,6CAAI;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;AACX,uBAAuB,6CAAI;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;AACX,wBAAwB,6CAAI;AAC3C;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA,iEAAe,SAAS,EAAC;AACzB;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA,iEAAe,aAAa,EAAC;AAC7B;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACpB;AACE;AACE;AACA;AACrC;;AAEA,+BAA+B,kDAAS;;AAExC,kCAAkC,kDAAS;;AAE3C;AACA;AACA,kBAAkB,+DAAkB;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,iDAAQ;AACrB;;AAEe;AACf,gBAAgB,+DAAkB,GAAG,+CAAO;AAC5C;AACA;AACA;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACpB;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,+CAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGe;AACf,oBAAoB,+DAAkB,GAAG,+CAAO;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtEA,4CAA4C,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;;AAEpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACY;AACU;AACA;AACN;AACY;AACtC;AACA;AACQ;AACD;AACQ;AACP;AACA;AACS;AACF;AACA;AACI;AACQ;AACjC;AACtB;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,gBAAgB,mEAAgB;AAChC,eAAe,kEAAe;AAC9B,eAAe,kEAAe;AAC9B,iBAAiB,oEAAiB;AAClC,qBAAqB,wEAAqB;AAC1C,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA,QAAQ,mDAAW;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,uBAAuB,+DAAkB,2BAA2B,6DAAY,sCAAsC,6DAAY;AAClI;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,aAAa,MAAM;AACnB,cAAc,MAAM;AACpB;;;AAGA;AACA,2FAA2F,wDAAS;;AAEpG,yBAAyB,+DAAkB,6BAA6B,sEAAkB,sCAAsC,2EAAuB,qCAAqC,2EAAuB;AACnN,uEAAuE,yDAAS;;AAEhF,4CAA4C,wEAAoB;AAChE;AACA,qBAAqB,wEAAK;AAC1B;;AAEA;AACA;;AAEA;AACA,KAAK;AACL,uEAAuE,6DAAa;;AAEpF,4CAA4C,8EAA0B;AACtE;AACA,qBAAqB,4EAAS;AAC9B;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;AChTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACS;AAC8B;AACjF,iEAAe,8FAAwB,iCAAiC,qDAAY;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iEAAY;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,CAAC,EAAC;AACH;;;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACuC;AAChD;AACjC,iEAAe,8FAAwB,gCAAgC,qDAAY;AACnF;AACA;AACA;;AAEA;AACA,wFAAwF,+CAAO;AAC/F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,CAAC,EAAC;AACH;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACiB;AACsB;AACjF,iEAAe,8FAAwB,qCAAqC,qDAAY;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,qEAAgB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,CAAC,EAAC;AACH;;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACK;AAChC,8BAA8B,qDAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,+DAAU;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;ACzEA,4CAA4C,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;;AAEpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACK;AACA;AAChC,8BAA8B,qDAAY;AACzD;AACA;;AAEA,wDAAwD;;AAExD,yDAAyD;;AAEzD,sDAAsD;AACtD;;AAEA;AACA;AACA,oCAAoC,+DAAU;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,+DAAU;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACzHA,4CAA4C,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;;AAEpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiC;AACjC;AACA,UAAU;AACV;;AAEA;AACe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA,kCAAkC,uBAAuB;AACzD,IAAI;;;AAGJ;AACA,kCAAkC,uBAAuB;AACzD,IAAI;;;AAGJ;AACA,kCAAkC,uBAAuB;AACzD,IAAI;;;AAGJ;AACA,kCAAkC,uBAAuB;AACzD,IAAI;;;AAGJ;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,+CAAO;AACjB;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC,oBAAoB,oCAAoC,WAAW;AACrG;AACA;AACA;;;;;;;;;;;;;;;;AC7BA,4CAA4C,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;;AAEpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuC;AAC9E;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,+DAA+D;;AAE/D,kDAAkD;AAClD;;AAEA;AACA,mCAAmC,kGAA4B;AAC/D;;AAEA;AACA,sCAAsC,iBAAiB;AACvD;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,kGAA4B;AAC/D;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,kGAA4B;AAC/D;;AAEA;AACA,sCAAsC,iBAAiB;AACvD;;AAEA;;AAEA;AACA;;AAEA,oCAAoC,4DAA4D;AAChG;AACA;AACA,YAAY;;AAEZ,cAAc,+CAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,mDAAW;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,kGAA4B;AAC/D;AACA;;AAEA;AACA;AACA,mCAAmC,kGAA4B;AAC/D;AACA;;AAEA;AACA;AACA,mCAAmC,kGAA4B;AAC/D;AACA;;AAEA;AACA;AACA,mCAAmC,kGAA4B;AAC/D;AACA;;AAEA,GAAG;AACH;AACA,uCAAuC,gBAAgB;AACvD;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;;;;;;;;;;;;;;;;;AC3BA,2CAA2C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,iEAAiE,GAAG,kCAAkC;;AAEvU,iCAAiC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,4CAA4C,KAAK,6CAA6C,6EAA6E,OAAO,iDAAiD,mFAAmF,OAAO;;AAEtgB,4CAA4C,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;;AAEpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACH;AACxB;AAC1B;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;;AAEe;AACf,mBAAmB,6CAAI;AACvB,gBAAgB,iEAAc;;AAE9B;AACA;AACA;AACA,IAAI;AACJ,uBAAuB,mEAAS;AAChC;AACA;;AAEA,mEAAmE;AACnE;AACA;AACA;AACA;;AAEA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;;AAEA,IAAI,IAAI;AACR;AACA;AACA;AACA;;AAEA,IAAI,IAAI;AACR;AACA;AACA;AACA;;AAEA,IAAI,IAAI;AACR;AACA;;;;;;;;;;AC/Ea;;AAEb,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEsC;AACc;AACQ;;AAE5D;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,sCAAsC;AACtC,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,sCAAsC;AACtC,oEAAoE;AACpE;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2CAA2C;AAC3C;AACA,qEAAqE,+BAA+B;AACpG,yEAAyE,+BAA+B;AACxG;AACA,uEAAuE,mCAAmC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yBAAyB;AAC9E,mEAAmE,+BAA+B;AAClG,yEAAyE,+BAA+B;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2CAA2C;AAC3C;AACA,qEAAqE,+BAA+B;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA,gBAAgB,6DAAqB;AACrC;AACA;AACA,EAAE,IAAI;AACN;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,YAAY,GAAG;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,YAAY,2BAA2B;AACvC;AACA;AACA;AACA,kBAAkB,oDAAU;AAC5B;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA,UAAU,oBAAoB;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,QAAQ;AACvC;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,eAAe;AAC1B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA,aAAa,SAAS;AACtB,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,oBAAoB,UAAU;AAC9B,iCAAiC,uBAAuB;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA;AACA,aAAa,SAAS;AACtB;AACA,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,cAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,QAAQ;AACrB;AACA;AACA,aAAa,SAAS;AACtB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wDAAwD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAwD;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,QAAQ;AACrB;AACA;AACA,aAAa,SAAS;AACtB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wDAAwD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAwD;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,cAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,2BAA2B;AACzC;AACA;AACA;AACA,gBAAgB,yEAAc;AAC9B,+BAA+B,YAAY,QAAQ,cAAc;AACjE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;;AAElB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA,UAAU,iBAAiB;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,WAAW,eAAe;AAC1B,YAAY,kBAAkB;AAC9B;AACA;AACA,UAAU,iBAAiB;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA,4DAA4D,UAAU;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA,UAAU,iBAAiB;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,iBAAiB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA,UAAU,0BAA0B;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD,WAAW,eAAe;AAC1B,YAAY,kBAAkB;AAC9B;AACA;AACA,UAAU,0BAA0B;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,2BAA2B;AACtC,YAAY,2BAA2B;AACvC;AACA;AACA;AACA,SAAS,4BAA4B,EAAE,+CAA+C;AACtF;AACA;AACA,OAAO,EAAE,4BAA4B,EAAE,+CAA+C;AACtF;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD,WAAW,eAAe;AAC1B,YAAY,kBAAkB;AAC9B;AACA;AACA,UAAU,UAAU;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA,UAAU,UAAU;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,sDAAsD,YAAY,GAAG;AACrE,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,YAAY;AACZ,YAAY,OAAO;AACnB;AACA;AACA;AACA,6CAA6C;AAC7C,0BAA0B;AAC1B,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,SAAS;AACpB;AACA,YAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA,WAAW,SAAS;AACpB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,2BAA2B,8DAA8D;AACzF;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACoE;AACpE;;;;;;;;;;;;;;;ACn2FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACO;;;;;;;;;;;;;;;;AC5BP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;AAE5B;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,2BAA2B;AACvC;AACO,6BAA6B;AACpC,EAAE,yCAAG;AACL;AACA;AACA,GAAG;;;;;;;;;;;;;;;;;ACrCH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;AACiB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB,GAAG,sBAAsB,GAAG,sBAAsB;AAClG;AACA,eAAe,IAAI;AACnB;AACA,kBAAkB,sBAAsB,GAAG;AAC3C,oBAAoB,sBAAsB,SAAS;AACnD;AACA,eAAe,IAAI;AACnB;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,oDAAoD;AAChE;AACO,sCAAsC,6DAAqB;AAClE;AACA;AACA,EAAE,iDAAO;AACT;AACA;AACA,GAAG;;;;;;;;;;;;;;;;AC5DH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyE;;AAEzE;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,2BAA2B;AACvC;AACO,yBAAyB;AAChC,MAAM,iFAAyB;AAC/B;AACA,GAAG;;;;;;;UCpCH;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAKqC;AACS;AACR;AACsB;;AAE5D;AACA,cAAc,uDAAO;AACrB,UAAU,+CAAG;AACb,qBAAqB,qEAAc;AACnC,yBAAyB,iFAAyB;AAMhD","sources":["webpack://ImmutableLinkedOrderedMap/webpack/universalModuleDefinition","webpack://ImmutableLinkedOrderedMap/./node_modules/declarative-factory/src/index.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/index.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/array.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/bitwise.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/callback.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/color.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/combinatorics.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/constraint.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/convert.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/core/compare.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/core/index.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/date.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/fn.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/google.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/hash.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/iterator.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/map-coordinates.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/math.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/object.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/path.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/promise.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/rand.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/stats.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/string.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/time.js","webpack://ImmutableLinkedOrderedMap/./node_modules/js-utl/dist/es6/modules/web.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/advices/Advice.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/advices/AfterAdvice.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/advices/AroundAdvice.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/advices/BeforeAdvice.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/builtin/lazyObject.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/factory/handlerFactory.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pigretto.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/FunctionCallPointcut.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/MethodCallPointcut.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/ObjectConstructionPointcut.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/Pointcut.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/PropertyGettingPointcut.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/PropertySettingPointcut.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/shorthands/apply.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/shorthands/call.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/shorthands/construct.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/shorthands/get.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/pointcuts/shorthands/set.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/rules/ExactRule.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/rules/ORedRule.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/rules/RegexRule.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/rules/Rule.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/rules/applyRule.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/rules/constructRule.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/rules/parser/parseRule.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/rules/rulesGenerator.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/Trap.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/executors/ApplyTrapExecutor.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/executors/CallTrapExecutor.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/executors/ConstructTrapExecutor.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/executors/GetTrapExecutor.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/executors/SetTrapExecutor.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/executors/TrapExecutor.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/executors/behaviours/common/throwErrorIfDoesNotImplement.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/executors/behaviours/withFunctionTrapExecutor.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/reflect/reflectApply.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/reflect/reflectConstruct.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/reflect/reflectGet.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/reflect/reflectSet.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/dist/es6/trap/trapHandlerForRules.js","webpack://ImmutableLinkedOrderedMap/./node_modules/pigretto/node_modules/escape-string-regexp/index.js","webpack://ImmutableLinkedOrderedMap/./src/ImmutableLinkedOrderedMap.js","webpack://ImmutableLinkedOrderedMap/./src/constants.js","webpack://ImmutableLinkedOrderedMap/./src/shortcuts/lazyMap.js","webpack://ImmutableLinkedOrderedMap/./src/shortcuts/lazyMapFactory.js","webpack://ImmutableLinkedOrderedMap/./src/shortcuts/map.js","webpack://ImmutableLinkedOrderedMap/webpack/bootstrap","webpack://ImmutableLinkedOrderedMap/webpack/runtime/compat get default export","webpack://ImmutableLinkedOrderedMap/webpack/runtime/define property getters","webpack://ImmutableLinkedOrderedMap/webpack/runtime/global","webpack://ImmutableLinkedOrderedMap/webpack/runtime/hasOwnProperty shorthand","webpack://ImmutableLinkedOrderedMap/webpack/runtime/make namespace object","webpack://ImmutableLinkedOrderedMap/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ImmutableLinkedOrderedMap\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ImmutableLinkedOrderedMap\"] = factory();\n\telse\n\t\troot[\"ImmutableLinkedOrderedMap\"] = factory();\n})(this, function() {\nreturn ","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport { isArray } from \"js-utl\";\n\n/**\n * @type {Function}\n */\nconst testConditionFn = testCondition =>\n  Boolean(\n    typeof testCondition === \"function\" ? testCondition() : testCondition\n  );\n\n/**\n * A function to easily create interchangeable factories switching them\n * in a declarative way based on the given runtime parameters.\n *\n * @param {Function} tuples An array of tuples, each tuple being an array of two elements:\n *\n *                                - testCondition: A boolean value or a function returning a boolean value\n *                                                 which, if \"true\", instructs this function to return the \"factory\" factory\n *                                                 bound to this \"testCondition\".\n *                                                 Note that the first \"factory\" for which \"testCondition\" is truthy\n *                                                 will be returned and further tuples will be ignored;\n *\n *                                - factory: Anything. The value to return if \"testCondition\" is a truthy value\n *                                           or a function returning a truthy value.\n *\n *                            The last element of the returned tuples MAY not be a tuple array with two elements,\n *                            and in such case it will be treated as the default factory value to return if none\n *                            of the test conditions of the previous factories are satisfied.\n *                            If the last tuple is not a default value and none of the test conditions of the previous\n *                            factories are satisfied as well as for the factory of last tuple, then \"undefined\"\n *                            will be returned by this function.\n * @param {Array|undefined} deps Dependencies array to use.\n * @return {*} The first factory value for which the test is truthy or returns a truthy value, a default factory value,\n *             or \"undefined\".\n */\nexport default function declarativeFactory(tuples) {\n  const factoryValue = (() => {\n    let i = 0;\n    // Loop through all the tuples except the last one (handled after this loop).\n    for (; i < tuples.length - 1; i++) {\n      const tuple = tuples[i];\n      const [testCondition, factoryValue] = tuple;\n      if (testConditionFn(testCondition)) {\n        // Test condition for factory value is satisfied.\n        return factoryValue;\n      }\n    }\n    const lastTuple = tuples[i];\n    if (isArray(lastTuple) && lastTuple.length === 2) {\n      const [testCondition, factoryValue] = lastTuple;\n      if (testConditionFn(testCondition)) {\n        // Test condition for last factory value is satisfied.\n        return factoryValue;\n      }\n\n      // No default and no factory value satisfying a test condition.\n      return void 0;\n    } else {\n      // Default factory value.\n      return lastTuple;\n    }\n  })();\n\n  return factoryValue;\n}\n","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Public API exposed to client code.\n */\nexport { config, isObjectEmpty, isObject, isPlainObject, isArray, isEmpty, isEmptyOr0, getGlobalObject, uniqueId, deepArrayCompare, deepObjectCompare, nestedObjectConstructValue, cloneDeeplyJSON, isReferenceType, isPrimitiveType, hasCyclicReference, typeToStr, cloneObjDeeply, deepObjectExtend, deepObjectCloningExtend, extend, extendDecorate, shallowExtend, includesTypeCoercion, nestedPropertyValue, getNestedPropertyValue, hasNestedPropertyValue, setNestedPropertyValue, isUndefined, isInt, ctypeDigit, isIntegerOrIntegerStr, isCallable, findIndex, firstPropValue, isStrictlyTrue, isTruthy, allTruthy, allNotUndefined, isJSONString, noOpFn, is, shallowEqual, objectPropEqual, partialShallowEqual, shallowObjectDiff, nestedMapSet, nestedMapHas, nestedMapGet, nestedTreeMapSet, nestedTreeMapHas, nestedTreeMapGet, mapYield, str, mapObject, mapToObject, propSelection, prototypeChainProperties, prop, defineProperty, completeObjectAssign } from \"./modules/core\";\nexport { _, proceedCallingFn, curry, POJOCurry, compose, pipe, pick, liftBinaryFn, juxt, converge, execIfPOJOHas, execWithExistentProps, forGen, flatten, flattenDeep, cartesianProduct, identityFn, identityArgsFn, chain } from \"./modules/fn\";\nexport { stringHashArray, hashString, onePassStringHash } from \"./modules/hash\";\nexport { timeout, minDelayPromise, maxDelayFallbackPromise, applyAsync, composeAsync } from \"./modules/promise\";\nexport { buildQueryString, formData, xhr, checkNetwork, waitNetwork, setCookie, getCookie, unsetCookie, isInViewport, isScrolledIntoView, hasVerticalScrollbar, hasHorizontalScrollbar, elementUniqueId, getElementComputedStyle, elementInnerDimensions, countTextareaLines, isScrollOnBottom, getVerticalScrollBarWidth, isEllipsisActive, copyTextToClipboard, rAFLooper, nestedRAF, getRawURIFragment, getDecodedURIFragment, appendEncodedJSONFragmentToURI, getDecodedJSONFromFragmentURI, getQueryStringArgsMultiDim, cursorFocus, parseQueryStringArgsMultiDim, detectWrapped, maxNestingLevel, getScrollableAncestor, smoothScrollToTop } from \"./modules/web\";\nexport { randomInt, randomFloat, randomStr, randomDifferentFromValue, randomArrayShuffle, uuid, noncanonicalUUID } from \"./modules/rand\";\nexport { time, msToTime, millisecToSec } from \"./modules/time\";\nexport { escapeRegExp, trimCharacterMask, trimCharacterRegex, trim, trimLeft, trimRight, concatWithInnerOuterSeparators, optionsValueLabel, startsWith, ucaseFirst, reverseString, separateIntThousands } from \"./modules/string\";\nexport { googleMapBestZoomLevelFromBounds } from \"./modules/google\";\nexport { delay, debounce, throttle } from \"./modules/callback\";\nexport { basename, pathinfo, filenameExtension, dirname } from \"./modules/path\";\nexport { b2d, d2b } from \"./modules/convert\";\nexport { turnNthBitOff, turnNthBitOn, toggleNthBit, checkNthBitOn } from \"./modules/bitwise\";\nexport { getLuminance } from \"./modules/color\";\nexport { yieldCombinationsWithoutRepetition, uniqueProgressiveIncrementalCombinations, yieldUniqueProgressiveIncrementalCombinations, yieldAllSubsequences, yieldUniqueSubsequences, yieldPermutations } from \"./modules/combinatorics\";\nexport { round, sum, intDiv, isEven, isOdd, proportion } from \"./modules/math\";\nexport { unshiftArray, cloneArray, arraySliceFromValueToValue, areArrayItemsAllCoercibleToNumber, arrayOrArrayLike, lastOfArray, firstOfArray, arrayFindReverse, arrayMax, arrayMin, sortNums } from \"./modules/array\";\nexport { objectMin } from \"./modules/object\";\nexport { mean, median, minAbsDeviationFromValue, minAbsDeviationFromExcludedValue } from \"./modules/stats\";\nexport { clampLat, wrapLng, normalizeLat, normalizeLng } from \"./modules/map-coordinates\";\nexport { xrange } from \"./modules/iterator\";\nexport { isValidDate, isValidDateTimeStr } from \"./modules/date\";\nexport { filterInt, filterFloat } from \"./modules/constraint\";\n//# sourceMappingURL=index.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Array-related utility functions.\n */\n\n/**\n * Unshifts an array.\n *\n * @param {Array} arr The array.\n * @param {*} item The item to unshift.\n * @return {undefined}\n */\nexport function unshiftArray(arr, item) {\n  let len = arr.length;\n\n  while (len) {\n    arr[len] = arr[len - 1];\n    len--;\n  }\n\n  arr[0] = item;\n}\n/**\n * Clones an array.\n *\n * @param {Array} arr The array to clone.\n * @return {Array} The cloned array.\n */\n\nexport function cloneArray(arr) {\n  return arr.slice(0);\n}\n/**\n * Gets a slice of an array from a value up until another.\n *\n * @param {Array} arr The input array.\n * @param {number} from The \"from\" lower value.\n * @param {number} to The \"two\" upper value.\n * @return {Array} The slice as a new array.\n */\n\nexport function arraySliceFromValueToValue(arr, from, to) {\n  const ret = [];\n  let include = false;\n\n  for (const value of arr) {\n    if (!include && value == from) {\n      ret.push(value);\n      include = true;\n    } else if (include && value == to) {\n      ret.push(value);\n      break;\n    } else if (include) {\n      ret.push(value);\n    }\n  }\n\n  return ret;\n}\n/**\n * Tests whether all the elements of an array are coercible to a number or not.\n *\n * @param {Array} array An array.\n * @return {boolean} True if all the elements are coercible to a number, false otherwise.\n */\n\nexport function areArrayItemsAllCoercibleToNumber(array) {\n  const res = !array.some(isNaN);\n  return res;\n}\n/**\n * Copies an array or converts an array-like object to a new array.\n *\n * @param {*} arg Array or array-like object.\n * @return {Array} An array.\n */\n\nexport function arrayOrArrayLike(arg) {\n  return Array.prototype.slice.call(arg);\n}\n/**\n * Returns the last element of the given array.\n *\n * @param {Array} array An array.\n * @return {*} The last element of the array or undefined if there isn't one.\n */\n\nexport function lastOfArray(array) {\n  return array[array.length - 1];\n}\n/**\n * Returns the first element of the given array.\n *\n * @param {Array} array An array.\n * @return {*} The first element of the array or undefined if there isn't one.\n */\n\nexport function firstOfArray(array) {\n  return array[0];\n}\n/**\n * Like {@link Array.prototype.find}, but in reverse order.\n *\n * @param {Array} array An array.\n * @param {Function} fn Function to use for the test. The function will receive the array element as parameter.\n * @return {*} The first element which satisfies the test in the array by seeking for the element in reverse order\n *             (i.e. the last element of the array for which the test is satisfied).\n *             If no element satisfies the test, \"undefined\" is returned.\n */\n\nexport function arrayFindReverse(array, fn) {\n  let l = array.length;\n  let ret = void 0;\n\n  while (l) {\n    l--;\n\n    if (fn(array[l])) {\n      ret = array[l];\n      break;\n    }\n  }\n\n  return ret;\n}\n/**\n * Finds the maximum value of an array of numbers.\n *\n * @param {number[]} array An array of numbers.\n * @return {number|undefined} The maximum value of the array, or \"undefined\"\n *                            if the given array is empty.\n */\n\nexport const arrayMax = array => array.length ? array.reduce((carry, current) => current > carry ? current : carry, -Infinity) : void 0;\n/**\n * Finds the minimum value of an array of numbers.\n *\n * @param {number[]} array An array of numbers.\n * @return {number|undefined} The minimum value of the array, or \"undefined\"\n *                            if the given array is empty.\n */\n\nexport const arrayMin = array => array.length ? array.reduce((carry, current) => current < carry ? current : carry, +Infinity) : void 0;\n/**\n * Sorts an array of numbers returning a new array with the sorted\n * numbers (does not mutate the original).\n *\n * @param {number[]} arrayOfNums An array of numbers.\n * @param {boolean} [desc] True for descending order, false for ascending order (default).\n * @return {number[]} A new array with the sorted numbers.\n */\n\nexport const sortNums = (arrayOfNums, desc = false) => [...arrayOfNums].sort((a, b) => !desc // asc\n? a - b : // desc\nb - a);\n//# sourceMappingURL=array.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Bitwise utility functions.\n */\n\n/**\n * Turns nth bit off.\n *\n * @param {number} num A number.\n * @param {number} nth Nth bit to turn off (starting from 1 for the rightmost bit).\n * @return {number} New number with the nth bit turned off.\n */\nexport const turnNthBitOff = (num, nth) => num & ~(1 << nth - 1);\n/**\n * Turns nth bit on.\n *\n * @param {number} num A number.\n * @param {number} nth Nth bit to turn on (starting from 1 for the rightmost bit).\n * @return {number} New number with the nth bit turned off.\n */\n\nexport const turnNthBitOn = (num, nth) => num | 1 << nth - 1;\n/**\n * Toggles nth bit.\n *\n * @param {number} num A number.\n * @param {number} nth Nth bit to toggle (starting from 1 for the rightmost bit).\n * @return {number} New number with the nth bit toggled.\n */\n\nexport const toggleNthBit = (num, nth) => num ^ 1 << nth - 1;\n/**\n * Checks if nth bit is on.\n *\n * @param {number} num A number.\n * @param {number} nth Nth bit to check.\n * @param {number} 0 if the nth bit is off, otherwise a number greater than 0 if the nth bit is on.\n */\n\nexport const checkNthBitOn = (num, nth) => num & 1 << nth - 1;\n//# sourceMappingURL=bitwise.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Utility functions for callback handling (like debouncing, throttling).\n */\nimport { isUndefined } from \"./core\";\n/**\n * Delays execution of a callback and cancels a previously registered callback if it wasn't executed yet.\n */\n\nexport const delay = function () {\n  let timer = 0;\n  /**\n   * Inner function.\n   *\n   * @param {Function} callback The callback to execute.\n   * @param {number} ms Milliseconds to wait before executing the callback.\n   * @return {undefined}\n   */\n\n  return function (callback, ms) {\n    clearTimeout(timer);\n    timer = setTimeout(function () {\n      callback();\n    }, ms);\n  };\n}();\n/**\n * Debounces a function.\n *\n * @param {Function} fn A function.\n * @param {number} wait Wait interval in milliseconds.\n * @return {Function} A new function, debounced.\n */\n\nexport function debounce(fn, wait) {\n  let timer = void 0;\n  return function (...args) {\n    !isUndefined(timer) && clearTimeout(timer);\n    timer = setTimeout(function () {\n      fn(...args);\n    }, wait);\n  };\n}\n/**\n * Throttles a function.\n *\n * @see https://www.sitepoint.com/throttle-scroll-events/\n *\n * @param {Function} fn A function.\n * @param {number} wait Wait interval in milliseconds.\n * @return {Function} A new function, throttled.\n */\n\nexport function throttle(fn, wait) {\n  let time = Date.now();\n  return function (...args) {\n    if (time + wait - Date.now() < 0) {\n      fn(...args);\n      time = Date.now();\n    }\n  };\n}\n//# sourceMappingURL=callback.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Color-related utility functions.\n */\n\n/**\n * Gets a color's luminance.\n *\n * @param {number} color Color int value (RGB).\n * @return {number} An int greater than 160 if the color is considered dark and less than or\n *                  equal to 160 if the color is considered light.\n */\nexport function getLuminance(color) {\n  const c = parseInt(color, 16);\n  const r = (c & 0xff0000) >> 16;\n  const g = (c & 0x00ff00) >> 8;\n  const b = c & 0x0000ff;\n  return 0.299 * r + 0.587 * g + 0.114 * b;\n}\n//# sourceMappingURL=color.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Combinatorics utility functions.\n */\nimport { nestedMapSet, nestedMapHas, mapYield } from \"./core\";\nimport { arrayOrArrayLike } from \"./array\";\n/**\n * Yields all the combinations of an array without repetitions (binomial coefficient).\n *\n * @generator\n * @param {Array} items An array.\n * @param {number} numberOfItemsPerCombination The number of elements in each combination\n *                                             (this function assumes it to be less than \"items.length\"\n *                                             and greater than 0).\n * @param {boolean} yieldCopy True if the yielded combination should be a copy (default) or\n *                            the internal array used during the generation of the current combination.\n * @yields {Array} The next combination.\n */\n\nexport const yieldCombinationsWithoutRepetition = function* (items, numberOfItemsPerCombination, yieldCopy = true) {\n  const l = items.length;\n  const prefix = [];\n\n  const recurse = function* recurse(items, l, prefix, numberOfItemsPerCombination, nextIndex = 0) {\n    // Same as:\n    // if (nextIndex === numberOfItemsPerCombination) {\n    if (prefix.length === numberOfItemsPerCombination) {\n      // Base case:\n      yield yieldCopy ? arrayOrArrayLike(prefix) : prefix;\n    } else {\n      // Recurrent case:\n      for (let i = nextIndex; i < l && // Remaining needed items\n      numberOfItemsPerCombination - prefix.length <= // Remaining available items\n      l - i; i++) {\n        prefix.push(items[i]);\n        yield* recurse(items, l, prefix, numberOfItemsPerCombination, i + 1);\n        prefix.pop();\n      }\n    }\n  };\n\n  yield* recurse(items, l, prefix, numberOfItemsPerCombination);\n};\n/**\n * Generate unique, progressive and incremental combinations.\n *\n * @param {Array} items An array of items.\n * @return {Array[]} An array of arrays, each representing a unique progressive incremental combination.\n *                   An empty array is returned if the given items array is empty.\n */\n\nexport const uniqueProgressiveIncrementalCombinations = items => {\n  const len = items.length;\n\n  if (len === 0) {\n    return [];\n  }\n\n  const last = arrayOrArrayLike(items); // Shallow copy/clone of the given array.\n\n  if (len === 1) {\n    // [1] => [[1]]\n    return [last];\n  }\n\n  const ret = []; // [1], [2], [3], ..., [n]\n\n  items.map(item => ret.push([item]));\n\n  if (len > 2) {\n    // There  are at least three items.\n    for (let numberOfItemsPerCombination = 2; numberOfItemsPerCombination < len; numberOfItemsPerCombination++) {\n      for (const combination of yieldCombinationsWithoutRepetition(items, numberOfItemsPerCombination)) {\n        ret.push(combination);\n      }\n    }\n  }\n\n  ret.push(last);\n  return ret;\n};\n/**\n * Yields unique, progressive and incremental combinations.\n *\n * @generator\n * @param {Array} items An array of items.\n * @param {boolean} yieldCopy True if some of the yielded combinations should be a copy (default)\n *                         of the corresponding internal array used during the generation of the current combination\n *                         or that same array should be returned (if \"yieldCopy\" is \"false\").\n * @yields {Array} An array, each representing the next unique progressive incremental combination.\n *                 An empty array is yielded if the given items array is empty.\n */\n\nexport const yieldUniqueProgressiveIncrementalCombinations = function* (items, yieldCopy = true) {\n  const len = items.length;\n\n  if (len === 0) {\n    return;\n  }\n\n  const last = yieldCopy ? arrayOrArrayLike(items) : items; // Shallow copy/clone of the given array.\n\n  if (len === 1) {\n    // [1] => [[1]]\n    yield last;\n    return;\n  } // [1], [2], [3], ..., [n]\n\n\n  yield* mapYield(items, item => [item]);\n\n  if (len > 2) {\n    // There  are at least three items.\n    for (let numberOfItemsPerCombination = 2; numberOfItemsPerCombination < len; numberOfItemsPerCombination++) {\n      for (const combination of yieldCombinationsWithoutRepetition(items, numberOfItemsPerCombination, yieldCopy)) {\n        yield combination;\n      }\n    }\n  }\n\n  yield last;\n};\n/**\n * Yields all the subsequences of the given array of items.\n *\n * @generator\n * @param {Array} items An array of items to use to yield subsequences.\n * @yields {Array} The next subsequence.\n */\n\nexport const yieldAllSubsequences = function* (items) {\n  const l = items.length;\n\n  for (let i = 0; i <= l; i++) {\n    for (const combination of yieldCombinationsWithoutRepetition(items, i)) {\n      yield combination;\n    }\n  }\n};\n/**\n * Yields only the unique subsequences of the given array of items.\n *\n * @generator\n * @param {Array} items An array of items to use to yield subsequences.\n * @yields {Array} The next unique subsequence.\n */\n\nexport const yieldUniqueSubsequences = function* (items) {\n  const map = new Map();\n  yield [];\n\n  for (const subsequence of yieldAllSubsequences(items)) {\n    if (!nestedMapHas(map, subsequence)) {\n      nestedMapSet(map, subsequence, true);\n      yield subsequence;\n    }\n  }\n};\n/**\n * Yields all the permutations of the given array of items.\n *\n * @generator\n * @param {Array} items An array of items to use to yield permutations.\n * @param {boolean} yieldCopy True if the yielded permutation should be a copy (default) or\n *                            the internal array used during the generation of the current permutation.\n * @yields {Array} The next permutation.\n */\n\nexport const yieldPermutations = function* (items, yieldCopy = true) {\n  const currentPermutationPrefix = [];\n  const currentPermutationIndicesMap = {};\n\n  const permute = function* () {\n    if (currentPermutationPrefix.length === items.length) {\n      yield yieldCopy ? arrayOrArrayLike(currentPermutationPrefix) : currentPermutationPrefix;\n    } else {\n      for (let i = 0; i < items.length; i++) {\n        if (currentPermutationIndicesMap[i]) {\n          continue;\n        }\n\n        currentPermutationPrefix.push(items[i]);\n        currentPermutationIndicesMap[i] = true;\n        yield* permute();\n        delete currentPermutationIndicesMap[i];\n        currentPermutationPrefix.pop();\n      }\n    }\n  };\n\n  yield* permute();\n};\n//# sourceMappingURL=combinatorics.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Constraints and filtering utility functions.\n */\n\n/**\n * Filters the given string so that it only includes digit (0-9)\n * and an optional leading sign (\"+\", which is removed if present, or \"-\"),\n * i.e. represents a valid integer parsable with \"Number.parseInt()\".\n *\n * @param {string} str The input string.\n * @return {string} The valid input string or an empty string if there isn't any digit.\n */\nexport function filterInt(str) {\n  let filtered = str.replace(/[^0-9]/g, \"\");\n  filtered = filtered.replace(/^[0]+([1-9])/, \"$1\");\n  filtered = filtered.replace(/^[0]+$/, \"0\");\n\n  if (str && filtered.length && str[0] === \"-\") {\n    filtered = `-${filtered}`;\n  }\n\n  return filtered;\n}\n/**\n * Filters the given string so that it only includes digits (0-9), a decimal separator (\".\" character)\n * and an optional leading sign (\"+\", which is removed if present, or \"-\"),\n * i.e. represents a valid float parsable with \"Number.parseFloat()\".\n *\n * @param {string} str The input string.\n * @return {string} The valid float string or an empty string if there isn't any digit or decimal separator.\n *                  If there isn't any digit in the input string and there is a decimal separator (\".\" character),\n *                  the returned string will be \"0.\", i.e. a parsable \"0.\" string.\n */\n\nexport function filterFloat(str) {\n  let filtered = str.replace(/[^0-9.]/g, \"\");\n  const regex = /(\\..*)\\./g;\n  const replace = \"$1\";\n\n  do {\n    filtered = filtered.replace(regex, replace);\n  } while (filtered != filtered.replace(regex, replace));\n\n  filtered === \".\" ? filtered = \"0.\" : filtered;\n  filtered = filtered.replace(/^[0]+([1-9])/, \"$1\");\n  filtered = filtered.replace(/^[0]+($|\\.)/, \"0$1\");\n\n  if (str && filtered.length && str[0] === \"-\") {\n    filtered = `-${filtered}`;\n  }\n\n  return filtered;\n}\n//# sourceMappingURL=constraint.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Utility functions related to conversion of data from one format to another.\n */\n\n/**\n * Binary to decimal.\n *\n * @param {string} x Binary string.\n * @return {number} Decimal number.\n */\nexport const b2d = x => parseInt(x, 2);\n/**\n * Decimal to binary.\n *\n * @param {number} x Decimal number.\n * @return {string} Binary representation.\n */\n\nexport const d2b = x => x.toString(2);\n//# sourceMappingURL=convert.js.map","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks\n *\n */\n\n/**\n * @type {Function}\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Function implementing \"Object.is\" behaviour.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n *\n * @param {*} x The first value to compare.\n * @param {*} y The second value to compare.\n * @return {boolean} A boolean indicating whether or not the two arguments are the same value.\n */\n\nexport function is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n/**\n * Checks whether a prop of an object equals in the other object (shallow comparison).\n *\n * @param {Object} objA The first object.\n * @param {Object} objB The second object.\n * @param {string} prop The name of the property.\n * @return {boolean} True if the value of \"prop\" in \"objA\" is shallowly equal to the value of \"prop\" in \"objB\".\n */\n\nexport function objectPropEqual(objA, objB, prop) {\n  return hasOwnProperty.call(objB, prop) && is(objA[prop], objB[prop]);\n}\n/**\n * Performs equality by iterating through keys on an object and returning \"false\"\n * when any key has values which are not strictly equal between the arguments.\n * Returns \"true\" when the values of all keys are strictly equal.\n *\n * @see https://stackoverflow.com/questions/22266826/how-can-i-do-a-shallow-comparison-of-the-properties-of-two-objects-with-javascri#answer-37636728\n *\n * @param {*} objA First object.\n * @param {*} objB Second object.\n * @return {boolean}\n */\n\nexport function shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n\n  for (let i = 0; i < keysA.length; i++) {\n    const prop = keysA[i];\n\n    if (!objectPropEqual(objA, objB, prop)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n//# sourceMappingURL=compare.js.map","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport { shallowEqual, objectPropEqual, is } from \"./compare\";\nexport { shallowEqual, objectPropEqual, is };\n/**\n * Core utility functions.\n */\n\n/**\n * Optional configuration with useful properties.\n *\n * @type {Object}\n */\n\nexport const config = {\n  uniqueIdPrefix: \"\",\n  elementUniqueIdPrefix: \"\",\n  checkNetworkURI: null\n};\n/**\n * Tests if an object is empty.\n *\n * @param {Object} obj The object to test.\n * @return {boolean} \"true\" if the given object is empty (does not have own properties), \"false\" otherwise.\n */\n\nexport function isObjectEmpty(obj) {\n  for (const prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @type {string}\n */\n\nconst objPrototypeToString = Object.prototype.toString.call({});\n/**\n * Tests if a variable is an object.\n *\n * @param {*} obj The variable to test.\n * @return {boolean} \"true\" if \"obj\" is indeed an object, \"false\" otherwise.\n */\n\nexport const isObject = function (obj) {\n  return objPrototypeToString === Object.prototype.toString.call(obj);\n};\n/**\n * Tests if a variable is a plain object (i.e. \"{}\", an object literal).\n *\n * @param {*} obj The variable to test.\n * @return {boolean} \"true\" if \"obj\" is a plain object, \"false\" otherwise.\n */\n\nexport const isPlainObject = obj => {\n  return obj !== null && typeof obj === \"object\" && obj.constructor === Object && isObject(obj);\n};\n/**\n * Tests to see whether something is an array or not.\n *\n * @param {*} something A variable to check whether it is an array or not.\n * @return {boolean} True if the parameter passed in is an array, false otherwise.\n */\n\nexport function isArray(something) {\n  return Object.prototype.toString.call(something) === Object.prototype.toString.call([]);\n}\n/**\n * Tests if the given value is callable.\n *\n * @param {*} v The value.\n * @return {boolean} True if callable, false otherwise.\n */\n\nexport function isCallable(v) {\n  return typeof v === \"function\";\n}\n/**\n * Tests if a variable is empty returning true for empty strings and empty arrays.\n *\n * @param {*} data The variable to test.\n * @return {boolean} True if the variable is empty, false otherwise.\n */\n\nexport function isEmpty(data) {\n  return !data || data.length === 0;\n}\n/**\n * Tests if a variable is empty or 0 (\"0\" string) returning true for empty strings,\n * empty arrays, the \"0\" string and empty values.\n *\n * @param {*} data The variable to test.\n * @return {boolean} True if the variable is empty or \"0\", false otherwise.\n */\n\nexport function isEmptyOr0(data) {\n  return !data || data === \"0\" || data.length === 0;\n}\n/**\n * Returns a reference to the global object.\n *\n * @return {Window|global} The global object (this function is cross-platform aware).\n */\n\nexport function getGlobalObject() {\n  return typeof global !== \"undefined\" ? global : window;\n}\n/**\n * @type {string}\n */\n\nconst JSUtlUniqueIdCounterProp = \"JSUtlUniqueIdCounterLEzKKl87QCDxwVH\";\n/**\n * Generates a unique ID which can be used as an \"id\" attribute.\n *\n * @param {string|undefined} [uniqueIdPrefix] Local unique ID prefix which overrides the prefix\n *                                            set on the \"config\" configuration object.\n * @return {string} The unique ID.\n */\n\nexport function uniqueId(uniqueIdPrefix = void 0) {\n  const globalObject = getGlobalObject();\n  globalObject[JSUtlUniqueIdCounterProp] = globalObject[JSUtlUniqueIdCounterProp] || 0;\n  globalObject[JSUtlUniqueIdCounterProp]++;\n  const uniqueIdCounter = globalObject[JSUtlUniqueIdCounterProp];\n  const uniqueId = (uniqueIdPrefix || config.uniqueIdPrefix) + uniqueIdCounter;\n  return uniqueId;\n}\n/**\n * Gets a nested value of an object given an array of nested property names (keys).\n *\n * @param {Object} data JS POJO object.\n * @param {Array} props Array of object nested keys.\n * @return {*} The leaf value.\n */\n\nexport function nestedPropertyValue(data, props) {\n  let root = data;\n\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i];\n    root = root[prop];\n  }\n\n  return root;\n}\n/**\n * Alias for \"nestedPropertyValue\".\n *\n * @alias\n */\n\nexport const getNestedPropertyValue = nestedPropertyValue;\n/**\n * Checks if a nested value of an object given an array of nested property names (keys) exists.\n *\n * @param {Object} data JS POJO object.\n * @param {Array} props Array of object nested keys.\n * @return {boolean} True if the nested key exists, false otherwise.\n */\n\nexport function hasNestedPropertyValue(data, props) {\n  if (!props.length) {\n    return false;\n  }\n\n  let root = data;\n\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i];\n\n    if (!root[prop]) {\n      return false;\n    }\n\n    root = root[prop];\n  }\n\n  return true;\n}\n/**\n * Sets a nested value of an object given an array of nested property names (keys).\n *\n * @param {Object} data JS POJO object.\n * @param {Array} props Array of object nested keys.\n * @param {*} value Leaf value.\n * @return {undefined}\n */\n\nexport function setNestedPropertyValue(data, props, value) {\n  if (!props.length) {\n    return;\n  }\n\n  let root = data;\n  let prev = null;\n\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i];\n\n    if (typeof root[prop] !== \"object\") {\n      root[prop] = {};\n    }\n\n    prev = root;\n    root = root[prop];\n  }\n\n  if (prev) {\n    prev[props[props.length - 1]] = value;\n  }\n}\n/**\n * Sets a nested value on a nested map.\n *\n * @param {Map|WeakMap} map A map or weak map.\n * @param {Array} keys Array of keys to traverse. Each key will lead to a nested map.\n * @param {*} value The value to set at the inner key.\n * @return {undefined}\n */\n\nexport const nestedMapSet = (map, keys, value) => {\n  let i = 0;\n  let current = map;\n\n  while (i < keys.length - 1) {\n    const key = keys[i];\n    const nested = current.get(key);\n\n    if (nested instanceof Map || nested instanceof WeakMap) {\n      current = nested;\n    } else {\n      const newMap = new Map();\n      current.set(key, newMap);\n      current = newMap;\n    }\n\n    i++;\n  }\n\n  current.set(keys[i], value);\n};\n/**\n * Tests if a map has the given nested keys.\n *\n * @param {Map|WeakMap} map A map or weak map.\n * @param {Array} keys Array of keys to check. Each key represents a nested map.\n * @return {boolean} \"true\" if all the nested keys exist, false otherwise.\n */\n\nexport const nestedMapHas = (map, keys) => {\n  let current = map;\n  let i = 0;\n  const l = keys.length;\n\n  while ((current instanceof Map || current instanceof WeakMap) && current.has(keys[i]) && i < l) {\n    current = current.get(keys[i]);\n    i++;\n  }\n\n  return i == l;\n};\n/**\n * Gets a value from a nested map.\n *\n * @param {Map|WeakMap} map A map or weak map.\n * @param {Array} keys Array of keys. Each key represents a nested map.\n * @return {*} The value of the map or \"undefined\" if there is no value for the given nested keys.\n */\n\nexport const nestedMapGet = (map, keys) => {\n  let current = map;\n  let i = 0;\n  const l = keys.length;\n\n  while ((current instanceof Map || current instanceof WeakMap) && current.has(keys[i]) && i < l) {\n    current = current.get(keys[i]);\n    i++;\n  }\n\n  return i == l ? current : void 0;\n};\n/**\n * @type {Symbol}\n */\n\nconst treeMapSubtree = Symbol(\"treeMapSubtree\");\n/**\n * Sets a nested value on a nested tree map.\n *\n * @param {Map|WeakMap} rootMap A map or weak map to use as the root.\n * @param {Array} keys Array of keys to traverse. Each key will lead to a nested node of the tree map.\n * @param {*} value The value to set at the inner nested key.\n * @return {undefined}\n */\n\nexport const nestedTreeMapSet = (rootMap, keys, value) => {\n  let i = 0;\n  let current = rootMap;\n  const MapConstructor = rootMap instanceof WeakMap ? WeakMap : Map;\n\n  while (i < keys.length - 1) {\n    const key = keys[i];\n    const nested = current.get(key);\n\n    if (nested) {\n      current = nested[treeMapSubtree] || (nested[treeMapSubtree] = new MapConstructor());\n    } else {\n      const newMap = new MapConstructor();\n      const node = {\n        [treeMapSubtree]: newMap,\n        value: void 0\n      };\n      current.set(key, node);\n      current = newMap;\n    }\n\n    i++;\n  }\n\n  const key = keys[i];\n  !current.has(key) ? current.set(key, {\n    value\n  }) : current.get(key).value = value;\n};\n/**\n * Tests if a tree map has the given nested keys.\n *\n * @param {Map|WeakMap} rootMap The root of the map or weak map.\n * @param {Array} keys Array of keys to check. Each key represents a nested node of the tree map.\n * @return {boolean} \"true\" if all the nested keys exist, false otherwise.\n */\n\nexport const nestedTreeMapHas = (rootMap, keys) => {\n  let current = rootMap;\n  let i = 0;\n  const l = keys.length;\n\n  while ((current instanceof Map || current instanceof WeakMap) && current.has(keys[i]) && i < l) {\n    current = current.get(keys[i])[treeMapSubtree];\n    i++;\n  }\n\n  return i == l;\n};\n/**\n * Gets a value from a nested tree map.\n *\n * @param {Map|WeakMap} rootMap The root of the map or weak map.\n * @param {Array} keys Array of keys. Each key represents a nested node of the tree map.\n * @return {*} The value of the tree map or \"undefined\" if there is no value for the given nested keys.\n */\n\nexport const nestedTreeMapGet = (rootMap, keys) => {\n  let current = rootMap;\n  let i = 0;\n  const lastIndex = keys.length - 1;\n\n  while ((current instanceof Map || current instanceof WeakMap) && current.has(keys[i]) && i < lastIndex) {\n    current = current.get(keys[i])[treeMapSubtree];\n    i++;\n  }\n\n  if (i === lastIndex && current) {\n    const lastKey = keys[i];\n\n    if (current.has(lastKey)) {\n      const nested = current.get(lastKey);\n      return nested.value;\n    }\n  }\n\n  return void 0;\n};\n/**\n * Yields values of an array mapping the yielded value.\n *\n * @generator\n * @param {Array} items An array of items.\n * @param {*} fn The function to call.\n *               The function will receive, in order the nth item,\n *               the index of the item in the array of items and the whole items array\n *               as parameters.\n * @param {*} thisArg Optional this arg of the called function (defaults to undefined).\n * @yields {*} The next yielded mapped item.\n */\n\nexport function* mapYield(items, fn, thisArg = void 0) {\n  items.map();\n  const boundFn = fn.bind(thisArg);\n\n  for (let i = 0; i < items.length; i++) {\n    yield boundFn(items[i], i, items);\n  }\n}\n/**\n * Compares two arrays deeply.\n *\n * @param {Array} arr1 First array.\n * @param {Array} arr2 Second array.\n * @return {boolean} True if they are equal (same indexes and same values), false otherwise.\n */\n\nexport function deepArrayCompare(arr1, arr2) {\n  if (arr1.length != arr2.length) {\n    return false;\n  }\n\n  const toString = Object.prototype.toString;\n  const arrayToStringStr = toString.call([]);\n\n  for (let i = 0; i < arr1.length; i++) {\n    if (!(i in arr2)) {\n      return false;\n    } else if (isPlainObject(arr1[i])) {\n      if (!isPlainObject(arr2[i]) || // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      !deepObjectCompare(arr1[i], arr2[i])) {\n        return false;\n      }\n    } else if (arrayToStringStr === toString.call(arr1[i])) {\n      if (arrayToStringStr !== toString.call(arr2[i]) || !deepArrayCompare(arr1[i], arr2[i])) {\n        return false;\n      }\n    } else {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Compare two objects deeply.\n *\n * @param {Object} obj1 First object.\n * @param {Object} obj2 Second object.\n * @return {boolean} True if they are equal (same properties and same values), false otherwise.\n */\n\nexport function deepObjectCompare(obj1, obj2) {\n  const toString = Object.prototype.toString;\n  const arrayToStringStr = toString.call([]);\n\n  for (const property in obj1) {\n    if (!(property in obj2)) {\n      // `obj2[property]` does not contain the property of `obj1`.\n      return false;\n    } else if (isPlainObject(obj1[property])) {\n      // `obj1[property]` is an object.\n      if (!isPlainObject(obj2[property]) || !deepObjectCompare(obj1[property], obj2[property])) {\n        // `obj2[property]` is not an object or the branches are different.\n        return false;\n      }\n    } else if (arrayToStringStr === toString.call(obj1[property])) {\n      // `obj1[property]` is an array.\n      if (arrayToStringStr !== toString.call(obj2[property]) || !deepArrayCompare(obj1[property], obj2[property])) {\n        // `obj2[property]` is not an array or the two objects are different.\n        return false;\n      }\n    } else {\n      // `obj1[property]` is not an object and is not an array.\n      if (obj1[property] !== obj2[property]) {\n        return false;\n      }\n    }\n  } // `obj1` equals `obj2` (has the same properties and the same values).\n\n\n  return true;\n}\n/**\n * Nests the properties of an object using an array of props definitions and defaults.\n * Returns the leaf.\n * Example:\n *\n *      var obj = {};\n *      var nest = [{a: {}}, {b: {}}, {c: {}}, {d: {}}, {e: {}}, {f: {}}, {g: {}}, {h: {}} ];\n *      var leaf = nestedObjectConstructValue(obj, nest);\n *      leaf.i = 'i';\n *      leaf.l = { m: \"m\" };\n *      JSON.stringify(obj); // {\"a\":{\"b\":{\"c\":{\"d\":{\"e\":{\"f\":{\"g\":{\"h\":{\"i\":\"i\",\"l\":{\"m\":\"m\"}}}}}}}}}}\n *      nest = nest.concat([ {n: {}}, {o: {}}, {p: {}} ]);\n *      var pLeaf = nestedObjectConstructValue(obj, nest);\n *      pLeaf.q = 'q';\n *      nest = nest.concat([ {q: {}} ]);\n *      nestedObjectConstructValue(obj, nest); // 'q'\n *\n * @param {Object} root The root object.\n * @param {Array} nestedPropsDef The nexted props definitions.\n * @param {boolean} [isRootArrayIfRootFalsy] True if the root should be an array if the first argument \"root\" is falsy.\n * @return {*} The leaf.\n */\n\nexport function nestedObjectConstructValue(root, nestedPropsDef, isRootArrayIfRootFalsy) {\n  root = root || (isRootArrayIfRootFalsy ? [] : {});\n  let leaf = root;\n\n  for (let i = 0; i < nestedPropsDef.length; i++) {\n    const propDef = nestedPropsDef[i];\n    const propKey = Object.keys(propDef)[0];\n    const propDefault = propDef[propKey];\n    leaf[propKey] = leaf[propKey] || propDefault;\n    leaf = leaf[propKey];\n  }\n\n  return leaf;\n}\n/**\n * Clones an object deeply using the JSON API.\n *\n * @param {Object} obj The object to clone.\n * @return {Object} The cloned object.\n */\n\nexport function cloneDeeplyJSON(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n * Tests whether the given value is a reference type or not.\n *\n * @param {*} value Any value which can be an object or a primitive type.\n * @return {boolean} True if the given value is a reference type, false otherwise.\n */\n\nexport function isReferenceType(value) {\n  return new Object(value) === value;\n}\n/**\n * Tests whether the given value is a primitive type or not.\n *\n * @param {*} value Any value which can be an object or a primitive type.\n * @return {boolean} True if the given value is a primitive type, false otherwise.\n */\n\nexport function isPrimitiveType(value) {\n  return new Object(value) !== value;\n}\n/**\n * Checks whether an object has a cyclic reference or not.\n *\n * @param {Object} obj The object to check for a cyclic reference.\n * @return {boolean} True if the object has a cyclic reference, false otherwise.\n */\n\nexport function hasCyclicReference(obj) {\n  const stackSet = [];\n  let detected = false;\n\n  function detect(obj) {\n    if (detected) {\n      return;\n    }\n\n    if (typeof obj !== \"object\") {\n      return;\n    }\n\n    const indexOfObj = stackSet.indexOf(obj);\n\n    if (indexOfObj !== -1) {\n      detected = true;\n      return;\n    }\n\n    stackSet.push(obj);\n\n    for (const k in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, k)) {\n        detect(obj[k]);\n      }\n    }\n\n    stackSet.splice(indexOfObj, 1);\n    return;\n  }\n\n  detect(obj);\n  return detected;\n}\n/**\n * Converts a type to its string representation.\n *\n * @param {*} type A variable.\n * @return {string} The string representation of \"type\".\n */\n\nexport function typeToStr(type) {\n  return Object.prototype.toString.call(type);\n}\n/**\n * Clones an object deeply and returns the clone.\n *\n * @param {Object} object The object to clone.\n * @return {Object} The clone.\n * @throws {Error} If a circular reference if even only one property is of an unkown type\n *                 (this should never happen) or a circular reference is detected.\n */\n\nexport function cloneObjDeeply(object) {\n  const newObject = new object.constructor();\n\n  for (const prop in object) {\n    // If the property is defined on the prototype, ignore it. We don't want to assign it for each clone instance.\n    if (!Object.prototype.hasOwnProperty.call(object, prop)) {\n      continue;\n    }\n\n    const property = object[prop];\n\n    if (isPrimitiveType(property)) {\n      newObject[prop] = property;\n    } else if (isReferenceType(property)) {\n      if (!hasCyclicReference(property)) {\n        const clone = cloneObjDeeply(property);\n        newObject[prop] = clone;\n      } else {\n        throw new Error(\"Circular reference detected inside of property '\" + prop + \"' (\" + typeToStr(property) + \") in object (\" + typeToStr(object) + \")\");\n      }\n    } else {\n      throw new Error(\"Oops! Unknown type for property '\" + prop + \"' (\" + typeToStr(property) + \") in object (\" + typeToStr(object) + \")\");\n    }\n  }\n\n  return newObject;\n}\n/**\n * Deep object extension implementation.\n * Nothing is returned, but the destination object will be modified and merged with the source object\n * so that properties of the source object which are objects will recursively merge with the corresponding\n * destination property while the other properties with all the other types will replace the properties of the\n * destination object.\n * Note that this method should not be used for inheritance via the Prototypal Combination Inheritance pattern.\n * Also, this method doesn't perform a deep object cloning, it just extends the destinationObject by adding properties\n * it doesn't have in a deep way.\n *\n * @param {Object} destinationObject The destination object which will be modified and merged with the source object.\n * @param {Object} sourceObject The source object which will be used to extend the destination object.\n * @param {Object} [options] An object containing the options for the extension.\n *                           The currently available options are:\n *\n *                               - extendsArrays (boolean: false): Whether or not to extend nested arrays too (defaults to false);\n *\n * @return {undefined}\n */\n\nexport function deepObjectExtend(destinationObject, sourceObject, options = {}) {\n  for (const property in sourceObject) {\n    if (sourceObject[property] && isPlainObject(sourceObject[property])) {\n      destinationObject[property] = destinationObject[property] || {};\n      deepObjectExtend(destinationObject[property], sourceObject[property], options);\n    } else if (options.extendArrays && sourceObject[property] && isArray(sourceObject[property])) {\n      destinationObject[property] = destinationObject[property] || [];\n      deepObjectExtend(destinationObject[property], sourceObject[property], options);\n    } else {\n      destinationObject[property] = sourceObject[property];\n    }\n  }\n}\n/**\n * Deep object cloning extension implementation. If the source objects contain a property with a reference type, a clone object\n * of the same type of that property will be created and then merged with the property object of the destination object.\n *\n * @param {Object} destinationObject The destination object which will be modified and merged with the source object.\n * @param {...Object} sourceObject One or more objects which will be used to extend the destination object.\n * @return {undefined}\n */\n\nexport function deepObjectCloningExtend(...args) {\n  const destinationObject = args[0];\n  let sourceObject;\n\n  for (let i = 1; args[i]; i++) {\n    sourceObject = args[i];\n\n    for (const property in sourceObject) {\n      if (sourceObject[property] && isPlainObject(sourceObject[property])) {\n        destinationObject[property] = destinationObject[property] || {};\n        deepObjectExtend(destinationObject[property], cloneObjDeeply(sourceObject[property]));\n      } else {\n        destinationObject[property] = sourceObject[property];\n      }\n    }\n  }\n}\n/**\n * Extends a destination object with the provided source objects.\n *\n * @param {Object} destinationObj The destination object.\n * @param {...Object|Array} sourceObjects The source objects. If the last argument is an array containing one single truthy element,\n *                                        it will be treated as an options parameter and its single first truthy element will be treated as object\n *                                        containing the options for the extension.\n *                                        The currently available options are:\n *\n *                                            - extendsArrays (boolean: false): Whether or not to extend nested arrays too (defaults to false);\n *\n * @return {Object} The destination object \"destinationObj\" given as parameter after extension.\n */\n\nexport function extend(destinationObj, ...sourceObjects) {\n  let options = {};\n\n  if (sourceObjects.length) {\n    const last = sourceObjects.pop();\n\n    if (isArray(last) && last.length === 1 && isPlainObject(last[0])) {\n      options = last[0];\n    } else {\n      sourceObjects.push(last);\n    }\n  }\n\n  for (const sourceObject of sourceObjects) {\n    deepObjectExtend(destinationObj, sourceObject, options);\n  }\n\n  return destinationObj;\n}\n/**\n * Extends a destination object with the provided source objects.\n *\n * @param {Object} destinationObject The destination object.\n * @param {...*} rest The source objects with the last parameter being an array of rules,\n *                    each rule being a tuple array where the first element is an array of \"ORed\" property names (strings or numbers)\n *                    or regexes matching property names for which the corresponding values should be decorated\n *                    (or a single property name or regex matching a property name if the decoration should only happen on a single property),\n *                    and where the second element is a callback to execute for each value which is a value of a property\n *                    of a source object.\n *                    The callback has the following signature:\n *\n *                        (value: *, prop: string|number, parent: Object) => *|undefined\n *\n *                    The callback will receive the final value after extension, its associated property and the parent object\n *                    where that property is set with that value.\n *                    Its returned value will be used as the final value of the property for that object in \"destinationObject\".\n *\n *                    If the last parameter is not an array of rules, it will be treated as the last source object to use for the extension\n *                    (the \"extend\" function will be simply called under the hood without any decoration logic).\n * @return {Object} The destination object \"destinationObject\" given as parameter after extension and, if the callback is given\n *                  as the last parameter, after applying the given callback.\n */\n\nexport function extendDecorate(destinationObject, ...rest) {\n  const rules = rest[rest.length - 1];\n\n  if (isArray(rules)) {\n    rest.pop();\n    const sourceObjects = rest;\n    const initialRetValue = {};\n    const matchedRulesMap = new Map();\n    const callbacksMap = new Map();\n    const paths = [];\n\n    const mapKeys = (destinationObject, sourceObject, currentStack, currentPath) => {\n      for (const key in sourceObject) {\n        currentStack.push({\n          destinationObject,\n          sourceObject,\n          property: key,\n          path: [...currentPath, key]\n        });\n      }\n    };\n\n    const matchRule = (rule, property) => {\n      if (rule instanceof RegExp && typeof property === \"string\") {\n        return property.match(rule);\n      } else {\n        return rule === property;\n      }\n    };\n\n    const matchArrayRule = (arrayRule, property) => {\n      for (const rule of arrayRule) {\n        if (matchRule(rule, property)) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const ruleMatches = (rule, property) => {\n      if (isArray(rule)) {\n        return matchArrayRule(rule, property);\n      } else {\n        return matchRule(rule, property);\n      }\n    };\n\n    const matchRules = property => {\n      if (!matchedRulesMap.has(property)) {\n        const callbacks = [];\n\n        for (const [rule, callback] of rules) {\n          if (ruleMatches(rule, property)) {\n            callbacks.push(callback);\n          }\n        }\n\n        matchedRulesMap.set(property, callbacks);\n      }\n\n      return matchedRulesMap.get(property);\n    };\n\n    for (const sourceObject of sourceObjects) {\n      const currentStack = [];\n      const currentPath = [];\n      mapKeys(destinationObject, sourceObject, currentStack, currentPath);\n\n      while (currentStack.length) {\n        const {\n          destinationObject,\n          sourceObject,\n          property,\n          path: currentPath\n        } = currentStack.pop();\n\n        if (sourceObject[property] && isPlainObject(sourceObject[property])) {\n          // \"sourceObject[property]\" is an object of class \"Object\".\n          destinationObject[property] = isPlainObject(destinationObject[property]) ? destinationObject[property] : {};\n          mapKeys(destinationObject[property], sourceObject[property], currentStack, currentPath);\n        } else {\n          // \"sourceObject[property]\" is not an object.\n          destinationObject[property] = sourceObject[property];\n        }\n\n        const callbacks = matchRules(property);\n\n        if (callbacks && callbacks.length) {\n          if (!nestedTreeMapHas(callbacksMap, currentPath)) {\n            paths.push([...currentPath]);\n          }\n\n          nestedTreeMapSet(callbacksMap, currentPath, callbacks.map(callback => retValue => path => {\n            const value = retValue === initialRetValue ? destinationObject[property] : retValue;\n            return callback(value, property, destinationObject, path);\n          }));\n        }\n      }\n    } // Decorating the final nested values.\n\n\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const path = paths[i];\n      const callbacks = nestedTreeMapGet(callbacksMap, path) || [];\n      let retValue = initialRetValue;\n\n      for (const callback of callbacks) {\n        retValue = callback(retValue)(path);\n      }\n\n      if (retValue !== initialRetValue) {\n        setNestedPropertyValue(destinationObject, path, retValue);\n      }\n    }\n\n    return destinationObject;\n  } else {\n    return extend(destinationObject, ...rest);\n  }\n}\n/**\n * Shallowly extends a destination object with the provided source objects (first dimension).\n *\n * @param {Object} destinationObject The destination object.\n * @param {...Object} sourceObjects The source objects.\n * @return {Object} The destination object \"destinationObject\" given as parameter after shallow extension.\n */\n\nexport function shallowExtend(destinationObject, ...sourceObjects) {\n  sourceObjects.map(obj => Object.keys(obj).map(key => destinationObject[key] = obj[key]));\n  return destinationObject;\n}\n/**\n * Like \"Array.prototype.includes\", but with type coercion.\n *\n * @param {Array} array The array.\n * @param {Anything} value The value.\n * @return {boolean} True if the value is included within the array (checking with type coercion`==`).\n */\n\nexport function includesTypeCoercion(array, value) {\n  for (const valueOfArray of array) {\n    if (valueOfArray == value) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Tests whether a value is undefined or not.\n *\n * @param {*} value A value\n * @return {boolean} True value is undefined, false otherwise.\n */\n\nexport function isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n/**\n * Tests if the given value is an int.\n *\n * @param {*} value The value.\n * @return {boolean} True if value is an int, false otherwise.\n */\n\nexport function isInt(value) {\n  return Number.isInteger(value);\n}\n/**\n * Tests if the given string is an integer string.\n *\n * @param {*} a The string.\n * @return {boolean} True if the given string is an integer string, false otherwise.\n */\n\nexport function ctypeDigit(a) {\n  return Boolean(a.match(/^[0-9]+$/));\n}\n/**\n * Tests if the given value is an int or an integer string.\n *\n * @param {*} a The value.\n * @return {boolean} True if the value is an int or an integer string, false otherwise.\n */\n\nexport function isIntegerOrIntegerStr(a) {\n  return Number.isInteger(a) || ctypeDigit(a);\n}\n/**\n * Finds the index of a value in an array without type juggling\n * (i.e. like \"Array.prototype.indexOf\", but using \"==\" for equality comparison).\n *\n * @param {Array} array An array.\n * @param {*} value A value.\n * @return {number} -1 if the value is not in array, otherwise the index of value in array.\n */\n\nexport function findIndex(array, value) {\n  return array.findIndex(el => el == value);\n}\n/**\n * Returns the first value of the first property of an object.\n *\n * @param {Object} obj The object.\n * @return {*} The value of the first property of the given object.\n */\n\nexport function firstPropValue(obj) {\n  let prop;\n\n  for (prop in obj) {\n    break;\n  }\n\n  return obj[prop];\n}\n/**\n * Tests if a value is strictly a boolean \"true\".\n *\n * @param {*} value A value.\n * @return {boolean} \"true\" if the value is a boolean \"true\", \"false\" otherwise.\n */\n\nexport function isStrictlyTrue(value) {\n  return value === true;\n}\n/**\n * Tests if a value is truthy or not.\n *\n * @param {*} value The value.\n * @return {boolean} \"true\" if the value is truthy (evaluates to boolean \"true\"), \"false\" otherwise.\n */\n\nexport function isTruthy(value) {\n  return Boolean(value);\n}\n/**\n * Tests if all the given values are truthy.\n *\n * @param {...*} values The values.\n * @return {boolean} \"true\" if and only if all the values are truthy.\n */\n\nexport function allTruthy(...values) {\n  return values.every(isTruthy);\n}\n/**\n * Tests if all the given values are not undefined.\n *\n * @param {...*} values The values.\n * @return {boolean} \"true\" if and only if all the values are not undefined.\n */\n\nexport function allNotUndefined(...values) {\n  return values.every(value => typeof value !== \"undefined\");\n}\n/**\n * Tests if a string is a valid JSON string.\n *\n * @param {string} str A string.\n * @return {boolean} \"true\" if the string represents a valid JSON string, \"false\" otherwise.\n */\n\nexport function isJSONString(str) {\n  try {\n    JSON.parse(str);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * No-op function.\n *\n * @return {undefined}\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\n\nexport function noOpFn() {}\n/**\n * Tests if a partial object is a subset of another object.\n *\n * @param {Object} obj An object.\n * @param {Object} partialObj A partial object which may not have all the keys of \"obj\"\n *                            or may even have different keys, or keys with different values.\n * @return {boolean} False if \"partialObj\" has a key which is not in \"obj\",\n *                   or has at least one key which is also in \"obj\" but with a different value\n *                   (shallow comparison), true otherwise.\n */\n\nexport function partialShallowEqual(obj, partialObj) {\n  return shallowEqual(Object.keys(partialObj).reduce((carry, key) => {\n    carry[key] = obj[key];\n    return carry;\n  }, {}), partialObj);\n}\n/**\n * Returns a shallow object diff, returning an object with two keys \"objA\" and \"objB\",\n * each containing an object with all the properties of one of the two objects which are not within\n * the other object, respectively.\n * If a property is on both objects but each object has a different value for that same property\n * (using shallow equality comparison), the returned property will be set on both objects with their\n * respective values.\n *\n * @param {Object} objA First object.\n * @param {Object} objB Second object.\n * @return {Object} An object containing the shallow diff, with two keys \"objA\" and \"objB\".\n */\n\nexport function shallowObjectDiff(objA, objB) {\n  const diff = {\n    objA: {},\n    objB: {}\n  };\n\n  if (shallowEqual(objA, objB)) {\n    return diff;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  for (let i = 0; i < keysA.length; i++) {\n    const prop = keysA[i];\n\n    if (!objectPropEqual(objA, objB, prop)) {\n      diff.objA[prop] = objA[prop];\n\n      if (hasOwnProperty.call(objB, prop)) {\n        diff.objB[prop] = objB[prop];\n      }\n    }\n  }\n\n  for (let i = 0; i < keysB.length; i++) {\n    const prop = keysB[i];\n\n    if (!objectPropEqual(objB, objA, prop)) {\n      diff.objB[prop] = objB[prop];\n\n      if (hasOwnProperty.call(objA, prop)) {\n        diff.objA[prop] = objA[prop];\n      }\n    }\n  }\n\n  return diff;\n}\n/**\n * Casts a value to a string.\n *\n * @param {*} v A value.\n * @return {string} The string representation of the value.\n */\n\nexport function str(v) {\n  return \"\" + v;\n}\n/**\n * Maps an object, executing a function on each of its properties\n * returning a new mapped object.\n *\n * @param {Object} obj The object to map.\n * @param {Function} fn The function to use for the mapping.\n * @return {Object} The new mapped object.\n */\n\nexport const mapObject = (obj, fn) => Object.fromEntries(Object.entries(obj).map(([key, value], index) => [key, fn(value, key, index)]));\n/**\n * Maps an array to an object.\n *\n * @param {Array} arr An array.\n * @param {Function} fn A function receiving the current value, its index as well as the whole array \"arr\"\n *                      as parameters returning a tuple with the key at index 0 and the value at index 1 to set on the object.\n * @returns {Object} The array mapped to an object.\n */\n\nexport const mapToObject = (arr, fn) => {\n  let res;\n  return arr.reduce((carry, ...rest) => (res = fn(...rest)) && false || (carry[res[0]] = res[1]) && false || carry, {});\n};\n/**\n * Selects the truthy properties of an object or the properties of an object\n * passing a test specified with a callback function.\n *\n * @param {Object} obj The input object.\n * @param {Function} fn A function which will receive two parameters:\n *\n *                          - value: The current value of the input object for a given property;\n *                          - prop: The name of the current property of the input object.\n *\n *                      The function will have to return a boolean \"true\" indicating that this value\n *                      and property has to be included in the returned object, or \"false\" otherwise.\n *\n * @return {Object} An object having only the properties which passed the test\n *                  implemented by the \"fn\" callback function.\n */\n\nexport const propSelection = (obj, fn = isTruthy) => Object.keys(obj).reduce((carry, key) => {\n  if (fn(obj[key], key)) {\n    carry[key] = obj[key];\n  }\n\n  return carry;\n}, {});\n/**\n * Returns all the properties of the given object traversing its prototype chain.\n *\n * @param {Object} obj The object.\n * @param {Object} [options] An object with options.\n * @param {?Object} [options.stopAtPrototype] The prototype in the chain at which to stop the traversing.\n *                                            Defaults to null, in which case the whole prototype chain will be traversed.\n * @param {boolean} [options.stopAtPrototypeInclude] Whether or not to include the properties of the given prototype at which to stop.\n *                                                   Works only if \"stopAtPrototype\" is set to a valid prototype object in the prototype chain\n *                                                   of \"obj\".\n *                                                   Defaults to true, in which case the properties of the prototype at which to stop will be included\n *                                                   in the returned array.\n * @return {string[]} An array of containing the names of the properties.\n */\n\nexport function prototypeChainProperties(obj, {\n  stopAtPrototype = null,\n  stopAtPrototypeInclude = true\n} = {}) {\n  let current = obj;\n  const map = {};\n  let isStopPrototype = false;\n  let stop = false;\n\n  while (!stop && current && (!isStopPrototype || stopAtPrototypeInclude)) {\n    if (isStopPrototype) {\n      stop = true;\n    }\n\n    const properties = Object.getOwnPropertyNames(current);\n    properties.map(property => map[property] = true);\n    current = Object.getPrototypeOf(current);\n\n    if (stopAtPrototype) {\n      isStopPrototype = current === stopAtPrototype;\n    }\n  }\n\n  const properties = Object.keys(map);\n  return properties;\n}\n/**\n * Defines an object's property with a getter and an optional setter.\n *\n * @param {Object} obj An object (may be a prototype).\n * @param {string} propname The property name.\n * @param {Function} getfn Getter function.\n * @param {Function|undefined} [setfn] Setter function.\n * @return {undefined}\n */\n\nexport function prop(obj, propname, getfn, setfn = void 0) {\n  const propObj = {};\n  propObj[propname] = {\n    get: getfn,\n    set: setfn\n  };\n  Object.defineProperties(obj, propObj);\n}\n/**\n * Defines a property on an object.\n *\n * @param {Object} o An object.\n * @param {string} p The property to define.\n * @param {Object} descriptor Optional object containing the descriptor's properties to use to override the default properties.\n * @return {Object} The object that was passed to the function.\n */\n\nexport function defineProperty(o, p, descriptor = {}) {\n  return Object.defineProperty(o, p, _objectSpread({\n    configurable: false,\n    enumerable: false,\n    writable: true\n  }, descriptor));\n}\n/**\n * Assigns the properties of the given source objects to the target object.\n *\n * @source https://stackoverflow.com/questions/39515321/spread-operator-issues-with-property-accessors-getters#answer-39521418\n *\n * @param {Object} target The target object.\n * @param {...Object} sources The source objects.\n * @return {Object} The target object.\n */\n\nexport function completeObjectAssign(target, ...sources) {\n  sources.forEach(source => {\n    const descriptors = Object.keys(source).reduce((descriptors, key) => {\n      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);\n      return descriptors;\n    }, {}); // By default, Object.assign copies enumerable Symbols too.\n\n    Object.getOwnPropertySymbols(source).forEach(sym => {\n      const descriptor = Object.getOwnPropertyDescriptor(source, sym);\n\n      if (descriptor.enumerable) {\n        descriptors[sym] = descriptor;\n      }\n    });\n    Object.defineProperties(target, descriptors);\n  });\n  return target;\n}\n//# sourceMappingURL=index.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Tests if the given value is a valid date.\n *\n * @param {*} value The value to test.\n * @return {boolean} True if it is a valid date, false otherwise.\n */\nexport function isValidDate(value) {\n  return Object.prototype.toString.call(value) === \"[object Date]\" && !isNaN(value.getTime());\n}\n/**\n * Tests if the given string is a valid datetime string (e.g. in ISO \"YYYY-MM-DD HH:ii:ss\" format).\n *\n * @param {string} str The given string.\n * @return {boolean} True if it is a valid datetime string, false otherwise.\n */\n\nexport function isValidDateTimeStr(str) {\n  return isValidDate(new Date(str));\n}\n//# sourceMappingURL=date.js.map","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Utility functions for functional programming.\n */\nimport { isObjectEmpty, isArray } from \"./core\";\nimport { arrayOrArrayLike } from \"./array\";\n/**\n * @type {string}\n */\n\nconst JSUtlCurryPlaceholderProp = \"JSUtlCurryPlaceholderPropRPecoyYmCYqZ2lE\";\n/**\n * Curry function placeholder.\n *\n * @type {Object}\n */\n\nexport const _ = {\n  [JSUtlCurryPlaceholderProp]: true\n};\n/**\n * @type {string}\n */\n\nconst JSUtlProceedCallingFnProp = \"JSUtlProceedCallingFnPropRBmGaAgOCgftF9t\";\n/**\n * Return value of \"onFnCall\" to call the curried function and return its value.\n *\n * @type {Object}\n */\n\nexport const proceedCallingFn = {\n  [JSUtlProceedCallingFnProp]: true\n};\n/**\n * Curries a function.\n *\n * @see https://medium.com/@kj_huang/implementation-of-lodash-curry-function-8b1024d71e3b\n *\n * @param {Function} fn A function to curry in order to return the curried version of the function.\n * @param {Object} [obj] An optional object with further properties to tweak the currying behaviour\n *                       and execute code while collecting the arguments of the curried function.\n * @param {number|undefined} [obj.arity] The arity of the function, i.e. its number of arguments.\n *                                       If omitted, \"fn.length\" will be used.\n * @param {Function|undefined} [obj.onEffectiveArgAdded] An optional callback to execute whenever a new effective argument\n *                                                       (not a placeholder) is added to the curried function.\n *                                                       The callback will receive an object with the following properties as argument:\n *\n *                                                           - addedArg: The effective argument added;\n *                                                           - args: An array with all the previously arguments collected so far\n *                                                                   without considering \"addedArg\";\n *                                                           - fn: The function \"fn\";\n *                                                           - curriedFn: The current curried function;\n *\n *                                                       The return value of the function is ignored.\n * @param {Function|undefined} [obj.onPlaceholder] An optional callback to execute whenever a new placeholder is added to the curried function.\n *                                                 The callback will receive an object with the following properties as argument:\n *\n *                                                     - args: An array with all the previously arguments collected so far\n *                                                             without considering \"addedArg\";\n *                                                     - fn: The function \"fn\";\n *                                                     - curriedFn: The current curried function;\n *\n *                                                 The return value of the function is ignored.\n * @param {Function|undefined} [obj.onFnCall] An optional callback to execute just before calling the \"fn\" function\n *                                            (i.e. when the \"fn\" function is ready to be called and all its arguments have been collected).\n *\n *                                            The callback will receive an object with the following properties as argument:\n *\n *                                                - args: The array of the effective arguments of the \"fn\" function;\n *                                                - fn: The function \"fn\" which was initially passed to \"curry\";\n *                                                - curriedFn: The current curried function;\n *\n *                                            This way, the code of the callback may decide what to do and may even call the function on its own\n *                                            and prevent the call from the caller side (i.e. within the \"curry\" function).\n *\n *                                            The callback must explicitly tell \"curry\" to call the function by returing \"proceedCallingFn\".\n *                                            If the callback returns any other value, then \"fn\" will not be called in \"curry\" and the return value\n *                                            of this callback will be returned.\n * @param {Function|undefined} [obj.onCurriedFnFirstCall] An optional callback to execute only the first time when the first curried function returned by \"curry\"\n *                                                        is invoked for the very first time with the very first argument or arguments.\n *\n *                                                        The callback will receive an object with the following properties as argument:\n *\n *                                                            - addedArgs: The arguments provided by the caller;\n *                                                            - fn: The \"fn\" function;\n *                                                            - curriedFn: The current curried function;\n *\n * @param {Function|undefined} [obj.onNewCurriedFn] An optional callback to execute initially and each time a new curried function is going to be returned.\n *\n *                                                  The callback will an object with the following properties as argument:\n *\n *                                                      - curriedFn: The current curried function (same as \"newCurriedFn\" when this callback is invoked\n *                                                                   for the very first time);\n *                                                      - newCurriedFn: The new curried function (will be the same as \"curriedFn\" when this callback is invoked\n *                                                                      for the very first time);\n *\n *\n * @return {Function} The curried version of the function.\n */\n\nexport const curry = (fn, {\n  arity = void 0,\n  onEffectiveArgAdded = void 0,\n  onPlaceholder = void 0,\n  onFnCall = void 0,\n  onCurriedFnFirstCall = void 0,\n  onNewCurriedFn = void 0\n} = {}) => {\n  let curriedFnFirstCall = true;\n  const expectedNumberOfArgs = typeof arity !== \"undefined\" ? arity : fn.length;\n  const nextParameterIndex = 0;\n  const placeholdersIndices = [];\n\n  const curriedInner = (expectedNumberOfArgs, nextParameterIndex, placeholdersIndices, ...args) => function curriedFn(...addedArgs) {\n    let newExpectedNumberOfArgs = expectedNumberOfArgs;\n    let newNextParameterIndex = nextParameterIndex;\n    let newPlaceholdersIndices = null;\n    let argsRequiredChange = false;\n    curriedFnFirstCall && (onCurriedFnFirstCall && onCurriedFnFirstCall({\n      addedArgs,\n      fn,\n      curriedFn\n    }) || true) && (curriedFnFirstCall = false);\n    let numberOfConsumablePlaceholders = placeholdersIndices.length;\n\n    for (const addedArg of addedArgs) {\n      !argsRequiredChange && (args = [...args]);\n      argsRequiredChange = true; // \"addedArg\" may be either a placeholder or an effective argument.\n\n      const isPlaceholder = addedArg ? addedArg[JSUtlCurryPlaceholderProp] === _[JSUtlCurryPlaceholderProp] : false;\n\n      if (numberOfConsumablePlaceholders > 0 && !isPlaceholder) {\n        // Argument is an effective argument consuming a previously set placeholder.\n        onEffectiveArgAdded && onEffectiveArgAdded({\n          addedArg,\n          args,\n          fn,\n          curriedFn\n        });\n        let argIndex;\n\n        if (newPlaceholdersIndices === null) {\n          const [firstIndex, ...rest] = placeholdersIndices;\n          argIndex = firstIndex;\n          newPlaceholdersIndices = rest;\n        } else {\n          argIndex = newPlaceholdersIndices.shift();\n        }\n\n        args[argIndex] = addedArg;\n        numberOfConsumablePlaceholders--;\n        newExpectedNumberOfArgs--;\n      } else {\n        if (isPlaceholder) {\n          // Argument is a new placeholder.\n          if (newPlaceholdersIndices === null) {\n            newPlaceholdersIndices = placeholdersIndices.concat(newNextParameterIndex);\n          } else {\n            newPlaceholdersIndices.push(newNextParameterIndex);\n          }\n\n          onPlaceholder && onPlaceholder({\n            args,\n            fn,\n            curriedFn\n          });\n        } else {\n          // Argument is an effective argument.\n          newExpectedNumberOfArgs--;\n          onEffectiveArgAdded && onEffectiveArgAdded({\n            addedArg,\n            args,\n            fn,\n            curriedFn\n          });\n        }\n\n        args[newNextParameterIndex] = addedArg;\n        newNextParameterIndex++;\n      }\n    } // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n    return curried.call(null, curriedFn, newExpectedNumberOfArgs, newNextParameterIndex, newPlaceholdersIndices === null ? [...placeholdersIndices] : newPlaceholdersIndices, ...args);\n  };\n\n  const curried = (curriedFn, expectedNumberOfArgs, nextParameterIndex, placeholdersIndices, ...args) => {\n    if (expectedNumberOfArgs <= 0) {\n      if (onFnCall) {\n        const shouldCallCurriedFn = onFnCall({\n          args,\n          fn,\n          curriedFn\n        });\n\n        if (shouldCallCurriedFn && shouldCallCurriedFn[JSUtlProceedCallingFnProp] === proceedCallingFn[JSUtlProceedCallingFnProp]) {\n          return fn(...args);\n        } else {\n          return shouldCallCurriedFn;\n        }\n      } else {\n        return fn(...args);\n      }\n    } else {\n      const newCurried = curriedInner(expectedNumberOfArgs, nextParameterIndex, placeholdersIndices, ...args);\n      onNewCurriedFn && onNewCurriedFn({\n        curriedFn,\n        newCurriedFn: newCurried\n      });\n      return newCurried;\n    }\n  };\n\n  const newCurried = curriedInner(expectedNumberOfArgs, nextParameterIndex, placeholdersIndices);\n  onNewCurriedFn && onNewCurriedFn({\n    curriedFn: newCurried,\n    newCurriedFn: newCurried\n  });\n  return newCurried;\n};\n/**\n * Curries a POJO function, i.e. a function having only a single POJO (Plain Old JavaScript Object)\n * as parameter (a function with named arguments).\n *\n * Each object passed to the returned curried function will be merged with the final object\n * to pass to the function \"fn\" when finally calling it.\n *\n * @param {Function} fn A function to curry in order to return the curried version of the function.\n * @param {Object} [obj] An optional object with further properties to tweak the currying behaviour\n *                       and execute code while collecting the POJO objects which will construct\n *                       the final POJO object to pass to the curried function after plugging the curried POJO function.\n * @param {string} [obj.plugPropertyName] The name of the property which instructs that it's time to call the function.\n * @param {boolean} [obj.plugPropertyMustBeTruthy] By default, it is enough that the property with \"obj.plugPropertyName\" name\n *                                                 is set on the object passed to the curried function to instruct it to call\n *                                                 \"fn\".\n *                                                 If this property is set to \"true\", the property with \"plugPropertyName\" name\n *                                                 will also have to be truthy.\n * @param {Function} [obj.onPOJOArgMerged] An optional callback to execute right after merging the next POJO argument with the so far accumulated POJO object.\n *                                         The callback will an object with the following properties as argument:\n *\n *                                             - POJOArg: The given POJO argument;\n *                                             - POJO: the so far merged POJO object merged with the given \"POJOArg\";\n *                                             - fn: The \"fn\" function;\n *                                             - curriedFn: The current curried function;\n *\n * @param {Function} [obj.onFnCall] An optional callback to execute just before calling the \"fn\" function\n *                                  (i.e. when the \"fn\" function is ready to be called and has been plugged and all\n *                                  of its POJO object argument properties have been collected).\n *\n *                                  The callback will receive an object with the following properties as argument:\n *\n *                                      - POJO: The callback will receive the function \"fn\" POJO argument (an object) as its first argument;\n *                                      - fn: The \"fn\" function;\n *                                      - curriedFn: The current curried function;\n *\n *                                  This way, the code of the callback may decide what to do and may even call the function on its own\n *                                  and prevent the call from the caller side (i.e. within the \"POJOCurry\" function).\n *\n *                                  The callback must explicitly tell \"POJOCurry\" to call the function by returing \"proceedCallingFn\"\n *                                  If the callback returns any other value, then \"fn\" will not be called in \"POJOCurry\" and the return value\n *                                  of this callback will be returned.\n * @param {Function|undefined} [obj.onCurriedFnFirstCall] An optional callback to execute only the first time when the first curried function returned by \"curry\"\n *                                                        is invoked for the very first time with the very first POJO argument.\n *\n *                                                        The callback will receive an object with the following properties as argument:\n *\n *                                                            - POJOArg: The given POJO argument yet to merge with the internal final POJO;\n *                                                            - fn: The \"fn\" function;\n *                                                            - curriedFn: The current curried function;\n *\n * @param {Function|undefined} [obj.onNewCurriedFn] An optional callback to execute initially and each time a new curried function is going to be returned.\n *\n *                                                  The callback will receive an object with the following properties as argument:\n *\n *                                                      - curriedFn: The current curried function (same as \"newCurriedFn\" when this callback is invoked\n *                                                                   for the very first time);\n *                                                      - newCurriedFn: The new curried function (will be the same as \"curriedFn\" when this callback is invoked\n *                                                                      for the very first time);\n *\n * @return {Function} The curried version of the function.\n */\n\nexport const POJOCurry = (fn, {\n  plugPropertyName = \"plugCurried\",\n  plugPropertyMustBeTruthy = false,\n  onPOJOArgMerged = void 0,\n  onFnCall = void 0,\n  onCurriedFnFirstCall = void 0,\n  onNewCurriedFn = void 0\n} = {}) => {\n  const POJO = {};\n  let curriedFnFirstCall = true;\n\n  const curriedInner = accPOJO => function curriedFn(POJOArg) {\n    curriedFnFirstCall && (onCurriedFnFirstCall && onCurriedFnFirstCall({\n      POJOArg,\n      fn,\n      curriedFn\n    }) || true) && (curriedFnFirstCall = false);\n    let POJO = Object.assign({}, accPOJO, POJOArg || {});\n\n    if (Object.prototype.hasOwnProperty.call(POJO, plugPropertyName) && (!plugPropertyMustBeTruthy || POJO[plugPropertyName])) {\n      const {\n        [plugPropertyName]: POJOArgIgnoredProperty\n      } = POJOArg,\n            rest = _objectWithoutProperties(POJOArg, [plugPropertyName].map(_toPropertyKey));\n\n      const {\n        [plugPropertyName]: POJOIgnoredProperty\n      } = POJO,\n            POJORest = _objectWithoutProperties(POJO, [plugPropertyName].map(_toPropertyKey));\n\n      POJO = POJORest;\n\n      if (!isObjectEmpty(rest)) {\n        onPOJOArgMerged && onPOJOArgMerged({\n          POJOArg: rest,\n          POJO,\n          fn,\n          curriedFn\n        });\n      }\n\n      let shouldCallCurriedFn = true;\n      let ret = void 0;\n\n      if (onFnCall) {\n        ret = onFnCall({\n          POJO,\n          fn,\n          curriedFn\n        });\n        shouldCallCurriedFn = ret ? ret[JSUtlProceedCallingFnProp] === proceedCallingFn[JSUtlProceedCallingFnProp] : false;\n      }\n\n      if (shouldCallCurriedFn) {\n        return fn(POJO);\n      } else {\n        return ret;\n      }\n    } else {\n      onPOJOArgMerged && onPOJOArgMerged({\n        POJOArg,\n        POJO,\n        fn,\n        curriedFn\n      });\n      const newCurried = curriedInner(POJO);\n      onNewCurriedFn && onNewCurriedFn({\n        curriedFn,\n        newCurriedFn: newCurried\n      });\n      return newCurried;\n    }\n  };\n\n  const newCurried = curriedInner(POJO);\n  onNewCurriedFn && onNewCurriedFn({\n    curriedFn: newCurried,\n    newCurriedFn: newCurried\n  });\n  return newCurried;\n};\n/**\n * A utility function which composes functions or higher-order functions.\n *\n * @param {...Function|...Function[]} fns A list of functions or higher-order functions or arrays of functions\n *                                        (arrays will be flattened) to compose.\n * @return {Function} A function composed of all the functions or higher-order functions\n *                    used for composition.\n */\n\nexport const compose = (...fns) => (...args) => {\n  let outerArgs = args;\n  let hoFn = void 0;\n  fns = fns.flat(1);\n\n  for (let i = fns.length - 1; i >= 0; i--) {\n    const fn = fns[i];\n    hoFn = fn(...outerArgs);\n    outerArgs = [hoFn];\n  }\n\n  return hoFn;\n};\n/**\n * A utility function which pipes functions.\n *\n * @param {...Function|...Function[]} fns A list of functions or arrays of functions (arrays will be flattened)\n *                                        to pipe.\n * @return {Function} A function representing the pipe.\n */\n\nexport const pipe = (...fns) => (...args) => {\n  fns = fns.flat(1);\n  return fns.length ? fns.reduce((arg, fn) => [fn(...arg)], args)[0] : void 0;\n};\n/**\n * Returns a function which lets picking the properties of an object.\n *\n * @param {...string|...number} props The properties to pick.\n * @return {Function} A function which if called picks the \"props\" properties from its argument object\n *                    and returns a new object with the picked properties.\n */\n\nexport const pick = (...props) => o => props.reduce((a, e) => _objectSpread(_objectSpread({}, a), {}, {\n  [e]: o[e]\n}), {});\n/**\n * Lifts two functions using a binary function which takes their results as arguments.\n *\n * @param {Function} binaryFn A binary function (i.e. a function which takes two arguments).\n * @return {Function} A higher-order function which has to be called with the first function as argument (\"firstFn\")\n *                    and returns another higher-order function which has to be called with the second function as argument (\"secondFn\").\n *                    Then, the returned function will take the parameters to pass to the two functions (\"firstFn\" and \"secondFn\")\n *                    and return the result of calling \"binaryFn\" with the result of those functions given as parameters.\n */\n\nexport const liftBinaryFn = binaryFn => firstFn => secondFn => (...params) => binaryFn(firstFn(...params), secondFn(...params));\n/**\n * Applies an array of functions to a list of values.\n *\n * @param {Function[]} fns An array of functions.\n * @return {Function} A function which if called with a list of values, will pass the list to each function of \"fns\"\n *                    and return an array with the values after applying each of the original \"fns\" to its parameters.\n */\n\nexport const juxt = fns => (...values) => fns.map(fn => fn(...values));\n/**\n * Converges a multi-arg function.\n *\n * @param {Function} multiArgFn A multi-arg function.\n * @param {Function[]} fns An array of functions to converge.\n *                         Each function will receive the parameter passed to the function returned\n *                         by this higher-order function (i.e. \"params\").\n * @return {Function} A function which, if called, will pass its arguments to each of the functions in \"fns\"\n *                    and pass each result of those functions to the multi-arg function \"multiArgFn\",\n *                    returning its result.\n */\n\nexport const converge = (multiArgFn, fns) => (...params) => multiArgFn(...fns.map(fn => fn(...params)));\n/**\n * Executes a callback if a POJO object has a property.\n *\n * @param {Object} POJO A POJO object.\n * @return {(prop: string|number) => (fn: Function) => *} A function which receives the property\n *                                                        and returns and returns a function receiving the callback\n *                                                        function (\"fn\") to execute.\n */\n\nexport const execIfPOJOHas = POJO => prop => fn => Object.prototype.hasOwnProperty.call(POJO, prop) && fn(POJO[prop], POJO);\n/**\n * Executes a callback with the existent properties of an object.\n *\n * @param {...string|...number} props The properties to check for existence.\n * @return {(o: Object) => (fn: (existentProps: string[]|number[]) => *) => *} A function which receives the POJO object for which to check for the given properties\n *                                                                             and returns a function receiving a callback which will receive the existent properties\n *                                                                             of the object as parameter.\n */\n\nexport const execWithExistentProps = (...props) => o => fn => fn(props.filter(prop => Object.prototype.hasOwnProperty.call(o, prop)));\n/**\n * Loops through the values of a generator and returns an array with its mapped\n * values mapped with the given callback.\n *\n * @param {GeneratorFunction} gen A generator function.\n * @return {(args: ...*) => (fn: (val: *) => *) => Array} A function which takes the arguments for the generator and returns\n *                                                        another function which takes the callback to use to map each\n *                                                        value of the generator returning an array with all the mapped values of the generator.\n */\n\nexport const forGen = gen => (...args) => fn => {\n  const generator = gen(...args);\n  const arr = [];\n\n  for (const value of generator) {\n    const res = fn(value);\n    arr.push(res);\n  }\n\n  return arr;\n};\n/**\n * Flattens an array (its first dimension, at most).\n *\n * @param {Array} arr An array.\n * @return {Array} A new flattened array.\n */\n\nexport const flatten = arr => Array.prototype.concat.apply([], arr);\n/**\n * Flattens an array with any dimension.\n *\n * @param {Array} arr An array.\n * @param {number} dimension The flattening dimension (defaults to 1, but can be greater, even \"Infinity\").\n * @return {Array} The flattened array.\n */\n\nexport const flattenDeep = (arr, dimension = 1) => {\n  return dimension > 0 ? arr.reduce((acc, val) => acc.concat(isArray(val) ? flattenDeep(val, dimension - 1) : val), []) : arrayOrArrayLike(arr);\n};\n/**\n * Computes the cartesian product of the given sets.\n *\n * @param  {...Array} sets The sets to use to compute the cartesian product.\n * @return {Array} The cartesian product of the given sets.\n */\n\nexport const cartesianProduct = (...sets) => sets.reduce((acc, set) => flatten(acc.map(x => set.map(y => [...x, y]))), [[]]);\n/**\n * Identity function.\n *\n * @see https://en.wikipedia.org/wiki/Identity_function\n *\n * @param {*} value Any value.\n * @return {*} The same passed value.\n */\n\nexport const identityFn = value => value;\n/**\n * Identity function for multiple args returning an array of those args.\n *\n * @param  {...*} args The args.\n * @return {Array} The same args returned in an array.\n */\n\nexport const identityArgsFn = (...args) => args;\n/**\n * @type {Function}\n */\n\nconst chainLink = (fn, next) => args => fn(args, next && ((...args) => next(args)));\n/**\n * A higher-order function to create a chain of functions following the Chain of Responsibility design pattern.\n *\n * @param {...Function|...Function[]} fns A list of functions or higher-order functions or arrays of functions\n *                                        (arrays will be flattened) to chain.\n * @return {Function} A function representing the chain of the given functions which, if called, will return the result of the chain.\n *                    Each function will receive the next function as its last parameter.\n */\n\n\nexport const chain = (...fns) => (...args) => {\n  fns = fns.flat(1);\n  const chainFn = fns.reduceRight((nextChainLink, fn) => {\n    return chainLink(fn, nextChainLink);\n  }, void 0);\n  return chainFn(args);\n};\n//# sourceMappingURL=fn.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Utility functions related to Google.\n */\n\n/**\n * Determines the best zoom level for a Google map.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds.\n * @param {Object} mapDim JS POJO with the properties height and width.\n * @param {number} mapDim.height The height of the map's div.\n * @param {number} mapDim.width The width of the map's div.\n * @return {number} The best zoom level.\n */\nexport function googleMapBestZoomLevelFromBounds(bounds, mapDim) {\n  const WORLD_DIM = {\n    height: 256,\n    width: 256\n  };\n  const ZOOM_MAX = 21;\n\n  function latRad(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const radX2 = Math.log((1 + sin) / (1 - sin)) / 2;\n    return Math.max(Math.min(radX2, Math.PI), -Math.PI) / 2;\n  }\n\n  function zoom(mapPx, worldPx, fraction) {\n    return Math.floor(Math.log(mapPx / worldPx / fraction) / Math.LN2);\n  }\n\n  const ne = bounds.getNorthEast();\n  const sw = bounds.getSouthWest();\n  const latFraction = (latRad(ne.lat()) - latRad(sw.lat())) / Math.PI;\n  const lngDiff = ne.lng() - sw.lng();\n  const lngFraction = (lngDiff < 0 ? lngDiff + 360 : lngDiff) / 360;\n  const latZoom = zoom(mapDim.height, WORLD_DIM.height, latFraction);\n  const lngZoom = zoom(mapDim.width, WORLD_DIM.width, lngFraction);\n  return Math.min(latZoom, lngZoom, ZOOM_MAX);\n}\n//# sourceMappingURL=google.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Hashing-related utility functions.\n */\n\n/**\n * Computes a hash of an array of strings (the order of strings does not matter).\n *\n * NOTE: An array with duplicate values given as parameter to this function\n *       may yield to a hash which would collide with other hashes computed\n *       on different arrays with this same function.\n *       Therefore is on behalf of the caller to be sure that \"array\" contains\n *       unique strings.\n *\n * @param {string[]} array An array of strings.\n * @return {number} A number representing the hash code of the array.\n */\nexport function stringHashArray(array) {\n  let code = 0;\n\n  for (let i = 0; i < array.length; i++) {\n    let n = 0;\n\n    for (let j = 0; j < array[i].length; j++) {\n      n = n * 251 ^ array[i].charCodeAt(j);\n    }\n\n    code ^= n;\n  }\n\n  return code;\n}\n/**\n * Returns the hash of a string.\n *\n * @see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript#answer-7616484\n *\n * @param {string} str The string.\n * @return {number} The hash code of the string, represented as a number.\n */\n\nexport const hashString = str => {\n  let hash = 0,\n      i,\n      chr;\n\n  if (str.length === 0) {\n    return hash;\n  }\n\n  for (i = 0; i < str.length; i++) {\n    chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0; // Convert to 32 bit integer.\n  }\n\n  return hash;\n};\n/**\n * A one-pass algorithm to compute the hash of a series of unique strings incrementally.\n *\n * NOTE: Duplicate values given as parameter to this function\n *       may yield to a hash which would collide with other hashes computed\n *       on different string series with this same function.\n *       Therefore is on behalf of the caller to be sure that the series of strings will be unique\n *       while calling this function incrementally.\n *\n * @param {string} str The string.\n * @param {number} [hash] The previous hash computed with this same function if this call is the continuation\n *                        of the unique string series.\n * @return {number} The next hash.\n */\n\nexport function onePassStringHash(str, hash = 0) {\n  let nextHash = hash;\n  let n = 0;\n\n  for (let j = 0; j < str.length; j++) {\n    n = n * 251 ^ str.charCodeAt(j);\n  }\n\n  nextHash ^= n;\n  return nextHash;\n}\n//# sourceMappingURL=hash.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Utility functions related to iterators, generators and iterations.\n */\n\n/**\n * Yields all the numbers of the specified range\n * (including \"start\" and \"limit\" if they fall in the range while stepping\n * with \"step\").\n *\n * @generator\n * @param {number} start An int specifying the start of the range.\n * @param {number} limit An int specifying the limit of the range.\n * @param {number} step An int specifying the step to take within each value of the range.\n * @yield {number} The next number of the range.\n */\nexport function* xrange(start, limit, step = 1) {\n  if (start < limit) {\n    if (step <= 0) {\n      throw new RangeError(\"Step must be a positive int greater than 0.\");\n    }\n\n    for (let i = start; i <= limit; i += step) {\n      yield i;\n    }\n  } else {\n    if (step >= 0) {\n      throw new RangeError(\"Step must be a negative int greater than 0.\");\n    }\n\n    for (let i = start; i >= limit; i += step) {\n      yield i;\n    }\n  }\n}\n//# sourceMappingURL=iterator.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Utility functions related to the coordinates of a map.\n */\n\n/**\n * Clamps a latitude value so that it is always between -90 and 90.\n *\n * Latitude ranges between -90 and 90 degrees, inclusive.\n * Values above or below this range will be clamped to the range [-90, 90].\n * This means that if the value specified is less than -90, it will be set to -90.\n * And if the value is greater than 90, it will be set to 90.\n *\n * @param {number|string} lat Latitude. Either a number or a string which can be casted to a number.\n * @return {number} Latitude, clamped.\n */\nexport const clampLat = lat => Number(lat < -90 ? -90 : lat > 90 ? 90 : lat);\n/**\n * Wraps a longitude value so that it is always between -180 and 180.\n *\n * Longitude ranges between -180 and 180 degrees, inclusive.\n * Values above or below this range will be wrapped so that they fall within the range.\n * For example, a value of -190 will be converted to 170.\n * A value of 190 will be converted to -170.\n * This reflects the fact that longitudes wrap around the globe.\n *\n * @param {number|string} lng Longitude. Either a number or a string which can be casted to a number.\n * @return {number} lng Longitude, wrapped.\n */\n\nexport const wrapLng = lng => {\n  lng = Number(lng);\n\n  while (lng > 180) {\n    lng -= 360;\n  }\n\n  while (lng < -180) {\n    lng += 360;\n  }\n\n  return lng;\n};\n/**\n * Normalizes a latitude so that it is within the range [0, 180].\n *\n * 1. normalizeLat(90) === 0;\n * 2. normalizeLat(0) === 90;\n * 3. normalizeLat(-90) === 180;\n *\n * @param {number|string} lat Latitude. Either a number or a string which can be casted to a number.\n * @return {number} Latitude, normalized.\n */\n\nexport const normalizeLat = lat => {\n  lat = clampLat(lat);\n\n  if (lat >= 0) {\n    // 1. + 2.\n    return 90 - lat;\n  } else {\n    // 3.\n    return 90 + Math.abs(lat);\n  }\n};\n/**\n * Normalizes a longitude so that it is within the range [0, 360].\n *\n * 1. normalizeLng(-180) === 0;\n * 2. normalizeLng(0) === 180;\n * 3. normalizeLng(180) === 360;\n *\n * @param {number} lng Longitude. Either a number or a string which can be casted to a number.\n * @return {number} Longitude, normalized.\n */\n\nexport const normalizeLng = lng => {\n  lng = wrapLng(lng);\n  return lng + 180;\n};\n//# sourceMappingURL=map-coordinates.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Mathematical utility functions.\n */\n\n/**\n * Rounds a number.\n *\n * @param {number} number The number to round.\n * @param {number} precision The decimal precision.\n * @return {number} The rounded number.\n */\nexport function round(number, precision = 0) {\n  const factor = Math.pow(10, precision);\n  return Math.round(number * factor) / factor;\n}\n/**\n * Sums two or more numbers.\n *\n * @param {...number} numbers The numbers to sum.\n * @return {number} The sum.\n */\n\nexport function sum(...numbers) {\n  return numbers.reduce((carry, num) => carry + num);\n}\n/**\n * Integer division (without decimal part).\n *\n * @param {number} num A number.\n * @param {number} divideBy The number by which to divide \"num\".\n * @return {number} The result of the integer division.\n */\n\nexport function intDiv(num, divideBy) {\n  return Math.floor(num / divideBy);\n}\n/**\n * Tests if a number is even.\n *\n * @param {number} num A number.\n * @return {boolean} True if even, false if odd.\n */\n\nexport function isEven(num) {\n  return num % 2 === 0;\n}\n/**\n * Tests if a number is odd.\n *\n * @param {number} num A number.\n * @return {boolean} True if odd, false if even.\n */\n\nexport function isOdd(num) {\n  return !isEven(num);\n}\n/**\n * Converts a source value of a source range to a value that is proportional\n * in another destination range.\n *\n * @param {number[]} sourceTuple The source range tuple, i.e. a tuple of two values, the starting value of the range at index 0 and the ending value of the range at index 1,\n *                               respectively.\n *                               This function assumes that both the starting and ending values are positive numbers (the starting value can be 0).\n * @return {(destRange: number[]) => (sourceValue: number) => number} A function receiving the destination range tuple as argument (having the same shape as the source range)\n *                                                                    returning a function taking the source value as argument returning the value proportional\n *                                                                    in the destination range.\n */\n\nexport const proportion = ([sourceFrom, sourceTo]) => ([destFrom, destTo]) => sourceValue => (sourceValue - sourceFrom) * ((destTo - destFrom) / (sourceTo - sourceFrom)) + destFrom;\n//# sourceMappingURL=math.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Object-related utility functions.\n */\n\n/**\n * @type {Function}\n */\nconst defaultObjectComparator = (a, b) => a < b ? -1 : a > b ? 1 : 0;\n/**\n * Finds the minimum value of an object.\n *\n * @param {Object} obj An object.\n * @param {Object} [options] An optional object with further options.\n * @param {(a: *, c: *) => number} [options.comparator] A comparator function receiving two values as arguments which must return a number less than 0 if the first\n *                                                      given value is the new minimum value.\n * @param {boolean} [options.returnAsKeyVal] True to return an object containing two properties `value` and `key`, namely the minimum value's key\n *                                           (`key` property) as well as the minimum value itself (`value` property).\n * @return {*} The minimum value or an object with the key and the minimum value if \"returnAsKeyVal\" is truthy.\n */\n\n\nexport const objectMin = (obj, {\n  comparator = defaultObjectComparator,\n  returnAsKeyVal = false\n} = {}) => {\n  const min = {\n    key: void 0,\n    value: void 0\n  };\n\n  for (const key in obj) {\n    const value = obj[key];\n\n    if (typeof min.key === \"undefined\" || comparator(value, min.value) < 0) {\n      min.key = key;\n      min.value = value;\n    }\n  }\n\n  return returnAsKeyVal ? min : min.value;\n};\n//# sourceMappingURL=object.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Utility functions for filenames and paths.\n */\n\n/**\n * Returns the basename of a path.\n *\n * @param {string} path A path.\n * @return {string} The basename of the given path.\n */\nexport function basename(path) {\n  return path.split(/[\\\\/]/).pop();\n}\n/**\n * Returns info about a path.\n *\n * @param {string} path The path.\n * @param {number} [options] Optioanl options flag.\n */\n\nexport function pathinfo(path, options) {\n  //  discuss at: http://locutus.io/php/pathinfo/\n  // original by: Nate\n  //  revised by: Kevin van Zonneveld (http://kvz.io)\n  // improved by: Brett Zamir (http://brett-zamir.me)\n  // improved by: Dmitry Gorelenkov\n  //    input by: Timo\n  //      note 1: Inspired by actual PHP source: php5-5.2.6/ext/standard/string.c line #1559\n  //      note 1: The way the bitwise arguments are handled allows for greater flexibility\n  //      note 1: & compatability. We might even standardize this\n  //      note 1: code and use a similar approach for\n  //      note 1: other bitwise PHP functions\n  //      note 1: Locutus tries very hard to stay away from a core.js\n  //      note 1: file with global dependencies, because we like\n  //      note 1: that you can just take a couple of functions and be on your way.\n  //      note 1: But by way we implemented this function,\n  //      note 1: if you want you can still declare the PATHINFO_*\n  //      note 1: yourself, and then you can use:\n  //      note 1: pathinfo('/www/index.html', PATHINFO_BASENAME | PATHINFO_EXTENSION);\n  //      note 1: which makes it fully compliant with PHP syntax.\n  //   example 1: pathinfo('/www/htdocs/index.html', 1)\n  //   returns 1: '/www/htdocs'\n  //   example 2: pathinfo('/www/htdocs/index.html', 'PATHINFO_BASENAME')\n  //   returns 2: 'index.html'\n  //   example 3: pathinfo('/www/htdocs/index.html', 'PATHINFO_EXTENSION')\n  //   returns 3: 'html'\n  //   example 4: pathinfo('/www/htdocs/index.html', 'PATHINFO_FILENAME')\n  //   returns 4: 'index'\n  //   example 5: pathinfo('/www/htdocs/index.html', 2 | 4)\n  //   returns 5: {basename: 'index.html', extension: 'html'}\n  //   example 6: pathinfo('/www/htdocs/index.html', 'PATHINFO_ALL')\n  //   returns 6: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}\n  //   example 7: pathinfo('/www/htdocs/index.html')\n  //   returns 7: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}\n  let opt = \"\";\n  let realOpt = \"\";\n  let optName = \"\";\n  let optTemp = 0;\n  const tmpArr = {};\n  let cnt = 0;\n  let i = 0;\n  let haveBasename = false;\n  let haveExtension = false;\n  let haveFilename = false; // Input defaulting & sanitation\n\n  if (!path) {\n    return false;\n  }\n\n  if (!options) {\n    options = \"PATHINFO_ALL\";\n  } // Initialize binary arguments. Both the string & integer (constant) input is\n  // allowed\n\n\n  const OPTS = {\n    PATHINFO_DIRNAME: 1,\n    PATHINFO_BASENAME: 2,\n    PATHINFO_EXTENSION: 4,\n    PATHINFO_FILENAME: 8,\n    PATHINFO_ALL: 0\n  }; // PATHINFO_ALL sums up all previously defined PATHINFOs (could just pre-calculate)\n\n  for (optName in OPTS) {\n    if (Object.prototype.hasOwnProperty.call(OPTS, optName)) {\n      OPTS.PATHINFO_ALL = OPTS.PATHINFO_ALL | OPTS[optName];\n    }\n  }\n\n  if (typeof options !== \"number\") {\n    // Allow for a single string or an array of string flags\n    options = [].concat(options);\n\n    for (i = 0; i < options.length; i++) {\n      // Resolve string input to bitwise e.g. 'PATHINFO_EXTENSION' becomes 4\n      if (OPTS[options[i]]) {\n        optTemp = optTemp | OPTS[options[i]];\n      }\n    }\n\n    options = optTemp;\n  } // Internal Functions\n\n\n  const _getExt = function (path) {\n    const str = path + \"\";\n    const dotP = str.lastIndexOf(\".\") + 1;\n    return !dotP ? false : dotP !== str.length ? str.substr(dotP) : \"\";\n  }; // Gather path infos\n\n\n  if (options & OPTS.PATHINFO_DIRNAME) {\n    const dirName = path.replace(/\\\\/g, \"/\").replace(/\\/[^/]*\\/?$/, \"\"); // dirname\n\n    tmpArr.dirname = dirName === path ? \".\" : dirName;\n  }\n\n  if (options & OPTS.PATHINFO_BASENAME) {\n    if (haveBasename === false) {\n      haveBasename = basename(path);\n    }\n\n    tmpArr.basename = haveBasename;\n  }\n\n  if (options & OPTS.PATHINFO_EXTENSION) {\n    if (haveBasename === false) {\n      haveBasename = basename(path);\n    }\n\n    if (haveExtension === false) {\n      haveExtension = _getExt(haveBasename);\n    }\n\n    if (haveExtension !== false) {\n      tmpArr.extension = haveExtension;\n    }\n  }\n\n  if (options & OPTS.PATHINFO_FILENAME) {\n    if (haveBasename === false) {\n      haveBasename = basename(path);\n    }\n\n    if (haveExtension === false) {\n      haveExtension = _getExt(haveBasename);\n    }\n\n    if (haveFilename === false) {\n      haveFilename = haveBasename.slice(0, haveBasename.length - (haveExtension ? haveExtension.length + 1 : haveExtension === false ? 0 : 1));\n    }\n\n    tmpArr.filename = haveFilename;\n  } // If array contains only 1 element: return string\n\n\n  cnt = 0;\n\n  for (opt in tmpArr) {\n    if (Object.prototype.hasOwnProperty.call(tmpArr, opt)) {\n      cnt++;\n      realOpt = opt;\n    }\n  }\n\n  if (cnt === 1) {\n    return tmpArr[realOpt];\n  } // Return full-blown array\n\n\n  return tmpArr;\n}\n/**\n * Returns the extension of a filename.\n *\n * @param {string} filename The filename.\n * @return {string} The extension of the given filename.\n */\n\nexport function filenameExtension(filename) {\n  const extension = pathinfo(filename, \"PATHINFO_EXTENSION\");\n\n  if (typeof extension !== \"string\") {\n    return \"\";\n  }\n\n  return extension;\n}\n/**\n * Returns the dirname of a path.\n *\n * @param {string} path A path.\n * @return {string} The dirname of the given path.\n */\n\nexport function dirname(path) {\n  //  discuss at: http://locutus.io/php/dirname/\n  // original by: Ozh\n  // improved by: XoraX (http://www.xorax.info)\n  //   example 1: dirname('/etc/passwd')\n  //   returns 1: '/etc'\n  //   example 2: dirname('c:/Temp/x')\n  //   returns 2: 'c:/Temp'\n  //   example 3: dirname('/dir/test/')\n  //   returns 3: '/dir'\n  return path.replace(/\\\\/g, \"/\").replace(/\\/[^/]*\\/?$/, \"\");\n}\n//# sourceMappingURL=path.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Promise-related utility functions.\n */\nimport { uniqueId, isArray } from \"./core\";\n/**\n * Creates a new timeout promise which will resolve after the given milliseconds timeout.\n *\n * @param {number} delayMs Delay in milliseconds after which the promise will resolve.\n * @param {*} [value] Optional value to resolve with.\n * @return {Promise} A new promise which resolves right after \"delayMs\" have elapsed.\n */\n\nexport function timeout(delayMs, value) {\n  return new Promise(resolve => setTimeout(resolve, delayMs, value));\n}\n/**\n * Creates a new promise with a minimum delay before it is fulfilled.\n *\n * @param {Promise} promise A promise.\n * @param {number} minDelay Minumum delay in milliseconds.\n * @return {Promise} A new promise which resolves with the given value of the given promise\n *                   or rejects with the rejected value of the promise if it rejects.\n */\n\nexport function minDelayPromise(promise, minDelay) {\n  return Promise.all([promise, timeout(minDelay)]).then(([value]) => {\n    return value;\n  }).catch(e => {\n    throw e;\n  });\n}\n/**\n * Resolves a promise with an optional fallback which fires if the promise does not resolve\n * under a certain time constraint.\n *\n * @param {Object} obj An object.\n * @param {Promise} obj.promise A promise.\n * @param {number} obj.maxDelayMs Max delay in milliseconds to wait before executing \"onFallback\" code if the time elapses.\n * @param {Function} obj.onFallback Function to execute if the given \"promise\" takes more than \"maxDelayMs\" to resolve.\n * @param {number} obj.fallbackMinDelayMs Number of milliseconds to wait if the fallback code gets executed before resolving the promise.\n * @return {Promise} A promise which resolves with the value of \"promise\" or rejects with the error of the given \"promise\".\n */\n\nexport function maxDelayFallbackPromise({\n  promise,\n  maxDelayMs,\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  onFallback = () => {},\n  fallbackMinDelayMs\n} = {}) {\n  const uniqueIdentifier = uniqueId();\n  return Promise.race([promise, timeout(maxDelayMs).then(() => uniqueIdentifier)]).then(value => {\n    if (value === uniqueIdentifier) {\n      onFallback();\n      return minDelayPromise(promise, fallbackMinDelayMs);\n    } else {\n      return value;\n    }\n  });\n}\n/**\n * Applies an async operation to a promise returning a new one.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Composition\n *\n * @param {Promise} acc A promise.\n * @param {Function} onfulfilled Fulfilled callback.\n * @param {Function} onrejected Rejected callback.\n * @return {Promise} A new promise.\n */\n\nexport const applyAsync = (acc, onfulfilled, onrejected) => {\n  return typeof onrejected !== \"undefined\" ? acc.then(onfulfilled, onrejected) : acc.then(onfulfilled);\n};\n/**\n * Composes functions which are run subsequently\n * (sequential composition) using promises.\n *\n * This function is useful when a chain of operations is known ahead of time\n * and they must be executed subsequently.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Composition\n *\n * @param {...(Function|Array)} funcs The functions (fulfilled callbacks). An array can be given and it MUST have\n *                                    the fulfilled callback at index 0 and the reject callback at index 1.\n * @return {Function} A new function that accepts an initial value to be passed through the composition pipeline.\n *                    If the returned function is called, it will return a Promise which represents the chain formed\n *                    by the promises composed subsequently.\n */\n\nexport const composeAsync = (...funcs) => x => {\n  return funcs.reduce((acc, func) => {\n    let promise;\n\n    if (isArray(func)) {\n      // Item at index 0 is the fulfilled callback,\n      // while the item at index 1 is the reject callback.\n      promise = applyAsync(acc, func[0], func[1]);\n    } else {\n      promise = applyAsync(acc, func);\n    }\n\n    return promise;\n  }, Promise.resolve(x));\n};\n//# sourceMappingURL=promise.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Utility functions providing random functionality.\n */\n\n/**\n * Generates a random string.\n *\n * @param {number} length The length of the string to return.\n * @return {string} The random string.\n */\nexport function randomStr(length) {\n  let result = \"\";\n  const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charactersLength = characters.length;\n\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  return result;\n}\n/**\n * Generates a random int between min and max (both included).\n *\n * @param {number} min Min int value.\n * @param {number} max Max int value.\n * @return {number} A random int between min and max.\n */\n\nexport function randomInt(min = 0, max = Number.MAX_SAFE_INTEGER) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n/**\n * Generates a random float between min and max integers (both included).\n *\n * @param {number} min Min int value.\n * @param {number} max Max int value.\n * @return {number} A random float between min and max.\n */\n\nexport function randomFloat(min = 0, max = 562949953421311) {\n  const randInt = randomInt(min, max);\n\n  if (randInt >= max) {\n    return randInt;\n  }\n\n  return randInt + Math.random();\n}\n/**\n * Returns a random float (using \"Math.random()\") not equal to the given value.\n *\n * @param {number} value The given value.\n * @return {number} A random float not equal to value.\n */\n\nexport function randomDifferentFromValue(value) {\n  let ret = Math.random();\n\n  while (value == ret) {\n    ret = Math.random();\n  }\n\n  return ret;\n}\n/**\n * @type {Array}\n */\n\nlet noncanonicalUUIDCounter = 1;\n/**\n * Generates a new UUID.\n *\n * @see https://github.com/tastejs/todomvc/blob/gh-pages/examples/react/js/utils.js\n *\n * @return {string} The UUID.\n */\n\nexport function uuid() {\n  let i, random;\n  let uuid = \"\";\n\n  for (i = 0; i < 32; i++) {\n    random = Math.random() * 16 | 0;\n\n    if (i === 8 || i === 12 || i === 16 || i === 20) {\n      uuid += \"-\";\n    }\n\n    uuid += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\n  }\n\n  return uuid;\n}\n/**\n * Generates a new noncanonical UUID. This noncanonical UUID has a further\n * int prefixed by \"-\" which is concatenated to a canonical UUID at the end\n * of the canonical UUID before returning this noncanonical UUID.\n * The int starts with 1 and increments every time this function is called.\n *\n * @return {string} A noncanonical UUID.\n */\n\nexport function noncanonicalUUID() {\n  const UUID = uuid();\n  return UUID + \"-\" + noncanonicalUUIDCounter++;\n}\n/**\n * Shuffles an array randomly modifing the given array.\n *\n * @param {Array} array The input array.\n * @return {Array} A reference to the same array given as input,\n *                 but with its elements randomly shuffled.\n */\n\nconst shuffleArrayRandomly = array => {\n  let i = array.length,\n      temporaryValue,\n      randomIndex;\n\n  while (0 !== i) {\n    randomIndex = Math.floor(Math.random() * i);\n    i--;\n    temporaryValue = array[i];\n    array[i] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n};\n/**\n * Returns an array with the elements of the given array randomly shuffled.\n *\n * @param {Array} array An array.\n * @return {Array} A new array with the same elements of the input array, but randomly shuffled.\n */\n\n\nexport function randomArrayShuffle(array) {\n  return shuffleArrayRandomly(Object.keys(array)).map(i => array[i]);\n}\n//# sourceMappingURL=rand.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Statistics-related utility functions.\n */\nimport { sum, intDiv, isOdd } from \"./math\";\nimport { sortNums } from \"./array\";\n/**\n * Computes the mean of the given numbers.\n *\n * @param {...number} numbers The numbers.\n * @return {number} The mean.\n */\n\nexport function mean(...numbers) {\n  return sum(...numbers) / numbers.length;\n}\n/**\n * Computes the median of the given numbers.\n *\n * @param {...number} numbers The numbers.\n * @return {number} The median value.\n */\n\nexport function median(...numbers) {\n  const sorted = sortNums(numbers);\n  const middleIndex = intDiv(sorted.length, 2);\n  return isOdd(sorted.length) ? sorted[middleIndex] : mean(sorted[middleIndex - 1], sorted[middleIndex]);\n}\n/**\n * Computes the min deviation from a value.\n *\n * @param {number} value A value.\n * @return {(...numbers: number[]) => number} A function receiving the numbers to use to compute the minimum deviation\n *                                            from \"value\".\n */\n\nexport const minAbsDeviationFromValue = value => (...numbers) => {\n  let minAbsDeviation = Infinity;\n  numbers.map(num => {\n    const deviation = Math.abs(num - value);\n\n    if (deviation < minAbsDeviation) {\n      minAbsDeviation = deviation;\n    }\n  });\n  return minAbsDeviation;\n};\n/**\n * Computes the min deviation from a value excluding that value from the numbers received.\n *\n * @param {number} value A value.\n * @return {(...numbers: number[]) => number} A function receiving the numbers to use to compute the minimum deviation\n *                                            from \"value\" exluding \"value\".\n */\n\nexport const minAbsDeviationFromExcludedValue = value => (...numbers) => minAbsDeviationFromValue(value)(...numbers.filter(num => num !== value));\n//# sourceMappingURL=stats.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Utility functions for working with strings.\n */\nimport { isArray } from \"./core\";\n/**\n * Escapes special characters for a JS regex.\n *\n * @see https://stackoverflow.com/questions/3115150/how-to-escape-regular-expression-special-characters-using-javascript#answer-9310752\n *\n * @param {string} text The string to escape.\n * @return {string} The same string with special regex characters escaped.\n */\n\nexport function escapeRegExp(text) {\n  return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n}\n/**\n * Trim characters from the beginning and end of a string.\n *\n * @param {string} str The string.\n * @param {string} characterMask Character mask.\n * @param {Object} options Options.\n * @param {Object.boolean} options.shouldTrimLeft \"true\" to trim left (defaults to \"true\" if omitted).\n * @param {Object.boolean} options.shouldTrimRight \"true\" to trim right (defaults to \"true\" if omitted).\n * @return {string} The trimmed string.\n */\n\nexport function trimCharacterMask(str, characterMask, options = {}) {\n  if (typeof characterMask === \"undefined\") {\n    characterMask = \" \";\n  }\n\n  const escapedCharacterMask = escapeRegExp(characterMask);\n  const shouldTrimLeft = typeof options.shouldTrimLeft === \"undefined\" || options.shouldTrimLeft;\n  const shouldTrimRight = typeof options.shouldTrimRight === \"undefined\" || options.shouldTrimRight;\n  const regexParts = [];\n\n  if (shouldTrimLeft) {\n    regexParts[regexParts.length] = \"^[\" + escapedCharacterMask + \"]+\";\n  }\n\n  if (shouldTrimRight) {\n    regexParts[regexParts.length] = \"[\" + escapedCharacterMask + \"]+$\";\n  }\n\n  const regex = new RegExp(regexParts.join(\"|\"), \"gm\");\n  return str.replace(regex, \"\");\n}\n/**\n * Trim characters from the beginning and end of a string using an array\n * of regex characters.\n *\n * @param {string} str The string.\n * @param {string} regexCharacters Regex characters.\n * @param {string} additionalModifiers Additional regex modifiers.\n * @return {string} The trimmed string.\n */\n\nexport function trimCharacterRegex(str, regexCharacters, additionalModifiers) {\n  if (typeof regexCharacters === \"undefined\") {\n    regexCharacters = [\"\\\\s\"];\n  }\n\n  additionalModifiers = additionalModifiers || \"\";\n  const regex = new RegExp(\"(^(\" + regexCharacters.join(\"|\") + \")+)|((\" + regexCharacters.join(\"|\") + \")+$)\", \"g\" + additionalModifiers);\n  return str.replace(regex, \"\");\n}\n/**\n * Alias of \"trimCharacterMask\".\n * Trim characters from the beginning and end of a string.\n *\n * @param {string} str The string.\n * @param {string} characterMask Character mask.\n * @return {string} The trimmed string.\n */\n\nexport function trim(str, characterMask) {\n  return trimCharacterMask(str, characterMask);\n}\n/**\n * Trim characters from the beginning of a string.\n *\n * @param {string} str The string.\n * @param {string} characterMask Character mask.\n * @return {string} The left-trimmed string.\n */\n\nexport function trimLeft(str, characterMask) {\n  return trimCharacterMask(str, characterMask, {\n    shouldTrimLeft: true,\n    shouldTrimRight: false\n  });\n}\n/**\n * Trim characters from the end of a string.\n *\n * @param {string} str The string.\n * @param {string} characterMask Character mask.\n * @return {string} The right-trimmed string.\n */\n\nexport function trimRight(str, characterMask) {\n  return trimCharacterMask(str, characterMask, {\n    shouldTrimLeft: false,\n    shouldTrimRight: true\n  });\n}\n/**\n * Concats the values of an array with an outer separator using an inner separator\n * for first nesting level arrays.\n *\n * E.g.:\n *\n *     concatWithInnerOuterSeparators([\"a\", \"value\", [\"with\", \"nested\", \"value\"], \"etc\"], \" # \", \" $ \")\n *     // Returns:\n *     \"a # value # with $ nested $ value # etc\"\n *\n * @param {Array<string>|Array<Array<string>>} arrayToConcat An array of strings or arrays or strings.\n * @param {string} outerSeparator Outer separator.\n * @param {string} innerSeparator Inner separator.\n * @return {string} The concatenated string.\n */\n\nexport function concatWithInnerOuterSeparators(arrayToConcat, outerSeparator = \" \", innerSeparator = \" \") {\n  const toConcatFinally = [];\n\n  for (const value of arrayToConcat) {\n    if (isArray(value)) {\n      toConcatFinally[toConcatFinally.length] = trim(value.join(innerSeparator), innerSeparator);\n    } else {\n      toConcatFinally[toConcatFinally.length] = value;\n    }\n  }\n\n  const ret = trim(toConcatFinally.join(outerSeparator), outerSeparator);\n  return ret;\n}\n/**\n * Returns an array of options with a value and a label string.\n *\n * @param {Object} obj An object with parameters.\n * @param {Object[]} obj.arrayOfObjects An array of objects.\n * @param {string[]|Array.<string|string[]>} obj.concatObjectProps Properties, keys of each object to use for the label\n *                                                                 and to concat with \"outerSeparator\".\n *                                                                 A nested array of properties can be used to specify an inner\n *                                                                 part of the label to concat using the \"innerSeparator\".\n * @param {string} obj.valueProp Name of the property which value has to be used for the value property\n *                               of the returned array of objects.\n * @param {string} obj.outerSeparator Outer separator.\n * @param {string} obj.innerSeparator Inner separator.\n * @return {Object[]} Array of objects, each object with two properties:\n *\n *                        - \"value\": The value of the object;\n *                        - \"label\": The label of the object.\n *\n */\n\nexport function optionsValueLabel({\n  arrayOfObjects,\n  concatObjectProps,\n  valueProp = \"id\",\n  outerSeparator = \" \",\n  innerSeparator = \" \"\n}) {\n  const options = [];\n\n  for (const obj of arrayOfObjects) {\n    const arrayToConcat = [];\n\n    for (const prop of concatObjectProps) {\n      if (isArray(prop)) {\n        arrayToConcat[arrayToConcat.length] = prop.map(propName => obj[propName]);\n      } else {\n        arrayToConcat[arrayToConcat.length] = obj[prop];\n      }\n    }\n\n    options[options.length] = {\n      value: obj[valueProp],\n      label: concatWithInnerOuterSeparators(arrayToConcat, outerSeparator, innerSeparator)\n    };\n  }\n\n  return options;\n}\n/**\n * Tests if a string starts with another\n *\n * @param {string} haystack The haystack string.\n * @param {string} needle The needle string.\n * @return {boolean} True if the haystack string starts with needle, false otherwise.\n */\n\nexport function startsWith(haystack, needle) {\n  return haystack.indexOf(needle, 0) === 0;\n}\n/**\n * Makes the first character of the given string uppercase.\n *\n * @param {string} string A string.\n * @return {string} The string with its first character made uppercase.\n */\n\nexport function ucaseFirst(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n/**\n * Reverses a string.\n *\n * @param {string} string A string to reverse.\n * @return {string} The reversed string.\n */\n\nexport function reverseString(string) {\n  return string.split(\"\").reverse().join(\"\");\n}\n/**\n * Given an integer, returns a string containing the same integer with additional thousands separators.\n *\n * @param {number} num An integer.\n * @param {string} [sep] The thousands separator to use.\n * @return {string} The same integer with thousands separators.\n */\n\nexport function separateIntThousands(num, sep = \",\") {\n  return num.toString().split(\"\").reverse().map((d, i, a) => (i + 1) % 3 === 0 && i !== a.length - 1 ? `${sep}${d}` : d).reverse().join(\"\");\n}\n//# sourceMappingURL=string.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Time-related utility functions.\n */\n\n/**\n * Returns the current Unix time in seconds.\n *\n * @return {number} Current Unix time in seconds.\n */\nexport function time() {\n  const d = new Date();\n  const seconds = Math.round(d.getTime() / 1000);\n  return seconds;\n}\n/**\n * Returns the time string approximated to the nearest microsecond\n * corresponding the given Unix timestamp in milliseconds\n * in the format \"HH:mm:ss.ms\".\n *\n * @param {number} [ms] The time in microseconds to convert into a string.\n *                      If omitted, the current time will be used.\n * @return {string} The time string.\n */\n\nexport function msToTime(ms) {\n  const date = new Date(ms || new Date().getTime());\n  const isoDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString();\n  return isoDate.slice(11, -1);\n}\n/**\n * Converts milliseconds to seconds.\n *\n * @param {number} millisec Number of milliseconds.\n * @return {number} The milliseconds in seconds.\n */\n\nexport function millisecToSec(millisec) {\n  return millisec * 0.001;\n}\n//# sourceMappingURL=time.js.map","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Web application (browser) utility functions.\n */\nimport { config, uniqueId, isEmpty, isJSONString, isPlainObject } from \"./core\";\n/**\n * Builds a form data instance or object recursively.\n *\n * @see https://stackoverflow.com/questions/22783108/convert-js-object-to-form-data#answer-42483509\n *\n * @param {FormData|Object} formData Form data instance or JS POJO object.\n * @param {Array|Object} data JS POJO object or array with the form data to use to build the forma data.\n * @param {boolean} [shouldEncodeURIComponent] Optionally instructs the function if the parameters should be encoded\n *                                             (keys and values) using \"encodeURIComponent\".\n * @param {string} [parentKey] Parent key for nested parameters (used internally for recursion).\n * @return {undefined}\n */\n\nfunction buildFormData(formData, data, shouldEncodeURIComponent, parentKey) {\n  if (data && typeof data === \"object\" && !(data instanceof Date) && !(data instanceof File)) {\n    Object.keys(data).forEach(key => {\n      buildFormData(formData, data[key], shouldEncodeURIComponent, parentKey ? `${parentKey}[${key}]` : shouldEncodeURIComponent ? encodeURIComponent(key) : key);\n    });\n  } else {\n    // Leaf value.\n    const value = data == null ? \"\" : shouldEncodeURIComponent ? encodeURIComponent(data) : data;\n    formData instanceof FormData ? formData.append(parentKey, value) : formData[parentKey] = value;\n  }\n}\n/**\n * Constructs a query string from the given data.\n * This method works with nested objects/arrays.\n *\n * @param {Array|Object} data The object.\n * @return {string} The query string.\n */\n\n\nexport function buildQueryString(data) {\n  const formData = {};\n  buildFormData(formData, data, true); // \"true\" instructs the function to encode URI parts (keys and values).\n\n  const parts = [];\n\n  for (const prop in formData) {\n    parts.push(prop + \"=\" + formData[prop]);\n  }\n\n  return parts.join(\"&\");\n}\n/**\n * Converts an object (array or JS POJO object) to a form data instance.\n *\n * @param {Array|Object} data The data (array or POJO object).\n * @return {FormData} A form data instance.\n */\n\nexport function formData(data) {\n  const formData = new FormData();\n  buildFormData(formData, data);\n  return formData;\n}\n/**\n * Returns a new XMLHttpRequest or ActiveXObject object.\n *\n * @return {XMLHttpRequest|ActiveXObject}\n */\n\nexport const xhr = () => window.ActiveXObject && new window.ActiveXObject(\"Microsoft.XMLHTTP\") || new XMLHttpRequest();\n/**\n * Checks whether the network is reachable or not.\n *\n * @param {string} URI An eventual URI to use for the request.\n *                     NOTE: If omitted, then \"config.checkNetworkURI\" will be used,\n *                           or, if \"config.checkNetworkURI\" is not set,\n *                           the website's hostname will be used.\n *                           Also, in every case, A GET query string with a random parameter\n *                           is always appended to the URI.\n * @return {Promise} A promise which resolves to \"true\" if the network is reachable and to \"false\" otherwise.\n *                   Note that the returned promise always resolves to \"true\" when this code runs on localhost.\n */\n\nexport function checkNetwork(URI = null) {\n  // Handle IE and more capable browsers.\n  const xhrObj = xhr();\n  return new Promise(resolve => {\n    // Issue request and handle response.\n    try {\n      xhrObj.onreadystatechange = () => {\n        if (xhrObj.readyState == 4) {\n          resolve(xhrObj.status >= 200 && (xhrObj.status < 300 || xhrObj.status === 304));\n        }\n      }; // Open new request as a HEAD to the root hostname with a random param to bust the cache.\n\n\n      xhrObj.open(\"HEAD\", (URI || config.checkNetworkURI || \"//\" + window.location.hostname + (window.location.port != 80 ? \":\" + window.location.port : \"\")) + \"?rand=\" + Math.floor((1 + Math.random()) * 0x10000), // 0x10000 = 2^16\n      true);\n      xhrObj.send();\n    } catch (error) {\n      resolve(false);\n    }\n  });\n}\n/**\n * Returns a promise which resolves when the network is available.\n *\n * NOTE: If the network is available, the promise will resolve almost immediately.\n *\n * @param {number} intervalMillisecs An interval in milliseconds to wait before the next network check.\n * @return {Promise} A promise.\n */\n\nexport function waitNetwork(intervalMillisecs = 3000) {\n  return new Promise(resolve => {\n    checkNetwork().then(isNetworkReachable => {\n      if (isNetworkReachable) {\n        resolve();\n      } else {\n        const interval = setInterval(() => {\n          checkNetwork().then(isNetworkReachable => {\n            if (isNetworkReachable) {\n              clearInterval(interval);\n              resolve();\n            }\n          });\n        }, intervalMillisecs);\n      }\n    });\n  });\n}\n/**\n * Sets a cookie value.\n *\n * @see https://www.w3schools.com/js/js_cookies.asp\n *\n * @param {string} cname The cookie name.\n * @param {string} cvalue The cookie value.\n * @param {number|undefined} exdays Number of days after which the cookie expires,\n *                                  or \"undefined\" to make the cookie expire at the end of the session.\n * @return {undefined}\n */\n\nexport function setCookie(cname, cvalue, exdays) {\n  let expires = \"\";\n\n  if (exdays) {\n    const d = new Date();\n    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);\n    expires = \"expires=\" + d.toUTCString() + \";\";\n  }\n\n  document.cookie = cname + \"=\" + cvalue + \";\" + expires + \"path=/\";\n}\n/**\n * Gets a cookie value.\n *\n * @see https://www.w3schools.com/js/js_cookies.asp\n *\n * @param {string} cname The cookie name.\n * @return {string|undefined} The cookie value or \"undefined\", if not set.\n */\n\nexport function getCookie(cname) {\n  const name = cname + \"=\";\n  const ca = document.cookie.split(\";\");\n\n  for (let i = 0; i < ca.length; i++) {\n    let c = ca[i];\n\n    while (c.charAt(0) == \" \") {\n      c = c.substring(1);\n    }\n\n    if (c.indexOf(name) == 0) {\n      return c.substring(name.length, c.length);\n    }\n  }\n\n  return void 0;\n}\n/**\n * Unsets a cookie.\n *\n * @param {string} cname The cookie name.\n * @return {undefined}\n */\n\nexport function unsetCookie(cname) {\n  setCookie(cname, \"\", -365);\n}\n/**\n * Tests whether a DOM element is in viewport or not.\n *\n * @param {Element} elem The DOM element.\n * @return {boolean} True if it is in viewport, false otherwise.\n */\n\nexport function isInViewport(elem) {\n  const bounding = elem.getBoundingClientRect();\n  return bounding.top >= 0 && bounding.left >= 0 && bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight) && bounding.right <= (window.innerWidth || document.documentElement.clientWidth);\n}\n/**\n * Tests if a DOM element is scrolled into the scrollable view of its parent scrollable container.\n *\n * @param {Element} elem The DOM element to test.\n * @param {Element} holder The DOM element of the scrollable container of the DOM element to test.\n * @param {number|Function} minPx Minimum number of pixels of the element's height which must be scrolled into the view\n *                                in order to consider the element to be scrolled into view.\n *                                If a function is given, it will receive the element's bounding client rect as the first argument\n *                                as well as the holder element's bounding client rect as the second argument and must return\n *                                the minimum number of pixels.\n * @return {boolean} True if the given element is scrolled into view, false otherwise.\n */\n\nexport function isScrolledIntoView(el, holder, minPx = 1) {\n  const elRect = el.getBoundingClientRect();\n  const holderRect = holder.getBoundingClientRect();\n  const {\n    top,\n    bottom,\n    height\n  } = elRect;\n\n  const minPxNumberFn = () => typeof minPx === \"function\" ? minPx(elRect, holderRect) : minPx;\n\n  let bottomDiff;\n  return top <= holderRect.top ? holderRect.top - top + minPxNumberFn() <= height : (bottomDiff = bottom - holderRect.bottom) < 0 ? true : holderRect.bottom >= top && minPx ? holderRect.bottom - top >= minPxNumberFn() : bottomDiff <= height;\n}\n/**\n * Tests if a DOM element has a vertical scrollbar.\n *\n * @param {Element} elem The DOM element.\n * @return {boolean} True it has a vertical scrollbar, false otherwise.\n */\n\nexport function hasVerticalScrollbar(elem) {\n  const hasVerticalScrollbar = elem.scrollHeight > elem.clientHeight;\n  return hasVerticalScrollbar;\n}\n/**\n * Tests if a DOM element has a horizontal scrollbar.\n *\n * @param {Element} elem The DOM element.\n * @return {boolean} True it has a horizontal scrollbar, false otherwise.\n */\n\nexport function hasHorizontalScrollbar(elem) {\n  const hasHorizontalScrollbar = elem.scrollWidth > elem.clientWidth;\n  return hasHorizontalScrollbar;\n}\n/**\n * Generates a unique ID which can be used for an element.\n *\n * @param {string|undefined} [elementUniqueIdPrefix] Local unique ID prefix which overrides the prefix\n *                                                   set on the \"config\" configuration object.\n * @return {string} The element unique ID.\n */\n\nexport function elementUniqueId(elementUniqueIdPrefix = void 0) {\n  const uniqueElementIdSuffix = uniqueId();\n  return (elementUniqueIdPrefix || config.elementUniqueIdPrefix) + uniqueElementIdSuffix;\n}\n/**\n * Gets the computed style of an element.\n *\n * @param {Element} element DOM element.\n * @return {CSSStyleDeclaration} The computed style.\n */\n\nexport function getElementComputedStyle(element) {\n  return window.getComputedStyle(element);\n}\n/**\n * Gets element's inner dimensions (height and width without padding).\n *\n * @param {Element} element An element.\n * @return {Object} An object with \"width\" and \"height\" properties.\n */\n\nexport function elementInnerDimensions(element) {\n  const computedStyle = getElementComputedStyle(element);\n  let elementHeight = element.clientHeight; // Height with padding.\n\n  let elementWidth = element.clientWidth; // Width with padding\n\n  elementHeight -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  elementWidth -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return {\n    width: elementWidth,\n    height: elementHeight\n  };\n}\n/**\n * @type {HTMLTextAreaElement}\n */\n\nlet countTextareaLinesBuffer;\n/**\n * Returns the number of lines in a textarea, including wrapped lines.\n *\n * @see https://stackoverflow.com/questions/28905965/textarea-how-to-count-wrapped-lines-rows#answer-45252226\n *\n * @param {HTMLTextAreaElement} textarea A textarea element. Note that the textarea should have an integer line height\n *                                       to avoid rounding errors.\n */\n\nexport function countTextareaLines(textarea) {\n  if (countTextareaLinesBuffer == null) {\n    countTextareaLinesBuffer = document.createElement(\"textarea\");\n    countTextareaLinesBuffer.style.border = \"none\";\n    countTextareaLinesBuffer.style.height = \"0\";\n    countTextareaLinesBuffer.style.overflow = \"hidden\";\n    countTextareaLinesBuffer.style.padding = \"0\";\n    countTextareaLinesBuffer.style.position = \"absolute\";\n    countTextareaLinesBuffer.style.left = \"0\";\n    countTextareaLinesBuffer.style.top = \"0\";\n    countTextareaLinesBuffer.style.zIndex = \"-1\";\n    document.body.appendChild(countTextareaLinesBuffer);\n  }\n\n  const cs = window.getComputedStyle(textarea);\n  const pl = parseInt(cs.paddingLeft);\n  const pr = parseInt(cs.paddingRight);\n  let lh = parseInt(cs.lineHeight); // `cs.lineHeight` may return 'normal', which means line height = font size.\n\n  if (isNaN(lh)) lh = parseInt(cs.fontSize); // Copy content width.\n\n  countTextareaLinesBuffer.style.width = textarea.clientWidth - pl - pr + \"px\"; // Copy text properties.\n\n  countTextareaLinesBuffer.style.font = cs.font;\n  countTextareaLinesBuffer.style.letterSpacing = cs.letterSpacing;\n  countTextareaLinesBuffer.style.whiteSpace = cs.whiteSpace;\n  countTextareaLinesBuffer.style.wordBreak = cs.wordBreak;\n  countTextareaLinesBuffer.style.wordSpacing = cs.wordSpacing;\n  countTextareaLinesBuffer.style.wordWrap = cs.wordWrap; // Copy value.\n\n  countTextareaLinesBuffer.value = textarea.value;\n  let result = Math.floor(countTextareaLinesBuffer.scrollHeight / lh);\n\n  if (result == 0) {\n    result = 1;\n  }\n\n  return result;\n}\n/**\n * Checks if the scroll of an element is on the bottom.\n *\n * @param {Element} DOMNode Element.\n * @return {boolean} True if the scroll is on the bottom, false otherwise.\n */\n\nexport function isScrollOnBottom(DOMNode) {\n  const ret = DOMNode.scrollTop + DOMNode.offsetHeight >= DOMNode.scrollHeight;\n  return ret;\n}\n/**\n * Returns the default browser's vertical scrollbar width.\n *\n * @return {Number} The scrollbar width.\n */\n\nexport function getVerticalScrollBarWidth() {\n  const scrollDiv = document.createElement(\"div\");\n  scrollDiv.className = \"vertical-scrollbar-measure\";\n  const sheet = document.createElement(\"style\");\n  sheet.innerHTML = \"div.vertical-scrollbar-measure { width: 100px; height: 100px; overflow: scroll; position: absolute; top: -9999px; }\";\n  document.body.appendChild(sheet);\n  document.body.appendChild(scrollDiv);\n  const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n  document.body.removeChild(scrollDiv);\n  const sheetParent = sheet.parentNode;\n  sheetParent.removeChild(sheet);\n  return scrollbarWidth;\n}\n/**\n * Tests if an element with \"text-overflow: ellipsis;\" has the ellipsis active\n * and therefore its text is truncated.\n *\n * @param {Element} e The DOM element.\n * @return {boolean} True if ellipsis are present, false otherwise.\n */\n\nexport function isEllipsisActive(e) {\n  return e.offsetWidth < e.scrollWidth;\n}\n/**\n * A fallback function to copy a text to clipboard.\n *\n * @param {string} text The text to copy.\n * @param {Function} [onSuccess] An optional callback to execute on success.\n * @param {Function} [onFailure] An optional callback to execute on failure.\n * @return {undefined}\n */\n\nfunction fallbackCopyTextToClipboard(text, onSuccess, onFailure) {\n  const bodyScrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n  const textArea = document.createElement(\"textarea\");\n  textArea.value = text;\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    const successful = document.execCommand(\"copy\");\n\n    if (successful) {\n      onSuccess && onSuccess();\n    } else {\n      onFailure && onFailure();\n    }\n  } catch (err) {\n    onFailure && onFailure(err);\n  }\n\n  document.body.removeChild(textArea) && document.documentElement.scrollTop && (document.documentElement.scrollTop = bodyScrollTop) || (document.body.scrollTop = bodyScrollTop);\n}\n/**\n * Copies a text to clipboard.\n *\n * @param {string} text The text to copy.\n * @param {Function} [onSuccess] An optional callback to execute on success.\n * @param {Function} [onFailure] An optional callback to execute on failure.\n * @return {undefined}\n */\n\n\nexport function copyTextToClipboard(text, onSuccess, onFailure) {\n  if (!navigator.clipboard) {\n    fallbackCopyTextToClipboard(text, onSuccess, onFailure);\n    return;\n  }\n\n  navigator.clipboard.writeText(text).then(function () {\n    onSuccess && onSuccess();\n  }, function (err) {\n    onFailure && onFailure(err);\n  });\n}\n/**\n * Asynchronously invokes a callback multiple times, each in its own animation frame.\n *\n * @param {number} n The number of times the callback should be invoked.\n * @param {Function} callback The callback to invoke.\n * @return {*} The identifier of the first animation frame or \"n\" if it is falsy during the outermost call.\n */\n\nexport const rAFLooper = (n, callback) => n && window.requestAnimationFrame(() => (callback(), rAFLooper(--n, callback)));\n/**\n * Requests a predefined number of animation frames and executes a callback after.\n *\n * @param {number} count The number of animation frames to request before executing the callback.\n * @param {Function} callback The callback to execute after \"count\" animation frames have been requested.\n * @return {number} The identifier of the first animation frame.\n */\n\nexport const nestedRAF = (count, callback) => {\n  let c = count || 1;\n\n  const innerCallback = () => {\n    c--;\n\n    if (!c) {\n      callback();\n      return;\n    }\n\n    window.requestAnimationFrame(innerCallback);\n  };\n\n  return window.requestAnimationFrame(innerCallback);\n};\n/**\n * Returns the raw contents of the URI fragment (i.e. everything after the hash (\"#\") character).\n *\n * @param {string} URIFragment The URI fragment.\n * @return {string} The raw contents of the URI fragment.\n */\n\nexport function getRawURIFragment(URIFragment) {\n  const fragment = (URIFragment || window.location.hash).replace(/^#/, \"\");\n  return fragment;\n}\n/**\n * Returns the decoded contents of a URI fragment (i.e. everything after the hash (\"#\") character).\n *\n * @param {string} URIFragment The URI fragment.\n * @return {string} The contents of the URI fragment, decoded.\n */\n\nexport function getDecodedURIFragment(URIFragment) {\n  const fragment = decodeURIComponent(getRawURIFragment(URIFragment));\n  return fragment;\n}\n/**\n * Appends an encoded JSON fragment to a URI.\n *\n * @param {string} URI The URI.\n * @param {*} data Data to encode in JSON format.\n */\n\nexport function appendEncodedJSONFragmentToURI(URI, data) {\n  return URI + \"#\" + encodeURIComponent(JSON.stringify(data));\n}\n/**\n * Returnes the decoded JSON data eventually stored in the URI fragment.\n *\n * @param {*} defaultData Default data to return if either the URI fragment is missing or\n *                        the content of the URI fragment is not a valid JSON-encoded string.\n * @return {*} The decoded JSON data or \"defaultData\".\n */\n\nexport function getDecodedJSONFromFragmentURI(defaultData = null) {\n  const fragment = window.location.hash;\n\n  if (!isEmpty(fragment)) {\n    const decodedFragment = getDecodedURIFragment(fragment);\n\n    if (isJSONString(decodedFragment)) {\n      return JSON.parse(decodedFragment);\n    }\n  }\n\n  return defaultData;\n}\n/**\n * Parses a multidimensional query string and returns an object with the parsed args.\n *\n * @see https://stackoverflow.com/questions/8648892/convert-url-parameters-to-a-javascript-object#answer-44713056\n *\n * @param {string} str The query string.\n * @param {Object} [array] The base object to use (or a new object if omitted or falsy).\n * @return {Object} The object with the parsed data.\n */\n\nexport function parseQueryStringArgsMultiDim(str, array) {\n  if (!str) {\n    str = window.location.search.substr(1);\n  }\n\n  let i, j, ct, p, lastObj, obj, undef, chr, tmp, key, value, postLeftBracketPos, keys, keysLen;\n\n  const strArr = String(str).replace(/^&/, \"\").replace(/&$/, \"\").split(\"&\"),\n        sal = strArr.length,\n        fixStr = function (str) {\n    return decodeURIComponent(str.replace(/\\+/g, \"%20\"));\n  };\n\n  if (!array) {\n    array = {};\n  }\n\n  for (i = 0; i < sal; i++) {\n    tmp = strArr[i].split(\"=\");\n    key = fixStr(tmp[0]);\n    value = tmp.length < 2 ? \"\" : fixStr(tmp[1]);\n\n    while (key.charAt(0) === \" \") {\n      key = key.slice(1);\n    }\n\n    if (key.indexOf(\"\\x00\") > -1) {\n      key = key.slice(0, key.indexOf(\"\\x00\"));\n    }\n\n    if (key && key.charAt(0) !== \"[\") {\n      keys = [];\n      postLeftBracketPos = 0;\n\n      for (j = 0; j < key.length; j++) {\n        if (key.charAt(j) === \"[\" && !postLeftBracketPos) {\n          postLeftBracketPos = j + 1;\n        } else if (key.charAt(j) === \"]\") {\n          if (postLeftBracketPos) {\n            if (!keys.length) {\n              keys.push(key.slice(0, postLeftBracketPos - 1));\n            }\n\n            keys.push(key.substr(postLeftBracketPos, j - postLeftBracketPos));\n            postLeftBracketPos = 0;\n\n            if (key.charAt(j + 1) !== \"[\") {\n              break;\n            }\n          }\n        }\n      }\n\n      if (!keys.length) {\n        keys = [key];\n      }\n\n      for (j = 0; j < keys[0].length; j++) {\n        chr = keys[0].charAt(j);\n\n        if (chr === \" \" || chr === \".\" || chr === \"[\") {\n          keys[0] = keys[0].substr(0, j) + \"_\" + keys[0].substr(j + 1);\n        }\n\n        if (chr === \"[\") {\n          break;\n        }\n      }\n\n      obj = array;\n\n      for (j = 0, keysLen = keys.length; j < keysLen; j++) {\n        key = keys[j].replace(/^['\"]/, \"\").replace(/['\"]$/, \"\");\n        lastObj = obj;\n\n        if (key !== \"\" && key !== \" \" || j === 0) {\n          if (obj[key] === undef) {\n            obj[key] = {};\n          }\n\n          obj = obj[key];\n        } else {\n          // To insert new dimension\n          ct = -1;\n\n          for (p in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, p)) {\n              if (+p > ct && p.match(/^\\d+$/g)) {\n                ct = +p;\n              }\n            }\n          }\n\n          key = ct + 1;\n        }\n      }\n\n      lastObj[key] = value;\n    }\n  }\n  /* ===== */\n\n  /*\n   * This code converts the object properties to arrays if they are objects with consecutive integer keys\n   * from 0 to n, where n is the number of properties of that object minus one\n   * (i.e. it converts meaningful objects which are to be interpreted as arrays to arrays).\n   */\n\n\n  const fnNormalizeObjToArrayIfPropsAreConsecutiveIntsFrom0 = function (obj) {\n    const keys = Object.keys(obj);\n    const truthMap = {};\n\n    for (let i = 0; i < keys.length; i++) {\n      truthMap[i] = true;\n    }\n\n    const array = [];\n\n    for (let i = 0; i < keys.length; i++) {\n      const prop = keys[i] + \"\";\n\n      if (!prop.match(/^[0-9]+$/)) {\n        return obj;\n      }\n\n      const intProp = Number(prop);\n\n      if (truthMap[intProp]) {\n        array[intProp] = obj[prop];\n        delete truthMap[intProp];\n      } else {\n        return obj;\n      }\n    }\n\n    if (Object.keys(truthMap).length === 0) {\n      return array;\n    } else {\n      return obj;\n    }\n  };\n\n  const fnNormalizeToArrayIfNeeded = function fnNormalizeToArrayIfNeeded(obj) {\n    for (const prop in obj) {\n      if (isPlainObject(obj[prop])) {\n        obj[prop] = fnNormalizeObjToArrayIfPropsAreConsecutiveIntsFrom0(obj[prop]);\n        fnNormalizeToArrayIfNeeded(obj[prop]);\n      }\n    }\n  };\n  /* /===== */\n\n\n  fnNormalizeToArrayIfNeeded(array);\n  return array;\n}\n/**\n * Gets the query string arguments of the current location in a multidimensional fashion\n * (multidimension-aware).\n *\n * @return {Object} An object representing the query string arguments.\n */\n\nexport function getQueryStringArgsMultiDim() {\n  const obj = {};\n  parseQueryStringArgsMultiDim(location.search.substring(1), obj);\n  return obj;\n}\n/**\n * Focuses an input without scrolling.\n *\n * @see https://stackoverflow.com/questions/4963053/focus-to-input-without-scrolling\n *\n * @param {Element} elem The DOM element.\n */\n\nexport const cursorFocus = function (elem) {\n  let x, y; // More sources for scroll x, y offset.\n\n  if (typeof window.pageXOffset !== \"undefined\") {\n    x = window.pageXOffset;\n    y = window.pageYOffset;\n  } else if (typeof window.scrollX !== \"undefined\") {\n    x = window.scrollX;\n    y = window.scrollY;\n  } else if (document.documentElement && typeof document.documentElement.scrollLeft !== \"undefined\") {\n    x = document.documentElement.scrollLeft;\n    y = document.documentElement.scrollTop;\n  } else {\n    x = document.body.scrollLeft;\n    y = document.body.scrollTop;\n  }\n\n  elem.focus();\n\n  if (typeof x !== \"undefined\") {\n    window.scrollTo(x, y);\n  }\n};\n/**\n * Detects wrapped elements.\n *\n * @param {string|Element[]} classNameOrElements A class name (with or without the leading dot) or the DOM elements to check.\n * @return {Element[]} The wrapped DOM elements.\n */\n\nexport function detectWrapped(classNameOrElements) {\n  let elements;\n\n  if (typeof classNameOrElements === \"string\") {\n    classNameOrElements = classNameOrElements.replace(/^\\./, \"\");\n    elements = document.getElementsByClassName(classNameOrElements);\n  } else {\n    elements = classNameOrElements;\n  }\n\n  const wrapped = [];\n  let prev = {};\n  let curr = {};\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    curr = element.getBoundingClientRect();\n\n    if (prev && prev.top < curr.top) {\n      wrapped.push(element);\n    }\n\n    prev = i === 0 ? curr : prev;\n  }\n\n  return wrapped;\n}\n/**\n * Gets the maximum nesting level of an element (or of the whole DOM if \"document.body\" is given as parameter).abs\n *\n * @param {Element} elem The DOM element from which to start identifying the maximum nesting level.\n * @return {number} The maximum nesting level, starting from 0 if the given element has no children.\n */\n\nexport function maxNestingLevel(el) {\n  if (!el.children) {\n    return 0;\n  }\n\n  let max = -1;\n\n  for (let i = 0; i < el.children.length; i++) {\n    const nestingLevel = maxNestingLevel(el.children[i]);\n\n    if (nestingLevel > max) {\n      max = nestingLevel;\n    }\n  }\n\n  return max + 1;\n}\n/**\n * @type {RegExp}\n */\n\nconst REGEXP_SCROLL_PARENT = /^(visible|hidden)/;\n/**\n * Get the first scrollable ancestor of an element.\n *\n * @param {Element} el The element to use as the base from which to determine its first scrollable ancestor.\n * @return {Element} The first scrollable ancestor element scroll, or the document body.\n */\n\nexport const getScrollableAncestor = el => !(el instanceof HTMLElement) || typeof window.getComputedStyle !== \"function\" ? null : el.scrollHeight >= el.clientHeight && !REGEXP_SCROLL_PARENT.test(window.getComputedStyle(el).overflowY || \"visible\") ? el : getScrollableAncestor(el.parentElement) || document.scrollingElement || document.body;\n/**\n * Smoothly scrolls to the top of a scrollable element or the browser's window.\n *\n * @param {Element} [el] The element. Defaults to \"window\".\n * @return {undefined}\n */\n\nexport const smoothScrollToTop = (el = window) => el.scroll({\n  top: 0,\n  behavior: \"smooth\"\n});\n//# sourceMappingURL=web.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nexport default class Advice {\n  constructor(fn) {\n    this.fn = fn;\n  }\n\n}\n//# sourceMappingURL=Advice.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Advice from \"./Advice\";\nexport default class AfterAdvice extends Advice {}\n//# sourceMappingURL=AfterAdvice.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Advice from \"./Advice\";\nexport default class AroundAdvice extends Advice {}\n//# sourceMappingURL=AroundAdvice.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Advice from \"./Advice\";\nexport default class BeforeAdvice extends Advice {}\n//# sourceMappingURL=BeforeAdvice.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport pigretto from \"../pigretto\";\nimport call from \"../pointcuts/shorthands/call\";\nimport set from \"../pointcuts/shorthands/set\";\nimport get from \"../pointcuts/shorthands/get\";\nimport escapeStringRegexp from \"escape-string-regexp\";\n/**\n * Builtin function using pigretto's API to implement lazy loading for objects.\n *\n * @param {Object} target A target object to lazy load. Lazy loading in this case means deferring an operation on the object\n *                        when it is used for the very first time by the client code.\n * @param {Object} options The options of the lazy loading.\n * @param {Function} onceCallback The callback to execute only once before performing the very first operation on the given \"target\"\n *                                when the given \"target\" is used for the very first time.\n *                                This callback is mandatory (otherwise it doesn't make sense to use \"lazy()\" at all)\n *                                and allows e.g. to perform a heavy initialization operation lazily on the underlying target object.\n * @param {Object} [options.ignoredTypes] The types which prototypes to ignore when going up the prototype chain in order to identify\n *                                        which prototypes to intercept when lazy loading.\n *                                        By default, only the properties set on the \"Object\" prototype will be ignored.\n *                                        This option can be used e.g. to avoid the performance of a heavy lazy initialization\n *                                        when calling the methods of a parent class of the given \"target\" object.\n * @param {boolean} [options.interceptConstructor] Whether or not to intercept the getting/setting of the \"constructor\" property.\n *                                                 Defaults to \"false\", meaning that when getting/setting \"target.constructor\",\n *                                                 this operation will not trigger the underlying lazy loading.\n * @param {string[]} [options.propertiesToIgnore] Property names or method names to ignore for lazy loading.\n * @param {Array} [options.pointcuts] Array of pointcut shorthands to use for interception and lazy loading.\n *                                    By default, only \"call\", \"get\" and \"set\" pointcuts will be used.\n *                                    Other pointcut shorthands (e.g. \"apply\", \"construct\") will be ignored, if passed.\n * @return {Proxy} A new proxy object for the given target which supports this builtin feature.\n */\n\nexport default function lazyObject(target, {\n  onceCallback,\n  ignoredTypes = [Object],\n  interceptConstructor = false,\n  propertiesToIgnore = [],\n  pointcuts = [call, get, set]\n} = {}) {\n  let hasCall = false,\n      hasGet = false,\n      hasSet = false;\n  const rules = [];\n  const propertiesMap = {};\n  const constructorsToIgnore = ignoredTypes.map(Type => Type.prototype.constructor);\n  let current = target;\n  let currentIsProto = false;\n\n  while (current) {\n    const constructor = current.constructor;\n\n    if (!currentIsProto || !constructorsToIgnore.includes(constructor)) {\n      const properties = Reflect.ownKeys(current);\n      properties.map(property => propertiesMap[property] = {\n        isMethod: property !== \"constructor\" && typeof target[property] === \"function\"\n      });\n    }\n\n    current = Object.getPrototypeOf(current);\n    currentIsProto = true;\n  }\n\n  propertiesToIgnore.map(propertyToIgnore => delete propertiesMap[propertyToIgnore]);\n  !interceptConstructor && delete propertiesMap[\"constructor\"];\n  pointcuts.map(pointcut => {\n    if (pointcut === call) {\n      hasCall = true;\n    } else if (pointcut === get) {\n      hasGet = true;\n    } else if (pointcut === set) {\n      hasSet = true;\n    }\n  });\n  const properties = Object.keys(propertiesMap);\n  let firstOperation = true;\n\n  const callback = function (...args) {\n    if (firstOperation) {\n      firstOperation = false;\n      onceCallback.apply(this, args);\n    }\n  };\n\n  const escape = names => names.map(escapeStringRegexp);\n\n  const regex = escapedNames => new RegExp(`^(${escapedNames.join(\"|\")})$`);\n\n  const addRule = regex => pointcut => rules.push([regex, pointcut().before(callback)]);\n\n  if (hasCall) {\n    const methodNames = properties.filter(property => propertiesMap[property].isMethod);\n    const escapedMethodNames = escape(methodNames);\n    addRule(regex(escapedMethodNames))(call);\n  }\n\n  if (hasGet || hasSet) {\n    const propertyNames = properties.filter(property => !propertiesMap[property].isMethod);\n    const escapedPropertyNames = escape(propertyNames);\n    hasGet && addRule(regex(escapedPropertyNames))(get);\n    hasSet && addRule(regex(escapedPropertyNames))(set);\n  }\n\n  const pigrettarget = pigretto(target, rules);\n  return pigrettarget;\n}\n//# sourceMappingURL=lazyObject.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport trapHandlerForRules from \"../trap/trapHandlerForRules\";\n/**\n * Factory function to generate a new handler object for the given proxy rules.\n *\n * @param {Object|Array} proxyRules The proxy rules.\n * @return {Object} The handler object for the given proxy rules.\n */\n\nexport default function handlerFactory(proxyRules) {\n  const handler = trapHandlerForRules(proxyRules);\n  return handler;\n}\n//# sourceMappingURL=handlerFactory.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport handlerFactory from \"./factory/handlerFactory\";\n/**\n * Generates a new pigretto proxy object.\n *\n * A pigretto proxy object lets proxying and advising the following operations:\n *\n *    - Calling a method (`call()` method);\n *    - Getting a property (`get()` method);\n *    - Setting a property (`set()` method);\n *    - Calling a function (`[applyRule]` symbol property with `apply()` method);\n *    - Constructing a new object via the \"new\" keyword (`[constructRule]` symbol property with `construct()`).\n *\n * @param {*} target A function, a constructor function or an object to proxy.\n * @param {Object|Array} proxyRules The proxy rules.\n *                                  This parameter can be:\n *\n *                                      - An object containing proxy rules as keys and pointcuts with advices as values;\n *\n *                                      - An array of rules, each rule either being an object with proxy rules as keys\n *                                        and advices as values or a tuple of two elements: an array of rules of the same\n *                                        type or a single rule as the first element and a pointcut with advices for those rules or\n *                                        that rule as the second element;\n *\n * @return {Proxy} A new proxy object for the given target.\n */\n\nexport default function pigretto(target, proxyRules) {\n  const handler = handlerFactory(proxyRules);\n  const proxy = new Proxy(target, handler);\n  return proxy;\n}\n//# sourceMappingURL=pigretto.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Pointcut from \"./Pointcut\";\nimport BeforeAdvice from \"../advices/BeforeAdvice\";\nimport AfterAdvice from \"../advices/AfterAdvice\";\nimport AroundAdvice from \"../advices/AroundAdvice\";\nexport default class FunctionCallPointcut extends Pointcut {\n  /**\n   * Register a before advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A function which receives the parameters\n   *                            of the underlying proxied function before calling it.\n   * @return {FunctionCallPointcut} This pointcut (fluent interface).\n   */\n  before(adviceFn) {\n    this.advices.push(new BeforeAdvice(adviceFn));\n    return this;\n  }\n  /**\n   * Register an after advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A higher-order function which will receive\n   *                            the parameters of the proxied function and MUST return a function\n   *                            which will receive the return value of the underlying proxied function\n   *                            as parameter.\n   * @return {FunctionCallPointcut} This pointcut (fluent interface).\n   */\n\n\n  after(adviceFn) {\n    this.advices.push(new AfterAdvice(adviceFn));\n    return this;\n  }\n  /**\n   * Register an around advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A higher-order function which will receive the \"proceed\"\n   *                            function as parameter and which MUST return a function which will receive the parameters\n   *                            of the underlying proxied function.\n   *                            If the advice function proceeds, the callback given to \"proceed\" will receive\n   *                            the return value to return to the caller or may return another value\n   *                            instead of the current return value.\n   * @return {FunctionCallPointcut} This pointcut (fluent interface).\n   */\n\n\n  around(adviceFn) {\n    this.advices.push(new AroundAdvice(adviceFn));\n    return this;\n  }\n\n}\n//# sourceMappingURL=FunctionCallPointcut.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Pointcut from \"./Pointcut\";\nimport BeforeAdvice from \"../advices/BeforeAdvice\";\nimport AfterAdvice from \"../advices/AfterAdvice\";\nimport AroundAdvice from \"../advices/AroundAdvice\";\nexport default class MethodCallPointcut extends Pointcut {\n  /**\n   * Register a before advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A function which receives the parameters\n   *                            of the underlying proxied method call.\n   * @return {MethodCallPointcut} This pointcut (fluent interface).\n   */\n  before(adviceFn) {\n    this.advices.push(new BeforeAdvice(adviceFn));\n    return this;\n  }\n  /**\n   * Register an after advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A higher-order function which will receive\n   *                            the parameters of the proxied method and MUST return a function\n   *                            which will receive the return value of the underlying proxied function\n   *                            as parameter.\n   * @return {MethodCallPointcut} This pointcut (fluent interface).\n   */\n\n\n  after(adviceFn) {\n    this.advices.push(new AfterAdvice(adviceFn));\n    return this;\n  }\n  /**\n   * Register an around advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A higher-order function which will receive the \"proceed\"\n   *                            function as parameter and which MUST return a function which will receive the parameters\n   *                            of the underlying proxied method.\n   *                            If the advice function proceeds by calling the \"proceed\" function, the callback given to \"proceed\" will receive\n   *                            the return value to return to the caller or may return another value\n   *                            instead of the current return value.\n   * @return {MethodCallPointcut} This pointcut (fluent interface).\n   */\n\n\n  around(adviceFn) {\n    this.advices.push(new AroundAdvice(adviceFn));\n    return this;\n  }\n\n}\n//# sourceMappingURL=MethodCallPointcut.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Pointcut from \"./Pointcut\";\nimport BeforeAdvice from \"../advices/BeforeAdvice\";\nimport AfterAdvice from \"../advices/AfterAdvice\";\nimport AroundAdvice from \"../advices/AroundAdvice\";\nexport default class ObjectConstructionPointcut extends Pointcut {\n  /**\n   * Register a before advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A function which receives the constructor parameters\n   *                            of the underlying proxied object construction.\n   * @return {ObjectConstructionPointcut} This pointcut (fluent interface).\n   */\n  before(adviceFn) {\n    this.advices.push(new BeforeAdvice(adviceFn));\n    return this;\n  }\n  /**\n   * Register an after advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A higher-order function which will receive\n   *                            the parameters of the proxied object construction and MUST return a function\n   *                            which will receive the instance object created by the underlying proxied\n   *                            object construction.\n   * @return {ObjectConstructionPointcut} This pointcut (fluent interface).\n   */\n\n\n  after(adviceFn) {\n    this.advices.push(new AfterAdvice(adviceFn));\n    return this;\n  }\n  /**\n   * Register an around advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A higher-order function which will receive the \"proceed\"\n   *                            function as parameter and which MUST return a function which will receive the constructor parameters\n   *                            of the underlying object construction.\n   *                            If the advice function proceeds, the callback given to \"proceed\" will receive\n   *                            the instance object to return to the caller or may return another instance\n   *                            instead of the current one.\n   * @return {ObjectConstructionPointcut} This pointcut (fluent interface).\n   */\n\n\n  around(adviceFn) {\n    this.advices.push(new AroundAdvice(adviceFn));\n    return this;\n  }\n\n}\n//# sourceMappingURL=ObjectConstructionPointcut.js.map","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nexport default class Pointcut {\n  constructor() {\n    _defineProperty(this, \"advices\", []);\n  }\n\n}\n//# sourceMappingURL=Pointcut.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Pointcut from \"./Pointcut\";\nimport BeforeAdvice from \"../advices/BeforeAdvice\";\nimport AfterAdvice from \"../advices/AfterAdvice\";\nimport AroundAdvice from \"../advices/AroundAdvice\";\nexport default class PropertyGettingPointcut extends Pointcut {\n  /**\n   * Register a before advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A function to execute before getting a property.\n   * @return {PropertyGettingPointcut} This pointcut (fluent interface).\n   */\n  before(adviceFn) {\n    this.advices.push(new BeforeAdvice(adviceFn));\n    return this;\n  }\n  /**\n   * Register an after advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function.\n   *                            A function which will receive the current value of the property.\n   * @return {PropertyGettingPointcut} This pointcut (fluent interface).\n   */\n\n\n  after(adviceFn) {\n    this.advices.push(new AfterAdvice(adviceFn));\n    return this;\n  }\n  /**\n   * Register an around advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A higher-order function which will receive the \"proceed\"\n   *                            function as parameter and which MUST return a function to execute before getting a property.\n   *                            If the advice function proceeds, the callback given to \"proceed\" will receive\n   *                            the value of the property to return to the caller or may return another value\n   *                            to return to the caller instead of the one passed as argument.\n   * @return {PropertyGettingPointcut} This pointcut (fluent interface).\n   */\n\n\n  around(adviceFn) {\n    this.advices.push(new AroundAdvice(adviceFn));\n    return this;\n  }\n\n}\n//# sourceMappingURL=PropertyGettingPointcut.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Pointcut from \"./Pointcut\";\nimport BeforeAdvice from \"../advices/BeforeAdvice\";\nimport AfterAdvice from \"../advices/AfterAdvice\";\nimport AroundAdvice from \"../advices/AroundAdvice\";\nexport default class PropertySettingPointcut extends Pointcut {\n  /**\n   * Register a before advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A function to execute before setting a property\n   *                            which will receive the previous property value.\n   * @return {PropertySettingPointcut} This pointcut (fluent interface).\n   */\n  before(adviceFn) {\n    this.advices.push(new BeforeAdvice(adviceFn));\n    return this;\n  }\n  /**\n   * Register an after advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A higher-order function which will receive\n   *                            the previous value of the property and MUST return a new function\n   *                            which will receive the new property value set on the object's property.\n   * @return {PropertySettingPointcut} This pointcut (fluent interface).\n   */\n\n\n  after(adviceFn) {\n    this.advices.push(new AfterAdvice(adviceFn));\n    return this;\n  }\n  /**\n   * Register an around advice for this pointcut.\n   *\n   * @param {Function} adviceFn The advice function. A higher-order function which will receive the \"proceed\"\n   *                            function as parameter and which MUST return a function which will receive the previous value of the property.\n   *                            If the advice function proceeds, the callback given to \"proceed\" will receive\n   *                            the new value of the property to return in order to set it on the object\n   *                            or may return another value to set it on the object's property.\n   * @return {PropertySettingPointcut} This pointcut (fluent interface).\n   */\n\n\n  around(adviceFn) {\n    this.advices.push(new AroundAdvice(adviceFn));\n    return this;\n  }\n\n}\n//# sourceMappingURL=PropertySettingPointcut.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport FunctionCallPointcut from \"../FunctionCallPointcut\";\n/**\n * Returns a new function call pointcut.\n *\n * @return {FunctionCallPointcut} A function call pointcut.\n */\n\nexport default function apply() {\n  return new FunctionCallPointcut();\n}\n//# sourceMappingURL=apply.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport MethodCallPointcut from \"../MethodCallPointcut\";\n/**\n * Returns a new method call pointcut.\n *\n * @return {MethodCallPointcut} A method call pointcut.\n */\n\nexport default function call() {\n  return new MethodCallPointcut();\n}\n//# sourceMappingURL=call.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport ObjectConstructionPointcut from \"../ObjectConstructionPointcut\";\n/**\n * Returns a new object construction pointcut.\n *\n * @return {ObjectConstructionPointcut} An object construction pointcut.\n */\n\nexport default function construct() {\n  return new ObjectConstructionPointcut();\n}\n//# sourceMappingURL=construct.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport PropertyGettingPointcut from \"../PropertyGettingPointcut\";\n/**\n * Returns a new property getting pointcut.\n *\n * @return {PropertyGettingPointcut} A property getting pointcut.\n */\n\nexport default function get() {\n  return new PropertyGettingPointcut();\n}\n//# sourceMappingURL=get.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport PropertySettingPointcut from \"../PropertySettingPointcut\";\n/**\n * Returns a new property setting pointcut.\n *\n * @return {PropertySettingPointcut} A property setting pointcut.\n */\n\nexport default function set() {\n  return new PropertySettingPointcut();\n}\n//# sourceMappingURL=set.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Rule from \"./Rule\";\nexport default class ExactRule extends Rule {\n  constructor(property) {\n    super();\n    this.property = property;\n  }\n\n  matches(effectiveProperty) {\n    return this.property === effectiveProperty;\n  }\n\n}\n//# sourceMappingURL=ExactRule.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Rule from \"./Rule\";\nexport default class ORedRule extends Rule {\n  constructor(rules) {\n    super();\n    this.rules = rules;\n  }\n\n  matches(effectivePropertyName) {\n    for (const rule of this.rules) {\n      if (rule.matches(effectivePropertyName)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n//# sourceMappingURL=ORedRule.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport Rule from \"./Rule\";\nexport default class RegexRule extends Rule {\n  constructor(regex) {\n    super(); // This line prevents interference with the statefulness of the RegExp object.\n\n    this.regex = new RegExp(regex);\n  }\n\n  matches(effectivePropertyName) {\n    // This line resets the state of the RegExp object.\n    this.regex.lastIndex = 0;\n    return typeof effectivePropertyName !== \"symbol\" && this.regex.test(effectivePropertyName);\n  }\n\n}\n//# sourceMappingURL=RegexRule.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nexport default class Rule {}\n//# sourceMappingURL=Rule.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @type {Symbol}\n */\nconst applyRule = Symbol(\"applyRule\");\nexport default applyRule;\n//# sourceMappingURL=applyRule.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @type {Symbol}\n */\nconst constructRule = Symbol(\"constructRule\");\nexport default constructRule;\n//# sourceMappingURL=constructRule.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport declarativeFactory from \"declarative-factory\";\nimport { isArray } from \"js-utl\";\nimport ORedRule from \"../ORedRule\";\nimport RegexRule from \"../RegexRule\";\nimport ExactRule from \"../ExactRule\";\nconst REGEX_STRING_TOKEN = \"/\";\n\nconst regexRule = regex => new RegexRule(regex);\n\nconst exactRule = property => new ExactRule(property);\n\nconst parseSingle = ruleToParse => {\n  let factoryParam = ruleToParse;\n  const factory = declarativeFactory([[() => ruleToParse instanceof RegExp, regexRule], [() => {\n    if (typeof ruleToParse !== \"string\") {\n      return false;\n    }\n\n    const initialRegexStringToken = ruleToParse.indexOf(REGEX_STRING_TOKEN);\n    const lastRegexStringToken = ruleToParse.lastIndexOf(REGEX_STRING_TOKEN);\n\n    if (initialRegexStringToken === 0 && lastRegexStringToken > 0) {\n      const stringLiteralRegex = ruleToParse.substring(1, lastRegexStringToken);\n      const flags = ruleToParse.substring(lastRegexStringToken + 1) || void 0;\n      factoryParam = new RegExp(stringLiteralRegex, flags);\n      return true;\n    }\n\n    return false;\n  }, regexRule], exactRule]);\n  return factory(factoryParam);\n};\n\nconst parseMultiple = rulesToParse => {\n  const rules = [];\n\n  for (const ruleToParse of rulesToParse) {\n    const rule = parseSingle(ruleToParse);\n    rules.push(rule);\n  }\n\n  return new ORedRule(rules);\n};\n\nexport default function parseRule(rule) {\n  const parse = declarativeFactory([[isArray(rule), parseMultiple], parseSingle]);\n  return parse(rule);\n}\n//# sourceMappingURL=parseRule.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport declarativeFactory from \"declarative-factory\";\nimport { isArray } from \"js-utl\";\n\nconst objectRulesGenerator = function* (proxyRules) {\n  const ruleKeys = Reflect.ownKeys(proxyRules);\n\n  for (const ruleKey of ruleKeys) {\n    const pointcut = proxyRules[ruleKey];\n    yield {\n      rule: ruleKey,\n      pointcut\n    };\n  }\n};\n\nconst arrayRulesGenerator = function* (proxyRules) {\n  for (const proxyRule of proxyRules) {\n    if (isArray(proxyRule)) {\n      // Tuple.\n      const [rule, pointcut] = proxyRule;\n      yield {\n        rule,\n        pointcut\n      };\n    } else {\n      // Object.\n      yield* objectRulesGenerator(proxyRule);\n    }\n  }\n};\n/**\n * A generator for proxy rules.\n *\n * @param {Object|Array} proxyRules An array of proxy rules or object with rules as keys.\n * @yields {Object} The next rule object, having two keys:\n *\n *                      - rule: The rule, as-is (as given by the client code);\n *                      - pointcut: The pointcut associated with that rule.\n *\n */\n\n\nexport default function* rulesGenerator(proxyRules) {\n  const generator = declarativeFactory([[isArray(proxyRules), arrayRulesGenerator], objectRulesGenerator]);\n  yield* generator(proxyRules);\n}\n//# sourceMappingURL=rulesGenerator.js.map","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport declarativeFactory from \"declarative-factory\";\nimport MethodCallPointcut from \"../pointcuts/MethodCallPointcut\";\nimport PropertyGettingPointcut from \"../pointcuts/PropertyGettingPointcut\";\nimport PropertySettingPointcut from \"../pointcuts/PropertySettingPointcut\";\nimport FunctionCallPointcut from \"../pointcuts/FunctionCallPointcut\";\nimport ObjectConstructionPointcut from \"../pointcuts/ObjectConstructionPointcut\";\nimport ExactRule from \"../rules/ExactRule\";\nimport applyRule from \"../rules/applyRule\";\nimport constructRule from \"../rules/constructRule\";\nimport apply from \"../pointcuts/shorthands/apply\";\nimport construct from \"../pointcuts/shorthands/construct\";\nimport BeforeAdvice from \"../advices/BeforeAdvice\";\nimport AroundAdvice from \"../advices/AroundAdvice\";\nimport CallTrapExecutor from \"./executors/CallTrapExecutor\";\nimport GetTrapExecutor from \"./executors/GetTrapExecutor\";\nimport SetTrapExecutor from \"./executors/SetTrapExecutor\";\nimport ApplyTrapExecutor from \"./executors/ApplyTrapExecutor\";\nimport ConstructTrapExecutor from \"./executors/ConstructTrapExecutor\";\nimport { isUndefined } from \"js-utl\";\nexport default class Trap {\n  constructor() {\n    _defineProperty(this, \"advices\", {\n      // Requires matching (get trap). Requires distribution.\n      call: [],\n      // Requires matching (get trap). Requires distribution.\n      get: [],\n      // Requires matching (set trap). Requires distribution.\n      set: [],\n      // Does not require matching (apply trap). Requires distribution.\n      apply: [],\n      // Does not require matching (construct trap). Requires distribution.\n      construct: []\n    });\n\n    _defineProperty(this, \"distributedAdvices\", {\n      call: {\n        before: void 0,\n        around: void 0,\n        after: void 0\n      },\n      get: {\n        before: void 0,\n        around: void 0,\n        after: void 0\n      },\n      set: {\n        before: void 0,\n        around: void 0,\n        after: void 0\n      },\n      apply: {\n        before: void 0,\n        around: void 0,\n        after: void 0\n      },\n      construct: {\n        before: void 0,\n        around: void 0,\n        after: void 0\n      }\n    });\n\n    _defineProperty(this, \"matchedDistributedAdvices\", {\n      call: new Map(),\n      get: new Map(),\n      set: new Map()\n    });\n\n    _defineProperty(this, \"trapExecutors\", {\n      call: new CallTrapExecutor(),\n      get: new GetTrapExecutor(),\n      set: new SetTrapExecutor(),\n      apply: new ApplyTrapExecutor(),\n      construct: new ConstructTrapExecutor()\n    });\n  }\n\n  /**\n   * @private\n   */\n  hasAtLeastOneAdviceOfPointcutType(pointcutType) {\n    return !!this.advices[pointcutType].length;\n  }\n  /**\n   * @private\n   */\n\n\n  addAdvices(pointcutType, rule, advices = []) {\n    advices.map(advice => this.advices[pointcutType].push({\n      rule,\n      advice\n    }));\n  }\n  /**\n   * @private\n   */\n\n\n  lazilyDistributeAdvices(pointcutType) {\n    if (isUndefined(this.distributedAdvices[pointcutType].before)) {\n      this.distributedAdvices[pointcutType].before = [];\n      this.distributedAdvices[pointcutType].around = [];\n      this.distributedAdvices[pointcutType].after = [];\n\n      for (const {\n        rule,\n        advice\n      } of this.advices[pointcutType]) {\n        const subKey = declarativeFactory([[() => advice instanceof BeforeAdvice, \"before\"], [() => advice instanceof AroundAdvice, \"around\"], \"after\"]);\n        this.distributedAdvices[pointcutType][subKey].push({\n          rule,\n          advice\n        });\n      }\n    }\n  }\n  /**\n   * For \"call\", \"get\" and \"set\" advices.\n   *\n   * @private\n   */\n\n\n  lazilyMatchAdvices(pointcutType, property) {\n    this.lazilyDistributeAdvices(pointcutType);\n    const map = this.matchedDistributedAdvices[pointcutType];\n\n    if (!map.has(property)) {\n      const node = {\n        before: [],\n        around: [],\n        after: []\n      };\n      map.set(property, node);\n      const beforeAdvices = this.distributedAdvices[pointcutType].before;\n      const aroundAdvices = this.distributedAdvices[pointcutType].around;\n      const afterAdvices = this.distributedAdvices[pointcutType].after;\n\n      const match = advices => key => {\n        for (const {\n          rule,\n          advice\n        } of advices) {\n          const matches = rule.matches(property);\n\n          if (matches) {\n            node[key].push({\n              rule,\n              advice\n            });\n          }\n        }\n      };\n\n      match(beforeAdvices)(\"before\");\n      match(aroundAdvices)(\"around\");\n      match(afterAdvices)(\"after\");\n    }\n  }\n  /**\n   * Adds a pointcut and its associated rule to this trap.\n   * If a pointcut is of an unknown type, it will be ignored.\n   *\n   * @param {Pointcut|Function} pointcut The pointcut or a function (for implicit apply and construct pointcuts).\n   * @param {Rule} rule The rule.\n   * @return {Trap} This trap object.\n   */\n\n\n  addPointcutRule(pointcut, rule) {\n    const isImplicitBeforeAdvice = () => typeof pointcut === \"function\" && rule instanceof ExactRule;\n\n    const pointcutType = declarativeFactory([[() => pointcut instanceof MethodCallPointcut, \"call\"], [() => pointcut instanceof PropertyGettingPointcut, \"get\"], [() => pointcut instanceof PropertySettingPointcut, \"set\"], [() => {\n      const isImplicit = isImplicitBeforeAdvice() && rule.property === applyRule;\n\n      if (isImplicit || pointcut instanceof FunctionCallPointcut) {\n        if (isImplicit) {\n          pointcut = apply().before(pointcut);\n        }\n\n        return true;\n      }\n\n      return false;\n    }, \"apply\"], [() => {\n      const isImplicit = isImplicitBeforeAdvice() && rule.property === constructRule;\n\n      if (isImplicit || pointcut instanceof ObjectConstructionPointcut) {\n        if (isImplicit) {\n          pointcut = construct().before(pointcut);\n        }\n\n        return true;\n      }\n\n      return false;\n    }, \"construct\"]]);\n\n    if (pointcutType) {\n      const {\n        advices\n      } = pointcut;\n      this.addAdvices(pointcutType, rule, advices);\n    }\n\n    return this;\n  }\n\n  hasGets() {\n    return this.hasAtLeastOneAdviceOfPointcutType(\"call\") || this.hasAtLeastOneAdviceOfPointcutType(\"get\");\n  }\n\n  hasSets() {\n    return this.hasAtLeastOneAdviceOfPointcutType(\"set\");\n  }\n\n  hasApplies() {\n    return this.hasAtLeastOneAdviceOfPointcutType(\"apply\");\n  }\n\n  hasConstructs() {\n    return this.hasAtLeastOneAdviceOfPointcutType(\"construct\");\n  }\n\n  get(target, property, receiver) {\n    // Method call and property access (getting) advices.\n    this.lazilyMatchAdvices(\"get\", property);\n    this.lazilyMatchAdvices(\"call\", property);\n    const {\n      before: getBefore,\n      around: getAround,\n      after: getAfter\n    } = this.matchedDistributedAdvices.get.get(property);\n    const propertyValue = this.trapExecutors.get.execute([target, property, receiver], getBefore, getAround, getAfter);\n    const {\n      before: callBefore,\n      around: callAround,\n      after: callAfter\n    } = this.matchedDistributedAdvices.call.get(property);\n    const returnValue = this.trapExecutors.call.execute([target, property, receiver, propertyValue], callBefore, callAround, callAfter);\n    return returnValue;\n  }\n\n  set(target, property, value, receiver) {\n    // Property access (setting) advices.\n    this.lazilyMatchAdvices(\"set\", property);\n    const {\n      before,\n      around,\n      after\n    } = this.matchedDistributedAdvices.set.get(property);\n    return this.trapExecutors.set.execute([target, property, value, receiver], before, around, after);\n  }\n\n  apply(target, thisArg, argumentsList) {\n    // Function call advices.\n    this.lazilyDistributeAdvices(\"apply\");\n    const {\n      before,\n      around,\n      after\n    } = this.distributedAdvices.apply;\n    return this.trapExecutors.apply.execute([target, thisArg, argumentsList], before, around, after);\n  }\n\n  construct(target, argumentsList, newTarget) {\n    // Object construction via the \"new\" keyword advices.\n    this.lazilyDistributeAdvices(\"construct\");\n    const {\n      before,\n      around,\n      after\n    } = this.distributedAdvices.construct;\n    return this.trapExecutors.construct.execute([target, argumentsList, newTarget], before, around, after);\n  }\n\n}\n//# sourceMappingURL=Trap.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport TrapExecutor from \"./TrapExecutor\";\nimport reflectApply from \"../reflect/reflectApply\";\nimport { withFunctionTrapExecutor } from \"./behaviours/withFunctionTrapExecutor\";\nexport default withFunctionTrapExecutor(class ApplyTrapExecutor extends TrapExecutor {\n  getTrapArgsArgumentsListIndex() {\n    return 2;\n  }\n\n  executeBeforeAdvice([target, thisArg, argumentsList], advice, rule) {\n    const context = {\n      target,\n      thisArg,\n      rule\n    };\n    advice.fn.apply(context, argumentsList);\n  }\n\n  executeAroundAdvice([target, thisArg, argumentsList], advice, rule, proceed) {\n    const context = {\n      target,\n      thisArg,\n      rule\n    };\n    return advice.fn.call(context, proceed).apply(context, argumentsList);\n  }\n\n  executeAfterAdvice([target, thisArg, argumentsList], advice, rule, returnValue) {\n    const context = {\n      target,\n      thisArg,\n      rule\n    };\n    advice.fn.call(context, ...argumentsList).apply(context, [returnValue]);\n  }\n\n  performUnderlyingOperation([target, thisArg, argumentsList]) {\n    const returnValue = reflectApply(target, thisArg, argumentsList);\n    return returnValue;\n  }\n\n  executeProceedCallback([target, thisArg, argumentsList], rule, returnValue, callback) {\n    const context = {\n      target,\n      thisArg,\n      rule,\n      argumentsList\n    };\n    return callback.apply(context, [returnValue]);\n  }\n\n});\n//# sourceMappingURL=ApplyTrapExecutor.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport TrapExecutor from \"./TrapExecutor\";\nimport { withFunctionTrapExecutor } from \"./behaviours/withFunctionTrapExecutor\";\nimport { isEmpty } from \"js-utl\";\nexport default withFunctionTrapExecutor(class CallTrapExecutor extends TrapExecutor {\n  getTrapArgsArgumentsListIndex() {\n    return 4;\n  }\n\n  execute([target, property, receiver, propertyValue], before, around, after) {\n    if (typeof propertyValue === \"function\" && [before, around, after].some(advices => !isEmpty(advices))) {\n      const superExecute = trapArgs => {\n        return super.execute(trapArgs, before, around, after);\n      };\n\n      const wrapperFn = function (...args) {\n        let boundThis;\n\n        if (this !== receiver) {\n          boundThis = this;\n        } else {\n          boundThis = target;\n        }\n\n        propertyValue = propertyValue.bind(boundThis);\n        const trapArgs = [target, property, receiver, propertyValue, args];\n        return superExecute(trapArgs);\n      };\n\n      return wrapperFn;\n    }\n\n    return propertyValue;\n  }\n\n  executeBeforeAdvice([target, property, receiver,, argumentsList], advice, rule) {\n    const context = {\n      target,\n      property,\n      receiver,\n      rule\n    };\n    advice.fn.apply(context, argumentsList);\n  }\n\n  executeAroundAdvice([target, property, receiver,, argumentsList], advice, rule, proceed) {\n    const context = {\n      target,\n      property,\n      receiver,\n      rule\n    };\n    return advice.fn.call(context, proceed).apply(context, argumentsList);\n  }\n\n  executeAfterAdvice([target, property, receiver,, argumentsList], advice, rule, returnValue) {\n    const context = {\n      target,\n      property,\n      receiver,\n      rule\n    };\n    advice.fn.call(context, ...argumentsList).apply(context, [returnValue]);\n  }\n\n  performUnderlyingOperation([,,, originalFn, argumentsList]) {\n    const returnValue = originalFn(...argumentsList);\n    return returnValue;\n  }\n\n  executeProceedCallback([target, property, receiver,, argumentsList], rule, returnValue, callback) {\n    const context = {\n      target,\n      property,\n      receiver,\n      rule,\n      argumentsList\n    };\n    return callback.apply(context, [returnValue]);\n  }\n\n});\n//# sourceMappingURL=CallTrapExecutor.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport TrapExecutor from \"./TrapExecutor\";\nimport reflectConstruct from \"../reflect/reflectConstruct\";\nimport { withFunctionTrapExecutor } from \"./behaviours/withFunctionTrapExecutor\";\nexport default withFunctionTrapExecutor(class ConstructTrapExecutor extends TrapExecutor {\n  getTrapArgsArgumentsListIndex() {\n    return 1;\n  }\n\n  executeBeforeAdvice([target, argumentsList, newTarget], advice, rule) {\n    const context = {\n      target,\n      newTarget,\n      rule\n    };\n    advice.fn.apply(context, argumentsList);\n  }\n\n  executeAroundAdvice([target, argumentsList, newTarget], advice, rule, proceed) {\n    const context = {\n      target,\n      newTarget,\n      rule\n    };\n    return advice.fn.call(context, proceed).apply(context, argumentsList);\n  }\n\n  executeAfterAdvice([target, argumentsList, newTarget], advice, rule, instance) {\n    const context = {\n      target,\n      newTarget,\n      rule\n    };\n    advice.fn.call(context, ...argumentsList).apply(context, [instance]);\n  }\n\n  performUnderlyingOperation([target, argumentsList, newTarget]) {\n    const instance = reflectConstruct(target, argumentsList, newTarget);\n    return instance;\n  }\n\n  executeProceedCallback([target, argumentsList, newTarget], rule, instance, callback) {\n    const context = {\n      target,\n      newTarget,\n      rule,\n      argumentsList\n    };\n    return callback.apply(context, [instance]);\n  }\n\n});\n//# sourceMappingURL=ConstructTrapExecutor.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport TrapExecutor from \"./TrapExecutor\";\nimport reflectGet from \"../reflect/reflectGet\";\nexport default class GetTrapExecutor extends TrapExecutor {\n  executeBeforeAdvice([target, property, receiver], advice, rule) {\n    const context = {\n      target,\n      property,\n      receiver,\n      rule\n    };\n    advice.fn.apply(context);\n  }\n\n  executeAroundAdvice([target, property, receiver], advice, rule, proceed) {\n    const context = {\n      target,\n      property,\n      receiver,\n      rule\n    };\n    return advice.fn.apply(context, [proceed]);\n  }\n\n  executeAfterAdvice([target, property, receiver], advice, rule, propertyValue) {\n    const context = {\n      target,\n      property,\n      receiver,\n      rule\n    };\n    advice.fn.apply(context, [propertyValue]);\n  }\n\n  performUnderlyingOperation([target, property, receiver]) {\n    const propertyValue = reflectGet(target, property, receiver);\n    return propertyValue;\n  }\n\n  executeProceedCallback([target, property, receiver], rule, propertyValue, callback) {\n    const context = {\n      target,\n      property,\n      receiver,\n      rule\n    };\n    return callback.apply(context, [propertyValue]);\n  }\n\n}\n//# sourceMappingURL=GetTrapExecutor.js.map","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport TrapExecutor from \"./TrapExecutor\";\nimport reflectSet from \"../reflect/reflectSet\";\nimport reflectGet from \"../reflect/reflectGet\";\nexport default class SetTrapExecutor extends TrapExecutor {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"previousPropertyValueMap\", {});\n\n    _defineProperty(this, \"returnNewPropertyValueMap\", {});\n\n    _defineProperty(this, \"updateWasSuccessfulMap\", {});\n  }\n\n  startExecutionContext([target, property,, receiver]) {\n    if (!Object.prototype.hasOwnProperty.call(this.previousPropertyValueMap, this.execContextID)) {\n      const previousPropertyValue = reflectGet(target, property, receiver);\n      this.previousPropertyValueMap[this.execContextID] = previousPropertyValue;\n      this.returnNewPropertyValueMap[this.execContextID] = void 0;\n      this.updateWasSuccessfulMap[this.execContextID] = false;\n    }\n  }\n\n  endExecutionContext([,,,]) {\n    delete this.previousPropertyValueMap[this.execContextID];\n    delete this.returnNewPropertyValueMap[this.execContextID];\n    delete this.updateWasSuccessfulMap[this.execContextID];\n  }\n\n  executeBeforeAdvice([target, property, value, receiver], advice, rule) {\n    const previousPropertyValue = this.previousPropertyValueMap[this.execContextID];\n    const context = {\n      target,\n      property,\n      value,\n      receiver,\n      rule\n    };\n    advice.fn.apply(context, [previousPropertyValue]);\n  }\n\n  executeAroundAdvice([target, property, value, receiver], advice, rule, proceed) {\n    const previousPropertyValue = this.previousPropertyValueMap[this.execContextID];\n    const context = {\n      target,\n      property,\n      value,\n      receiver,\n      rule\n    };\n    return advice.fn.call(context, proceed).apply(context, [previousPropertyValue]);\n  }\n\n  executeAfterAdvice([target, property, value, receiver], advice, rule, updateWasSuccessful) {\n    const previousPropertyValue = this.previousPropertyValueMap[this.execContextID];\n    const newPropertyValue = this.returnNewPropertyValueMap[this.execContextID];\n    const context = {\n      target,\n      property,\n      value,\n      receiver,\n      rule,\n      updateWasSuccessful\n    };\n    advice.fn.call(context, previousPropertyValue).apply(context, [newPropertyValue]);\n  }\n\n  performUnderlyingOperation([target, property, value, receiver]) {\n    const updateWasSuccessful = reflectSet(target, property, value, receiver);\n    this.updateWasSuccessfulMap[this.execContextID] = updateWasSuccessful;\n    this.returnNewPropertyValueMap[this.execContextID] = value;\n    return value;\n  }\n\n  executeProceedCallback([target, property, value, receiver], rule, newPropertyValue, callback) {\n    const context = {\n      target,\n      property,\n      value,\n      receiver,\n      rule\n    };\n    const returnValue = callback.apply(context, [newPropertyValue]);\n    return returnValue;\n  }\n\n  return([target, property,, receiver], returnValue) {\n    if (returnValue !== this.returnNewPropertyValueMap[this.execContextID]) {\n      this.performUnderlyingOperation([target, property, returnValue, receiver]);\n    }\n\n    return this.updateWasSuccessfulMap[this.execContextID];\n  }\n\n}\n//# sourceMappingURL=SetTrapExecutor.js.map","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport { isArray } from \"js-utl\";\n/**\n * @type {Symbol}\n */\n\nconst noReturnValue = Symbol(\"noReturnValue\");\nexport default class TrapExecutor {\n  constructor() {\n    _defineProperty(this, \"execContextStack\", []);\n\n    _defineProperty(this, \"execContextID\", -1);\n  }\n\n  execute(trapArgs, before, around, after) {\n    this.newExecutionContext();\n    this.setUpExecutionContext(before, around);\n    this.startExecutionContext(trapArgs);\n    this.beforePhase(trapArgs, before);\n    this.aroundPhase(trapArgs, around);\n    const returnValue = this.proceedPhase(trapArgs);\n    this.afterPhase(trapArgs, after, returnValue);\n    this.endExecutionContext(trapArgs);\n    this.cleanUpExecutionContext();\n    return returnValue;\n  }\n  /**\n   * @private\n   */\n\n\n  newExecutionContext() {\n    const context = {\n      proceeds: [],\n      hasAtLeastOneAroundAdvice: false,\n      hasAtLeastOneBeforeAdvice: false,\n      returnValue: noReturnValue\n    };\n    this.execContextStack.push(context);\n    this.execContextID++;\n  }\n  /**\n   * @private\n   */\n\n\n  setUpExecutionContext(before, around) {\n    this.execContextStack[this.execContextID].hasAtLeastOneBeforeAdvice = !!before.length;\n    this.execContextStack[this.execContextID].hasAtLeastOneAroundAdvice = !!around.length;\n  }\n  /* eslint-disable no-unused-vars, @typescript-eslint/no-empty-function */\n\n\n  startExecutionContext(trapArgs) {}\n  /* eslint-enable no-unused-vars, @typescript-eslint/no-empty-function */\n\n  /* eslint-disable no-unused-vars, @typescript-eslint/no-empty-function */\n\n\n  endExecutionContext(trapArgs) {}\n  /* eslint-enable no-unused-vars, @typescript-eslint/no-empty-function */\n\n  /**\n   * @private\n   */\n\n\n  cleanUpExecutionContext() {\n    this.execContextStack.pop();\n    this.execContextID--;\n  }\n  /**\n   * @private\n   */\n\n\n  unsupportedMultipleProceeds(advice, rule) {\n    // eslint-disable-next-line no-console\n    console.error(\"pigretto - Multiple proceeds for the same advice are not supported, subsequent proceed has been ignored.\", \"\\n\\tadvice: \", advice, \"\\n\\trule: \", rule);\n  } // eslint-disable-next-line no-unused-vars\n\n\n  executeBeforeAdvice(trapArgs, advice, rule) {\n    throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement \"executeBeforeAdvice\".`);\n  } // eslint-disable-next-line no-unused-vars\n\n\n  executeAroundAdvice(trapArgs, advice, rule, proceed) {\n    throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement \"executeAroundAdvice\".`);\n  } // eslint-disable-next-line no-unused-vars\n\n\n  executeAfterAdvice(trapArgs, advice, rule, returnValue) {\n    throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement \"executeAfterAdvice\".`);\n  } // eslint-disable-next-line no-unused-vars\n\n\n  performUnderlyingOperation(trapArgs) {\n    throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement \"performUnderlyingOperation\".`);\n  } // eslint-disable-next-line no-unused-vars\n\n\n  executeProceedCallback(trapArgs, rule, returnValue, callback) {\n    throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement \"executeProceedCallback\".`);\n  }\n  /**\n   * @private\n   */\n\n\n  beforePhase(trapArgs, before) {\n    for (const {\n      rule,\n      advice\n    } of before) {\n      this.executeBefore(trapArgs, advice, rule);\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  executeBefore(trapArgs, advice, rule) {\n    this.executeBeforeAdvice(trapArgs, advice, rule);\n  }\n  /**\n   * @private\n   */\n\n\n  aroundPhase(trapArgs, around) {\n    for (const {\n      rule,\n      advice\n    } of around) {\n      this.executeAround(trapArgs, advice, rule);\n\n      if (this.execContextStack[this.execContextID].returnValue !== noReturnValue) {\n        break;\n      }\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  executeAround(trapArgs, advice, rule) {\n    let hasProceeded = false;\n\n    const proceed = (params = void 0, fn = void 0) => {\n      if (hasProceeded) {\n        this.unsupportedMultipleProceeds(advice, rule);\n        return;\n      }\n\n      hasProceeded = true;\n      let finalParams = void 0;\n      let finalFn = void 0;\n\n      if (isArray(params)) {\n        finalParams = params;\n        finalFn = typeof fn === \"function\" ? fn : void 0;\n      } else if (typeof params === \"function\") {\n        finalFn = params;\n      }\n\n      this.execContextStack[this.execContextID].proceeds.push({\n        params: finalParams,\n        fn: finalFn,\n        rule\n      });\n    };\n\n    const returnValue = this.executeAroundAdvice(trapArgs, advice, rule, proceed);\n\n    if (!hasProceeded) {\n      this.execContextStack[this.execContextID].returnValue = returnValue;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  afterPhase(trapArgs, after, returnValue) {\n    for (const {\n      rule,\n      advice\n    } of after) {\n      this.executeAfter(trapArgs, advice, rule, returnValue);\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  executeAfter(trapArgs, advice, rule, returnValue) {\n    this.executeAfterAdvice(trapArgs, advice, rule, returnValue);\n  }\n  /**\n   * @private\n   */\n\n\n  proceedPhase(trapArgs) {\n    if (this.execContextStack[this.execContextID].returnValue !== noReturnValue) {\n      return this.return(trapArgs, this.execContextStack[this.execContextID].returnValue);\n    }\n\n    let returnValue = this.performUnderlyingOperation(trapArgs);\n\n    for (const {\n      fn: callback,\n      rule\n    } of this.execContextStack[this.execContextID].proceeds) {\n      if (typeof callback === \"function\") {\n        returnValue = this.executeProceedCallback(trapArgs, rule, returnValue, callback);\n      }\n    }\n\n    return this.return(trapArgs, returnValue);\n  }\n\n  return(trapArgs, returnValue) {\n    return returnValue;\n  }\n\n}\n//# sourceMappingURL=TrapExecutor.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nexport const throwErrorIfDoesNotImplement = (context, methodName, constructorFn) => {\n  if (typeof context[methodName] !== \"function\") {\n    throw new Error(`pigretto - ${constructorFn.name} trap executor does not implement \"${methodName}\".`);\n  }\n};\n//# sourceMappingURL=throwErrorIfDoesNotImplement.js.map","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport { isArray, isUndefined } from \"js-utl\";\nimport { throwErrorIfDoesNotImplement } from \"./common/throwErrorIfDoesNotImplement\";\nexport const withFunctionTrapExecutor = superclass => {\n  var _temp;\n\n  const NewClass = (_temp = class NewClass extends superclass {\n    constructor(...args) {\n      super(...args);\n\n      _defineProperty(this, \"executedAtLeastOnce\", false);\n\n      _defineProperty(this, \"lastProceedWithParamsIndexMap\", {});\n\n      _defineProperty(this, \"finalTrapArgsMap\", {});\n    }\n\n    startExecutionContext(trapArgs) {\n      !this.executedAtLeastOnce && throwErrorIfDoesNotImplement(superclass.prototype, \"startExecutionContext\", superclass);\n      super.startExecutionContext(trapArgs);\n\n      if (!this.executedAtLeastOnce && !Object.prototype.hasOwnProperty.call(this, \"execContextID\")) {\n        throw new Error(`pigretto - ${superclass.name} trap executor does not have \"execContextID\" property.`);\n      }\n\n      this.lastProceedWithParamsIndexMap[this.execContextID] = -1;\n      this.finalTrapArgsMap[this.execContextID] = void 0;\n    }\n\n    endExecutionContext(trapArgs) {\n      !this.executedAtLeastOnce && throwErrorIfDoesNotImplement(superclass.prototype, \"endExecutionContext\", superclass);\n      super.endExecutionContext(trapArgs);\n      this.finalTrapArgsMap[this.execContextID] = void 0;\n      this.executedAtLeastOnce = true;\n    }\n\n    getFinalTrapArgs(trapArgs) {\n      !this.executedAtLeastOnce && throwErrorIfDoesNotImplement(this, \"getTrapArgsArgumentsListIndex\", superclass);\n      const argumentsListIndex = this.getTrapArgsArgumentsListIndex();\n\n      if (!this.executedAtLeastOnce && !Object.prototype.hasOwnProperty.call(this, \"execContextStack\")) {\n        throw new Error(`pigretto - ${superclass.name} trap executor does not have \"execContextStack\" property.`);\n      }\n\n      const proceedsL = this.execContextStack[this.execContextID].proceeds.length;\n\n      if (proceedsL) {\n        let hasParamsOverride = false;\n\n        for (let i = proceedsL - 1; i > this.lastProceedWithParamsIndexMap[this.execContextID]; i--) {\n          const {\n            params\n          } = this.execContextStack[this.execContextID].proceeds[i];\n\n          if (isArray(params)) {\n            hasParamsOverride = true;\n            this.lastProceedWithParamsIndexMap[this.execContextID] = i;\n            trapArgs = [...trapArgs];\n            trapArgs[argumentsListIndex] = params;\n            this.finalTrapArgsMap[this.execContextID] = trapArgs;\n            break;\n          }\n        }\n\n        if (!hasParamsOverride) {\n          this.lastProceedWithParamsIndexMap[this.execContextID] = proceedsL - 1;\n        }\n      }\n\n      if (!isUndefined(this.finalTrapArgsMap[this.execContextID])) {\n        return this.finalTrapArgsMap[this.execContextID];\n      }\n\n      return trapArgs;\n    }\n\n    executeAroundAdvice(trapArgs, advice, rule, proceed) {\n      trapArgs = this.getFinalTrapArgs(trapArgs);\n      !this.executedAtLeastOnce && throwErrorIfDoesNotImplement(superclass.prototype, \"executeAroundAdvice\", superclass);\n      return super.executeAroundAdvice(trapArgs, advice, rule, proceed);\n    }\n\n    executeAfterAdvice(trapArgs, advice, rule, returnValue) {\n      trapArgs = this.getFinalTrapArgs(trapArgs);\n      !this.executedAtLeastOnce && throwErrorIfDoesNotImplement(superclass.prototype, \"executeAfterAdvice\", superclass);\n      super.executeAfterAdvice(trapArgs, advice, rule, returnValue);\n    }\n\n    performUnderlyingOperation(trapArgs) {\n      trapArgs = this.getFinalTrapArgs(trapArgs);\n      !this.executedAtLeastOnce && throwErrorIfDoesNotImplement(superclass.prototype, \"performUnderlyingOperation\", superclass);\n      return super.performUnderlyingOperation(trapArgs);\n    }\n\n    executeProceedCallback(trapArgs, rule, returnValue, callback) {\n      trapArgs = this.getFinalTrapArgs(trapArgs);\n      !this.executedAtLeastOnce && throwErrorIfDoesNotImplement(superclass.prototype, \"executeProceedCallback\", superclass);\n      return super.executeProceedCallback(trapArgs, rule, returnValue, callback);\n    }\n\n  }, _temp);\n  Object.defineProperty(NewClass, \"name\", {\n    value: `WithFunctionTrapExecutor(${superclass.name})`,\n    configurable: true\n  });\n  return NewClass;\n};\n//# sourceMappingURL=withFunctionTrapExecutor.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nexport default function reflectApply(target, thisArg, argumentsList) {\n  return Reflect.apply(target, thisArg, argumentsList);\n}\n//# sourceMappingURL=reflectApply.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nexport default function reflectConstruct(target, argumentsList, newTarget) {\n  return newTarget ? Reflect.construct(target, argumentsList, newTarget) : new target(...argumentsList);\n}\n//# sourceMappingURL=reflectConstruct.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nexport default function reflectGet(target, property, receiver) {\n  return Reflect.get(target, property, receiver);\n}\n//# sourceMappingURL=reflectGet.js.map","/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nexport default function reflectSet(target, property, value, receiver) {\n  return Reflect.set(target, property, value, receiver);\n}\n//# sourceMappingURL=reflectSet.js.map","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nimport rulesGenerator from \"../rules/rulesGenerator\";\nimport parseRule from \"../rules/parser/parseRule\";\nimport Trap from \"./Trap\";\n/**\n * Generates a new trap handler object for the given rules.\n *\n * @param {Object|Array} proxyRules The proxy rules.\n * @return {Object} The new trap handler object for the given rules.\n */\n\nexport default function trapHandlerForRules(proxyRules) {\n  const trap = new Trap();\n  const rules = rulesGenerator(proxyRules);\n\n  for (const {\n    rule,\n    pointcut\n  } of rules) {\n    const parsedRule = parseRule(rule);\n    trap.addPointcutRule(pointcut, parsedRule);\n  }\n\n  return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, trap.hasGets() ? {\n    // Trap for property access (getting) and method call.\n    get(target, property, receiver) {\n      return trap.get(target, property, receiver);\n    }\n\n  } : {}), trap.hasSets() ? {\n    // Trap for property access (setting).\n    set(target, property, value, receiver) {\n      const updateWasSuccessful = trap.set(target, property, value, receiver);\n      return updateWasSuccessful;\n    }\n\n  } : {}), trap.hasApplies() ? {\n    // Trap for function call.\n    apply(target, thisArg, argumentsList) {\n      return trap.apply(target, thisArg, argumentsList);\n    }\n\n  } : {}), trap.hasConstructs() ? {\n    // Trap for object construction with the \"new\" operator.\n    construct(target, argumentsList, newTarget) {\n      return trap.construct(target, argumentsList, newTarget);\n    }\n\n  } : {});\n}\n//# sourceMappingURL=trapHandlerForRules.js.map","'use strict';\n\nconst matchOperatorsRegex = /[|\\\\{}()[\\]^$+*?.-]/g;\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn string.replace(matchOperatorsRegex, '\\\\$&');\n};\n","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/*!\n * =========================\n * ImmutableLinkedOrderedMap\n * =========================\n *\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * @author Anton Bagdatyev (Tonix) <antonytuft@gmail.com>\n */\n\n/* ======================================================================================================== */\n\nimport { lazyObject } from \"pigretto\";\nimport { DEFAULT_KEY_PROP_NAME } from \"./constants\";\nimport { lazyMapFactory } from \"./shortcuts/lazyMapFactory\";\n\n/**\n * @type {string}\n */\nconst MAP_TAG = \"ImmutableLinkedOrderedMapEWoFkvQyQsM32wK4a5Kd\";\n\n/**\n * @type {string}\n */\nconst MAP_TAG_VALUE = true;\n\n/**\n * @type {string}\n */\nconst MULTIWAY_MODE_INITIAL_MAP_TREE_DEPTH_VERSION = \"\";\n\n/**\n * @type {string}\n */\nconst MULTIWAY_MODE_MAP_TREE_DEPTH_VERSION_SEPARATOR = \"#\";\n\n/**\n * @type {Object}\n */\nconst ImmutableLinkedOrderedMapMode = {\n  SINGLE: 1,\n  MULTIWAY: 2,\n  LIGHTWEIGHT: 3,\n};\n\n/**\n * @type {number}\n */\nconst DEFAULT_MAP_MODE = ImmutableLinkedOrderedMapMode.MULTIWAY;\n\n/* ======================================================================================================== */\n\n/**\n * Factory method to create a new immutable linked ordered map.\n *\n * @param {Array} [initialItems] Initial array of items to add to the map (defaults to an empty array).\n *                               Each item of the map MUST be an object with the following shape:\n *\n *                                   {\n *                                       [keyPropName]: keyPropValue,\n *                                       property: propertyValue,\n *                                       otherProperty: otherPropertyValue,\n *                                       ...\n *                                   }\n *\n *                               Where \"[keyPropName]\" is the name of the key property of the item.\n *                               In this case the map will map the value \"keyPropValue\" (the key)\n *                               to the whole item, which will be treated as the value of the map value, e.g.:\n *\n *                                   const map = new ImmutableLinkedOrderedMap({\n *                                       initialItems: [\n *                                           {\n *                                              id: 1, // <--- \"[keyPropName] === 'id'\"\n *                                              property: \"A value\",\n *                                              // ...\n *                                           },\n *                                           {\n *                                              id: 2,\n *                                              property: \"Another value\",\n *                                              // ...\n *                                           },\n *                                           // ...\n *                                       ]\n *                                   })\n *                                   map.get(2) // Will return: { id: 2, property: \"Another value\" }\n *\n *                               Or an object with a single property with the following shape (useful for primitives):\n *\n *                                   {\n *                                       key: value\n *                                   }\n *\n *                               In this case the map will map the key \"key\" to the value \"value\", and \"value\"\n *                               will be treated as the value of the map for the key \"key\", e.g.:\n *\n *                                   const map = new ImmutableLinkedOrderedMap({\n *                                       initialItems: [\n *                                           {\n *                                              key1: \"abc\"\n *                                           },\n *                                           {\n *                                              key2: \"def\"\n *                                           },\n *                                           // ...\n *                                       ]\n *                                   })\n *                                   map.get(\"key1\") // Will return: \"abc\"\n *\n *                               Both items' shapes may coexist in the same map if client code is mixing pears with apples.\n *\n *                               Note that if an object with a single property which name is \"[keyPropName]\" is given,\n *                               then the whole object will be mapped and treated as the map's value, e.g. when \"keyPropName === 'id'\":\n *\n *                                   const map = new ImmutableLinkedOrderedMap({\n *                                       initialItems: [\n *                                           {\n *                                              id: 123\n *                                           },\n *                                           {\n *                                              id: 456\n *                                           },\n *                                           ...\n *                                       ]\n *                                   })\n *                                   map.get(123) // Will return: { id: 123 }\n *\n *                               The same item format is used for all mutation operations where an item or items may be given as parameters,\n *                               e.g. for \"set\", \"replace\", etc... .\n *\n * @param {string} [keyPropName] The name of the key property of an item which value should be used for the key of the map (defaults to \"id\").\n * @param {number} mode The mode of the map (a value of the enum-like object \"ImmutableLinkedOrderedMapMode\").\n *                      When the map is single mode (\"ImmutableLinkedOrderedMapMode.SINGLE\"), it will only allow a single mutation operation\n *                      per linked ordered immutable map instance.\n *                      This mode allows faster lookups as the version tree of the map will consist of only\n *                      one branch and should cover almost all practical use cases.\n *                      E.g.:\n *\n *                          const map = new ImmutableLinkedOrderedMap({\n *                              mode: ImmutableLinkedOrderedMapMode.SINGLE\n *                          })\n *                          const item = { id: 1, value: \"A value\" }\n *                          const newMap = map.set(item)\n *                          //const anotherNewMapFromMap = map.set({ id: 2, value: \"Another value\" }) // This line, if uncommented, will throw an error in single mode, as a mutation operation already occurred on \"map\"!\n *                          const anotherNewMapFromNewMap = newMap.set({ id: 2, value: \"Another value\" }) // This will work, as a mutation operation did not occur yet on \"newMap\".\n *                          const yetAnotherMap = newMap.set(item) // This works, because \"newMap === yetAnotherMap\" as the given item is the same and already existed in \"newMap\".\n *                          //const thisMapWouldNotWork = newMap.set({ id: 3, value: \"Yet another value\" }) // This will throw an error in single mode as for \"anotherNewMapFromMap\".\n *                          // ...\n *\n *                      The version tree of this map in single mode will look like the following:\n *\n *                          map (Initial version)\n *                             \\\n *                             newMap/yetAnotherMap (Second version, remember, in this case \"newMap === yetAnotherMap\")\n *                                \\\n *                                anotherNewMapFromNewMap (Third version)\n *\n *                      The other available mode is multiway mode (\"ImmutableLinkedOrderedMapMode.MULTIWAY\").\n *                      This is the default mode.\n *                      In this mode, multiple mutation operations can occur on the same map, each leading to a different\n *                      branch.\n *                      Lookups may be slower, particularly if a lot of mutation operations have happened,\n *                      as the structural sharing code will need to determine the right branch of the version tree\n *                      given a map which tries to lookup its data for a given key.\n *                      E.g.:\n *\n *                          const map = new ImmutableLinkedOrderedMap() // \"ImmutableLinkedOrderedMapMode.MULTIWAY\" is the default mode.\n *                          const newMap = map.set({ id: 1, value: \"A value\" })\n *                          const anotherNewMapFromMap = map.set({ id: 2, value: \"Another value\" }) // This will work in multiway mode, but not in single mode.\n *                          const anotherNewMapFromNewMap = newMap.set({ id: 2, value: \"Another value\" })\n *                          // ...\n *\n *                      The version tree of this map in multiway mode will look like the following:\n *\n *                                                                             map (Initial version, root node)\n *                                                                            /   \\\n *                                                                           /     newMap (Second version, first branch)\n *                                                                          /        \\\n *                          (Third version, second branch) anotherNewMapFromMap       \\\n *                                                                                    anotherNewMapFromNewMap (Fourth version, first branch)\n *\n *                      This mode should be used only if client code needs to perform several mutation operations on the same map instance over time.\n *                      Also, a single mode map cannot become a multiway and viceversa.\n *\n *                      The last available mode is lightweight mode (\"ImmutableLinkedOrderedMapMode.LIGHTWEIGHT\").\n *                      This mode is the most restrictive and does not allow to perform any operation on a map on which a mutation operation\n *                      has occurred (basically once a mutation operation occurs on a map, it becomes useless and only the new map\n *                      could be used further).\n *                      The advantage is that a map in this mode will have the fastest lookups, as in this mode there isn't any version tree.\n *                      E.g.:\n *\n *                          const map = new ImmutableLinkedOrderedMap({\n *                              mode: ImmutableLinkedOrderedMapMode.LIGHTWEIGHT\n *                          })\n *                          const item = { id: 1, value: \"A value\" }\n *                          const newMap = map.set(item)\n *                          //const anotherNewMapFromMap = map.set({ id: 2, value: \"Another value\" }) // This line, if uncommented, will throw an error in lightweight mode, as with single mode.\n *                          //const value = map.get(1) // In lightweight mode, even this line will throw an error, as after a mutation operation occurs on a map, it will become useless.\n *                          const valueOfNewMap = newMap.get(1) // This works.\n *                          const anotherNewMapFromNewMap = newMap.unset(1) // This will also work, and from this point on, \"newMap\" will become useless and a further operation will have to be performed on \"anotherNewMapFromNewMap\"\n *                          // ...\n *\n *                      Note that the mentioned version tree is only an abstraction, a conceptual idea behind the structural sharing code of the map.\n *                      Internally, the structural sharing code does not create any tree.\n *                      For multiway mode, though, the structural sharing code keeps track of the version of the map in a string\n *                      which is then used to determine if a map is a descendant of another one during lookup operations.\n * @return {ImmutableLinkedOrderedMap} The new immutable linked ordered map.\n */\nfunction newImmutableLinkedOrderedMap({\n  initialItems = [],\n  keyPropName = DEFAULT_KEY_PROP_NAME,\n  mode = DEFAULT_MAP_MODE,\n  lazy = false,\n} = {}) {\n  mode =\n    (ImmutableLinkedOrderedMapForMode[mode] && mode) ||\n    (mode = DEFAULT_MAP_MODE);\n  let map = newMapFromMode(mode);\n  hydrateNew.call(map, { keyPropName, mode });\n  if (lazy) {\n    map = newLazyMap(map, initialItems);\n  } else {\n    appendInitialItemsToMap(map, initialItems);\n  }\n  return map;\n}\n\n/* ======================================================================================================== */\n\n/**\n * Creates a new map given the mode.\n *\n * @param {number} mode The mode of the map (a property value of the enum-like object \"ImmutableLinkedOrderedMapMode\").\n * @return {ImmutableLinkedOrderedMap} A new immutable linked ordered map.\n */\nfunction newMapFromMode(mode) {\n  const ImmutableLinkedOrderedMapClass =\n    ImmutableLinkedOrderedMapForMode[mode].ImmutableLinkedOrderedMapClass;\n  return new ImmutableLinkedOrderedMapClass();\n}\n\n/* ======================================================================================================== */\n\n/**\n * Defines a getter and optional setter on an object's property.\n *\n * @param {Object} obj An object (may be a prototype).\n * @param {string} propname The property name.\n * @param {Function} getfn Getter function.\n * @param {Function} setfn Setter function.\n * @return {undefined}\n */\nfunction prop(obj, propname, getfn, setfn) {\n  const propObj = {};\n  propObj[propname] = {\n    get: getfn,\n    set: setfn,\n  };\n  Object.defineProperties(obj, propObj);\n}\n\n/**\n * Makes a new node (used internally).\n *\n * @param {Object} previous Previous node.\n * @param {Object} next Next node.\n * @param {*} element The element of the node.\n * @return {Object} The node.\n */\nfunction makeNode(previous, next, element) {\n  return {\n    previous,\n    next,\n    element,\n  };\n}\n\n/* ======================================================================================================== */\n\n/**\n * Hydrates a new map when the client code creates it.\n *\n * @param {string} keyPropName Name of the property to use for the keys of the map.\n * @param {number} mode The mode of the map (a property value of the enum-like object \"ImmutableLinkedOrderedMapMode\").\n * @return {undefined}\n */\nfunction hydrateNew({ keyPropName, mode }) {\n  /**\n   * Each new map created from client code has a reference to a shared data structure called heap map.\n   *\n   * Beside the fancy name, it basically stores all the nodes holding the values of the map\n   * linked together in order to maintain insertion order and maps all the keys which were ever added\n   * to all the maps forked from the original one.\n   *\n   * The heap map maps keys to depths. Each time a new map is forked from a previous one,\n   * the depth of the new forked map increases.\n   *\n   * For single mode each depth in turn maps directly to the node representing the value\n   * of that key for that particular map. This allows quick lookups.\n   *\n   * For multiway mode each depth additionally maps to a stack which associates map versions for that depth\n   * in the order they have been added to the version tree for that depth.\n   * It may sound complicated, but basically each version represents a mutation on a map at any given time.\n   * Lookups are slower because in this case when calling \"map.get('key')\", the structural sharing code must\n   * determine if the given version in the stack of the heap map for that key and depth is an ancestor\n   * of the version of the map on which \"get\" is called.\n   */\n  const heapMap = {};\n  hydrate.call(this, {\n    heapMap,\n    depth: 0,\n    length: 0,\n    keyPropName,\n    mode,\n  });\n\n  const hydrateMode = ImmutableLinkedOrderedMapForMode[mode].hydrate;\n  hydrateMode && hydrateMode.call(this);\n}\n\n/**\n * Hydrates a map.\n *\n * @param {Object} heapMap The heap map is an object which maps a key to a linked ordered map\n *                         which in turn maps a depth of the version tree to a stack\n *                         (another linked oredered map used as a stack) of all the maps with that depth\n *                         with the first map being the last created map for that depth.\n * @param {number|undefined} depth The depth of the version tree.\n * @param {number|undefined} length The length of the map.\n * @param {string} keyPropName Name of the property to use for the keys of the map.\n * @param {number} mode The mode of the map (a value of the enum-like object \"ImmutableLinkedOrderedMapMode\").\n * @param {Object|undefined} head Head of the map.\n * @param {Object|undefined} tail Tail of the map.\n * @return {undefined}\n */\nfunction hydrate({\n  heapMap,\n  depth,\n  length,\n  keyPropName,\n  mode,\n  head,\n  tail,\n  ancestorMap,\n} = {}) {\n  prop(this, \"heapMap\", () => heapMap);\n  this.depth = depth || 0;\n  this.length = length || 0;\n  this.keyPropName = keyPropName;\n  prop(this, \"mode\", () => mode);\n  this.head = head || null;\n  this.tail = tail || null;\n  this.ancestorMap = ancestorMap || null;\n  this.shouldNextForEachBreak = false;\n  this.forEachNextFn = void 0;\n  this.change = null;\n  this[MAP_TAG] = MAP_TAG_VALUE;\n}\n\n/**\n * Returns a node or undefined if the node is an orphan node.\n *\n * @param {Object|undefined} node\n * @return {*} The node if it is valid and is not an orphan node, or \"undefined\" otherwise.\n */\nfunction nodeOrUndefined(node) {\n  return node && !isOrphanNode(node) ? node : void 0;\n}\n\n/**\n * Tests if a node is an orphan node or not.\n *\n * @param {Object} node The node to test.\n * @return {boolean} \"true\" if the node is orphan, \"false\" otherwise.\n */\nfunction isOrphanNode(node) {\n  return node.isOrphanNode;\n}\n\n/**\n * Creates a new lazy map which appends its initial items only when the map is used for the very first time\n * (by calling a method, accessing or setting one of its properties).\n *\n * @param {ImmutableLinkedOrderedMap} map The map.\n * @param {Array} items Array of items to append.\n * @return {ImmutableLinkedOrderedMap} The lazy map.\n */\nfunction newLazyMap(map, initialItems = []) {\n  map.length = initialItems.length;\n  const lazyMap = lazyObject(map, {\n    onceCallback: () => {\n      map.length = 0;\n      appendInitialItemsToMap(map, initialItems);\n    },\n  });\n  return lazyMap;\n}\n\n/**\n * Mutates a map's shared structure (structural sharing) by appending items to the map.\n * This internal function assumes that the given map is empty.\n *\n * @param {ImmutableLinkedOrderedMap} map The map.\n * @param {Array} items Array of items to append.\n * @return {undefined}\n */\nfunction appendInitialItemsToMap(map, items = []) {\n  const { mode, keyPropName } = map;\n\n  const keysMap = {};\n  const length = items.length;\n  if (length) {\n    // There's at least one element.\n    // Update tail.\n    const lastItem = items[length - 1];\n    const { key: tailKey, value: tailValue } = keyValueForItem(\n      keyPropName,\n      lastItem\n    );\n\n    // New tail.\n    const newTail = ImmutableLinkedOrderedMapForMode[\n      mode\n    ].makeImmutableLinkedOrderedMapNode(map, null, null, tailKey, tailValue);\n    ImmutableLinkedOrderedMapForMode[mode].updateHeapMap(map, newTail);\n\n    // Previous tail.\n    const previousTail = map.tail;\n    map.tail = newTail;\n\n    // The tail does not change.\n    keysMap[tailKey] || (map.length++ && (keysMap[tailKey] = true));\n\n    if (length > 1) {\n      // There are at least two items.\n      let lastNode = map.tail;\n\n      // Looping on all the nodes below the last one, in reverse order to ignore previous duplicate keys.\n      for (let i = length - 2; i >= 0; i--) {\n        const item = items[i];\n        const { key, value } = keyValueForItem(keyPropName, item);\n        if (!keysMap[key]) {\n          const node = ImmutableLinkedOrderedMapForMode[\n            mode\n          ].makeImmutableLinkedOrderedMapNode(map, null, null, key, value);\n          ImmutableLinkedOrderedMapForMode[mode].updateHeapMap(map, node);\n          ImmutableLinkedOrderedMapForMode[mode].bindNodes(map, node, lastNode);\n          lastNode = node;\n          map.length++ && (keysMap[key] = true);\n        }\n      }\n\n      if (map.head === null) {\n        map.head = lastNode;\n      }\n    } else {\n      if (previousTail === null) {\n        // \"newTail\" is the first node ever of this map.\n        map.head = newTail;\n      } else {\n        // Only one item, i.e. only the one in \"newTail\".\n        // There was a previous tail, though.\n        ImmutableLinkedOrderedMapForMode[mode].bindNodes(\n          map,\n          previousTail,\n          map.tail\n        );\n      }\n    }\n  }\n}\n\n/**\n * Gets the key and the value of an item.\n *\n * @param {string} keyPropName The name of the key property to use for the items of the map.\n * @param {Object} item An item.\n * @return {Object} An object with a \"key\" and a \"value\" property.\n */\nfunction keyValueForItem(keyPropName, item) {\n  let key;\n  let value;\n  if (item) {\n    key = item[keyPropName];\n    if (typeof key !== \"undefined\") {\n      value = item;\n    } else {\n      for (const prop in item) {\n        key = prop;\n        break;\n      }\n      value = item[key];\n    }\n  }\n  return {\n    key,\n    value,\n  };\n}\n\n/**\n * Stores a change on a map.\n *\n * @param {ImmutableLinkedOrderedMap} map The map.\n * @param {string} changeLabel The label identifying the change.\n * @param {*} [payload] The optional payload of the change.\n * @return {undefined}\n */\nfunction mapChange(map, changeLabel, payload = true) {\n  map.change = {\n    [changeLabel]: payload,\n  };\n}\n\n/**\n * @type {boolean}\n */\nlet isFork = false;\n\n/**\n * Forks a new map from an existent one, hydrating it as needed.\n *\n * @param {ImmutableLinkedOrderedMap} map The map from which to fork.\n * @return {ImmutableLinkedOrderedMap} The new forked map instance.\n */\nfunction forkMap(map) {\n  isFork = true;\n  const newMap = newMapFromMode(map.mode);\n  isFork = false;\n  hydrate.call(newMap, {\n    heapMap: map.heapMap,\n    depth: map.depth,\n    length: map.length,\n    keyPropName: map.keyPropName,\n    mode: map.mode,\n    head: map.head,\n    tail: map.tail,\n    ancestorMap: map,\n  });\n  newMap.depth++;\n\n  const fork = ImmutableLinkedOrderedMapForMode[map.mode].fork;\n  fork && fork(map, newMap);\n  return newMap;\n}\n\n/**\n * Adds an orphan node with \"undefined\" as a value to the given map for the given key.\n *\n * @param {ImmutableLinkedOrderedMap} map The map.\n * @param {string|number} key The key.\n * @return {undefined}\n */\nfunction addImmutableLinkedOrderedMapOrphanNode(map, key) {\n  const newNode = ImmutableLinkedOrderedMapForMode[\n    map.mode\n  ].makeImmutableLinkedOrderedMapNode(map, null, null, key, void 0);\n  newNode.isOrphanNode = true;\n  ImmutableLinkedOrderedMapForMode[map.mode].updateHeapMap(map, newNode);\n}\n\n/**\n * @type {boolean}\n */\nlet creatingNew = false;\n\n/**\n * Base class of an immutable linked ordered map.\n *\n * This is the only class exposed to the code of the client using this library.\n * Internally it uses the factory function \"newImmutableLinkedOrderedMap\"\n * to return the correct subclass given the passed options.\n */\nclass ImmutableLinkedOrderedMap {\n  /**\n   * Constructor.\n   *\n   * @constructor\n   *\n   * @param {Object} options Options.\n   */\n  constructor(options) {\n    if (isFork) {\n      return;\n    }\n    if (!creatingNew) {\n      creatingNew = true;\n      const instance = newImmutableLinkedOrderedMap(options);\n      return instance;\n    } else {\n      creatingNew = false;\n      return this;\n    }\n  }\n\n  /**\n   * Getter for \"Symbol.toStringTag\" used for \"Object.prototype.toString\".\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n\n  /**\n   * Sets a value or multiple values and returns a new updated version of this map\n   * with the new values set.\n   *\n   * The same map instance will be returned if for the given item or all the given items\n   * the values at their respective keys are the same (using the triple equality operator \"===\").\n   *\n   * @param {Object|Array} items An object representing the item to set or an array of items to set (same structure as for the the \"initialItems\" option\n   *                             when creating a new map from scratch).\n   * @param {boolean} prependMissing If set to true and the item is not in the map, it will be prepended instead of being appended.\n   * @return {ImmutableLinkedOrderedMap} A new immutable linked ordered map or this map if nothing has changed.\n   */\n  set(items, prependMissing = false) {\n    const itemsIsArray = Array.isArray(items);\n    if (\n      (itemsIsArray &&\n        // items is an empty array.\n        !items.length) ||\n      // items is either a non-empty array or it's not an array.\n      // If it's falsy, then return this same map.\n      !items\n    ) {\n      // No valid item/items provided.\n      return this;\n    } else if (\n      // If it's not falsy and is not an array, wrap it in an array.\n      !itemsIsArray\n    ) {\n      items = [items];\n    }\n\n    // Initially, assume that all items exist in the map, therefore there isn't a new version yet.\n    let map;\n    let justForked = false;\n    const inserted = [];\n    const updated = [];\n    const keysMap = {};\n\n    let i = items.length - 1;\n    const towards = 0;\n    let nodes;\n    let appendOperationOldTail;\n    let lastPrepend;\n    let loopEnd;\n    const updateI = () => i--;\n    const valid = () => i >= towards;\n    const updateNodesBinding = ({ map, newNode, newNext }) => {\n      ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n        map,\n        newNode,\n        newNext\n      );\n    };\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    loopEnd = () => {}; // No-op.\n    if (!prependMissing) {\n      // Append missing.\n      let firstPrepend = true;\n      nodes = (map, newNode) => {\n        // Append.\n        let ret;\n        if (firstPrepend) {\n          // Store old tail before first appending operation.\n          firstPrepend = false;\n          if (map.tail !== null) {\n            appendOperationOldTail = map.tail;\n          }\n          map.tail = newNode;\n          ret = false;\n        } else {\n          ret = {\n            newNext: lastPrepend,\n          };\n        }\n        lastPrepend = newNode;\n        return ret;\n      };\n      loopEnd = () => {\n        if (lastPrepend) {\n          if (map.head === null) {\n            map.head = lastPrepend;\n          }\n          if (appendOperationOldTail) {\n            ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n              map,\n              appendOperationOldTail,\n              lastPrepend\n            );\n          }\n        }\n      };\n    } else {\n      // Prepend missing.\n      nodes = (map, newNode) => {\n        // Prepend.\n        const oldHead = map.head;\n        map.head = newNode;\n        return {\n          newNext: oldHead,\n        };\n      };\n    }\n    for (; valid(); updateI()) {\n      const item = items[i];\n      const { key, value } = keyValueForItem(this.keyPropName, item);\n      if (keysMap[key]) {\n        // Duplicate key, ignore.\n        continue;\n      }\n      keysMap[key] = true;\n\n      const node = ImmutableLinkedOrderedMapForMode[this.mode].lookup(\n        this,\n        key\n      );\n\n      if (!node) {\n        // Key is missing, either a new tail or a new head is needed.\n        map =\n          (map && ((justForked = false) || map)) ||\n          ((justForked = true) && forkMap(this));\n        const newNode = ImmutableLinkedOrderedMapForMode[\n          map.mode\n        ].makeImmutableLinkedOrderedMapNode(map, null, null, key, value);\n        ImmutableLinkedOrderedMapForMode[map.mode].updateHeapMap(map, newNode);\n\n        if (map.tail === null && prependMissing) {\n          // Initially (i.e. for the first element), the tail is the head when we are prepending.\n          map.tail = newNode;\n          map.head = newNode;\n        } else {\n          const nodesRet = nodes(map, newNode);\n          if (nodesRet) {\n            const { newNext } = nodesRet;\n            updateNodesBinding({ map, newNode, newNext });\n          }\n        }\n\n        map.length++;\n        inserted.unshift({\n          key,\n          value,\n        });\n      } else if (node.element.value !== value) {\n        // Existent key, but value is different.\n        map =\n          (map && (justForked = false)) ||\n          map ||\n          ((justForked = true) && forkMap(this));\n\n        const previous =\n          (!justForked &&\n            ImmutableLinkedOrderedMapForMode[map.mode].findMapNodeByDirection(\n              map,\n              node,\n              \"previous\"\n            )) ||\n          ImmutableLinkedOrderedMapForMode[map.mode].findMapNodeByDirection(\n            this,\n            node,\n            \"previous\"\n          );\n\n        const next =\n          (!justForked &&\n            ImmutableLinkedOrderedMapForMode[map.mode].findMapNodeByDirection(\n              map,\n              node,\n              \"next\"\n            )) ||\n          ImmutableLinkedOrderedMapForMode[map.mode].findMapNodeByDirection(\n            this,\n            node,\n            \"next\"\n          );\n\n        const newNode = ImmutableLinkedOrderedMapForMode[\n          map.mode\n        ].makeImmutableLinkedOrderedMapNode(map, null, null, key, value);\n        ImmutableLinkedOrderedMapForMode[this.mode].updateHeapMap(map, newNode);\n\n        // Check for head.\n        if (previous !== null) {\n          // There's a previous node, \"node\" is not a head.\n          ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n            map,\n            previous,\n            newNode\n          );\n        } else {\n          // \"node\" was a head. Update head.\n          map.head = newNode;\n        }\n\n        // Check for tail.\n        if (next !== null) {\n          // There's a next node, \"node\" is not a tail.\n          ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n            map,\n            newNode,\n            next\n          );\n        } else if (appendOperationOldTail) {\n          // Tail has been updated during the first append operation.\n          appendOperationOldTail = newNode;\n        } else {\n          // \"node\" was a tail. Update tail.\n          map.tail = newNode;\n        }\n\n        updated.unshift({\n          key,\n          value,\n        });\n      }\n    }\n    loopEnd();\n\n    if (!map) {\n      // Nothing has changed.\n      return this;\n    } else {\n      // Store the change on the new map and return it.\n      mapChange(map, \"set\", {\n        inserted,\n        updated,\n        prependMissing,\n      });\n      return map;\n    }\n  }\n\n  /**\n   * Replaces an item in the map, optionally appending or prepending it if \"oldKey\" is missing.\n   *\n   * The same map instance will be returned if for the given item\n   * the value at \"oldKey\" is the same (using the triple equality operator \"===\").\n   * Beware that in this case, \"oldKey\" will remain in the map even if the given \"item\" is the same\n   * but was mutated and now has a different key!\n   * Also, the same map instance will be returned if \"oldKey\" is missing and \"addMissing\" is true\n   * and there's already the same item at the key of \"item\".\n   *\n   * Note that if the key of \"item\" is different from \"oldKey\" and it already exists in the map,\n   * then the value of item will replace the underlying value for that same key\n   * if the values are different (using the triple equality operator \"===\")\n   * or a new untouched forked map will be returned.\n   * This is to prevent duplicate keys in the map.\n   *\n   * @param {string|number} oldKey The old key to replace.\n   * @param {Object} item The item (same structure as for the the \"initialItems\" option\n   *                      when creating a new map from scratch).\n   * @param {boolean} addMissing If set to true and \"oldKey\" is missing, will append the item if missing.\n   *                             If the key of the item already exists in the map, the value at that key will be replaced\n   *                             if the values are different (using the triple equality operator \"===\")\n   * @param {boolean} prependMissing If set to true with \"addMissing\" set to true and \"oldKey\" is missing,\n   *                                 will prepend the item, instead of appending it.\n   * @return {ImmutableLinkedOrderedMap} A new immutable linked ordered map or this map if nothing has changed.\n   */\n  replace(oldKey, item, addMissing = false, prependMissing = false) {\n    const node = ImmutableLinkedOrderedMapForMode[this.mode].lookup(\n      this,\n      oldKey\n    );\n    let map;\n    let wasInserted = false;\n    let wasUpdated = false;\n    let hadExistentNodeForKey = false;\n    let key;\n    let value;\n\n    if (!node) {\n      // The old key does not exist.\n      if (addMissing) {\n        // Add missing key with new item.\n        map = map || forkMap(this);\n\n        // This needs to happen before updating the heap map so that all modes work!\n        const existentNodeForKey = ImmutableLinkedOrderedMapForMode[\n          this.mode\n        ].lookup(this, key);\n\n        const keyValue = keyValueForItem(map.keyPropName, item);\n        key = keyValue.key;\n        value = keyValue.value;\n\n        const newNode = ImmutableLinkedOrderedMapForMode[\n          map.mode\n        ].makeImmutableLinkedOrderedMapNode(map, null, null, key, value);\n        ImmutableLinkedOrderedMapForMode[map.mode].updateHeapMap(map, newNode);\n\n        if (existentNodeForKey) {\n          hadExistentNodeForKey = true;\n          if (existentNodeForKey.element.value !== value) {\n            if (existentNodeForKey === map.head) {\n              map.head = newNode;\n            }\n            if (existentNodeForKey === map.tail) {\n              map.tail = newNode;\n            }\n            const existentNodeForKeyPrevious = ImmutableLinkedOrderedMapForMode[\n              this.mode\n            ].findMapNodeByDirection(this, existentNodeForKey, \"previous\");\n            const existentNodeForKeyNext = ImmutableLinkedOrderedMapForMode[\n              this.mode\n            ].findMapNodeByDirection(this, existentNodeForKey, \"next\");\n            if (existentNodeForKeyPrevious !== null) {\n              ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n                map,\n                existentNodeForKeyPrevious,\n                newNode\n              );\n            }\n            if (existentNodeForKeyNext !== null) {\n              ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n                map,\n                newNode,\n                existentNodeForKeyNext\n              );\n            }\n            wasUpdated = true;\n          }\n        }\n\n        if (!hadExistentNodeForKey) {\n          map.length++;\n          wasInserted = true;\n          if (!prependMissing) {\n            // Append new item.\n            const newPrevious = map.tail;\n            map.tail = newNode;\n\n            if (newPrevious === null) {\n              map.head = map.tail;\n            } else {\n              ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n                map,\n                newPrevious,\n                newNode\n              );\n            }\n          } else {\n            // Prepend new item.\n            const newNext = map.head;\n            map.head = newNode;\n\n            if (newNext === null) {\n              map.tail = map.head;\n            } else {\n              ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n                map,\n                newNode,\n                newNext\n              );\n            }\n          }\n        }\n      }\n    } else {\n      // The old key exists.\n      const keyValue = keyValueForItem(this.keyPropName, item);\n      key = keyValue.key;\n      value = keyValue.value;\n\n      if (node.element.value !== value) {\n        // Node already exists, it must be overridden in the new map.\n        map = map || forkMap(this);\n\n        const newNode = ImmutableLinkedOrderedMapForMode[\n          map.mode\n        ].makeImmutableLinkedOrderedMapNode(map, null, null, key, value);\n\n        const previous = ImmutableLinkedOrderedMapForMode[\n          this.mode\n        ].findMapNodeByDirection(this, node, \"previous\");\n        const next = ImmutableLinkedOrderedMapForMode[\n          this.mode\n        ].findMapNodeByDirection(this, node, \"next\");\n\n        if (oldKey + \"\" !== key + \"\") {\n          // \"oldKey\" differs from \"key\".\n          addImmutableLinkedOrderedMapOrphanNode(map, oldKey);\n\n          // This needs to happen before updating the heap map so that all modes work!\n          const existentNodeForKey = ImmutableLinkedOrderedMapForMode[\n            this.mode\n          ].lookup(this, key);\n          if (existentNodeForKey) {\n            hadExistentNodeForKey = true;\n            if (existentNodeForKey.element.value !== value) {\n              if (existentNodeForKey === map.head) {\n                map.head = newNode;\n              }\n              if (existentNodeForKey === map.tail) {\n                map.tail = newNode;\n              }\n              const existentNodeForKeyPrevious = ImmutableLinkedOrderedMapForMode[\n                this.mode\n              ].findMapNodeByDirection(this, existentNodeForKey, \"previous\");\n              const existentNodeForKeyNext = ImmutableLinkedOrderedMapForMode[\n                this.mode\n              ].findMapNodeByDirection(this, existentNodeForKey, \"next\");\n              if (existentNodeForKeyPrevious !== null) {\n                if (node !== existentNodeForKeyPrevious) {\n                  ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n                    map,\n                    existentNodeForKeyPrevious,\n                    newNode\n                  );\n                } else if (previous !== null) {\n                  ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n                    map,\n                    previous,\n                    newNode\n                  );\n                } else {\n                  map.head = newNode;\n                }\n              }\n              if (existentNodeForKeyNext !== null) {\n                if (node !== existentNodeForKeyNext) {\n                  ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n                    map,\n                    newNode,\n                    existentNodeForKeyNext\n                  );\n                } else if (next !== null) {\n                  ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n                    map,\n                    newNode,\n                    next\n                  );\n                } else {\n                  map.tail = newNode;\n                }\n              }\n            }\n            map.length--;\n          }\n        }\n\n        if (!hadExistentNodeForKey) {\n          if (previous === null) {\n            // It's a head.\n            map.head = newNode;\n            if (next === null) {\n              // It's also a tail.\n              map.tail = newNode;\n            } else {\n              ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n                map,\n                newNode,\n                next\n              );\n            }\n          } else if (next === null) {\n            // It's a tail and has a previous node.\n            map.tail = newNode;\n            ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n              map,\n              previous,\n              newNode\n            );\n          } else {\n            // It's a node in between.\n            ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n              map,\n              previous,\n              newNode\n            );\n            ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n              map,\n              newNode,\n              next\n            );\n          }\n        }\n\n        ImmutableLinkedOrderedMapForMode[map.mode].updateHeapMap(map, newNode);\n        wasUpdated = true;\n      }\n    }\n\n    if (!map) {\n      // Nothing has changed.\n      return this;\n    } else {\n      // Store the change on the new map and return it.\n      mapChange(map, \"replace\", {\n        oldKey,\n        key,\n        value,\n        wasInserted,\n        wasUpdated,\n        hadExistentNodeForKey,\n        prependMissing,\n      });\n      return map;\n    }\n  }\n\n  /**\n   * Unsets a value, multiple values or an item by its key and returns a new updated version of this map\n   * without those value/values.\n   *\n   * The same map instance will be returned if the given key or all the keys of the given items or item do not exist.\n   *\n   * @param {Object|Array|string|number} itemsOrKey An object or an array of objects to unset, or a key to unset.\n   * @return {ImmutableLinkedOrderedMap} A new immutable linked ordered map or this map if nothing has changed.\n   */\n  unset(itemsOrKey) {\n    const typeOfItemsOrKey = typeof itemsOrKey;\n    if (typeOfItemsOrKey === \"number\" || typeOfItemsOrKey === \"string\") {\n      return this.unsetKey(itemsOrKey);\n    }\n\n    const keyPropName = this.keyPropName;\n    if (Array.isArray(itemsOrKey)) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      let map = this;\n      for (const item of itemsOrKey) {\n        map = map.unsetKey(item[keyPropName]);\n      }\n      return map;\n    }\n    return this.unsetKey(itemsOrKey[keyPropName]);\n  }\n\n  /**\n   * Unsets an item by its key.\n   *\n   * The same map instance will be returned if the given key does not exist.\n   *\n   * @param {string|number} key The key to unset.\n   * @return {ImmutableLinkedOrderedMap} A new immutable linked ordered map or this map if nothing has changed.\n   */\n  unsetKey(key) {\n    const node = ImmutableLinkedOrderedMapForMode[this.mode].lookup(this, key);\n    let map;\n    let value;\n\n    if (node) {\n      // Node exists and therefore must be unset in the new map.\n      map = map || forkMap(this);\n      value = node.element.value;\n\n      // This new node is an orphan one.\n      // Lookups to it in the context of this new map will lead to \"undefined\".\n      addImmutableLinkedOrderedMapOrphanNode(map, key);\n\n      const previous = ImmutableLinkedOrderedMapForMode[\n        map.mode\n      ].findMapNodeByDirection(this, node, \"previous\");\n      const next = ImmutableLinkedOrderedMapForMode[\n        map.mode\n      ].findMapNodeByDirection(this, node, \"next\");\n\n      if (previous === null) {\n        // It's a head that's being removed.\n        if (next === null) {\n          // It's also a tail.\n          map.head = null;\n          map.tail = null;\n          map.length = 0;\n        } else {\n          // It has a next node.\n          const newHeadNode = ImmutableLinkedOrderedMapForMode[\n            map.mode\n          ].makeImmutableLinkedOrderedMapNode(\n            map,\n            null,\n            null,\n            next.element.key,\n            next.element.value\n          );\n          ImmutableLinkedOrderedMapForMode[map.mode].updateHeapMap(\n            map,\n            newHeadNode\n          );\n          map.head = newHeadNode;\n          const nextNext = ImmutableLinkedOrderedMapForMode[\n            map.mode\n          ].findMapNodeByDirection(this, next, \"next\");\n          if (nextNext === null) {\n            // The next node is a tail.\n            map.tail = newHeadNode;\n          } else {\n            ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n              map,\n              newHeadNode,\n              nextNext\n            );\n          }\n          map.length--;\n        }\n      } else if (next === null) {\n        // It's a tail that's being removed and it has a previous node.\n        const newTailNode = ImmutableLinkedOrderedMapForMode[\n          map.mode\n        ].makeImmutableLinkedOrderedMapNode(\n          map,\n          null,\n          null,\n          previous.element.key,\n          previous.element.value\n        );\n        ImmutableLinkedOrderedMapForMode[map.mode].updateHeapMap(\n          map,\n          newTailNode\n        );\n        map.tail = newTailNode;\n        const previousPrevious = ImmutableLinkedOrderedMapForMode[\n          map.mode\n        ].findMapNodeByDirection(this, previous, \"previous\");\n        if (previousPrevious === null) {\n          // The previous node is a head.\n          map.head = newTailNode;\n        } else {\n          ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n            map,\n            previousPrevious,\n            newTailNode\n          );\n        }\n        map.length--;\n      } else {\n        // It's a node in between.\n        ImmutableLinkedOrderedMapForMode[map.mode].bindNodes(\n          map,\n          previous,\n          next\n        );\n        map.length--;\n      }\n    }\n\n    if (!map) {\n      // Nothing has changed.\n      return this;\n    } else {\n      mapChange(map, \"unset\", {\n        key,\n        value,\n      });\n      return map;\n    }\n  }\n\n  /**\n   * Empties the map.\n   *\n   * The same map instance will be returned if the map is already empty.\n   *\n   * @return {ImmutableLinkedOrderedMap} A new emptied immutable linked ordered map.\n   */\n  empty() {\n    if (this.length <= 0) {\n      // The map is already empty. Nothing has changed.\n      return this;\n    }\n\n    const map = new ImmutableLinkedOrderedMap({\n      initialItems: [],\n      keyPropName: this.keyPropName,\n      mode: this.mode,\n    });\n    map.length = 0;\n    map.depth = this.depth + 1;\n    map.ancestorMap = this;\n    mapChange(map, \"empty\");\n    return map;\n  }\n\n  /**\n   * Lookups a value in the map.\n   *\n   * @param {string|number} key The key to lookup.\n   * @return {*} The associated value, or undefined, if the given key is missing.\n   */\n  get(key) {\n    const node = ImmutableLinkedOrderedMapForMode[this.mode].lookup(this, key);\n    if (node) {\n      return node.element.value;\n    }\n    return void 0;\n  }\n\n  /**\n   * Returns a key/value pair of the first item in the map.\n   *\n   * @return {Object|undefined} An object with the property \"key\" (the key of the item in the map) and \"value\"\n   *                            (the value of the item in the map).\n   *                            If the map is empty, \"undefined\" will be returned.\n   */\n  first() {\n    if (this.head) {\n      return {\n        key: this.head.element.key,\n        value: this.head.element.value,\n      };\n    } else {\n      return void 0;\n    }\n  }\n\n  /**\n   * Returns a key/value pair of the last item in the map.\n   *\n   * @return {Object|undefined} An object with the property \"key\" (the key of the item in the map) and \"value\"\n   *                            (the value of the item in the map).\n   *                            If the map is empty, \"undefined\" will be returned.\n   */\n  last() {\n    if (this.tail) {\n      return {\n        key: this.tail.element.key,\n        value: this.tail.element.value,\n      };\n    } else {\n      return void 0;\n    }\n  }\n\n  /**\n   * Returns a range of key/value pairs before the given key up to a max number of items\n   * (counting the given key if included).\n   *\n   * @param {string|number} key The key to lookup and use for the creation of the range.\n   * @param {number} maxNumberOfItems Max number of key/value pairs to return for the range including or not including the item at the given key\n   *                                  (depending on the value of the \"itemAtKeyIncluded\" opton).\n   *                                  By default, all items before the given key are included in the returned range of key/value pairs.\n   * @param {boolean} itemAtKeyIncluded Whether or not to include the item at the given key in the range (by default the item is included).\n   * @return {Array} An array which represents the range, each item being a key/value pair representing an item of the map.\n   *                 An empty array if the given key does not exist in the map or the given key does exist in the map but is not included\n   *                 in the range and its item is the first of the map.\n   *                 An empty array is also returned if \"maxNumberOfItems\" is less than or equal to 0.\n   */\n  rangeBefore(key, maxNumberOfItems = Infinity, itemAtKeyIncluded = true) {\n    const node = ImmutableLinkedOrderedMapForMode[this.mode].lookup(this, key);\n    if (!node || maxNumberOfItems <= 0) {\n      return [];\n    }\n\n    let current = itemAtKeyIncluded\n      ? node\n      : ImmutableLinkedOrderedMapForMode[this.mode].findMapNodeByDirection(\n          this,\n          node,\n          \"previous\"\n        );\n    if (!current) {\n      return [];\n    }\n\n    const range = [{ key: current.element.key, value: current.element.value }];\n    while (current && range.length < maxNumberOfItems) {\n      current = ImmutableLinkedOrderedMapForMode[\n        this.mode\n      ].findMapNodeByDirection(this, current, \"previous\");\n      if (!current) {\n        break;\n      }\n      range.push({ key: current.element.key, value: current.element.value });\n    }\n    return range.reverse();\n  }\n\n  /**\n   * Returns a range of key/value pairs after the given key up to a max number of items\n   * (counting the given key if included).\n   *\n   * @param {string|number} key The key to lookup and use for the creation of the range.\n   * @param {number} maxNumberOfItems Max number of key/value pairs to return for the range including or not including the item at the given key\n   *                                  (depending on the value of the \"itemAtKeyIncluded\" opton).\n   *                                  By default, all items after the given key are included in the returned range of key/value pairs.\n   * @param {boolean} itemAtKeyIncluded Whether or not to include the item at the given key in the range (by default the item is included).\n   * @return {Array} An array which represents the range, each item being a key/value pair representing an item of the map.\n   *                 An empty array if the given key does not exist in the map or the given key does exist in the map but is not included\n   *                 in the range and its item is the last of the map.\n   *                 An empty array is also returned if \"maxNumberOfItems\" is less than or equal to 0.\n   */\n  rangeAfter(key, maxNumberOfItems = Infinity, itemAtKeyIncluded = true) {\n    const node = ImmutableLinkedOrderedMapForMode[this.mode].lookup(this, key);\n    if (!node || maxNumberOfItems <= 0) {\n      return [];\n    }\n\n    let current = itemAtKeyIncluded\n      ? node\n      : ImmutableLinkedOrderedMapForMode[this.mode].findMapNodeByDirection(\n          this,\n          node,\n          \"next\"\n        );\n    if (!current) {\n      return [];\n    }\n\n    const range = [{ key: current.element.key, value: current.element.value }];\n    while (current && range.length < maxNumberOfItems) {\n      current = ImmutableLinkedOrderedMapForMode[\n        this.mode\n      ].findMapNodeByDirection(this, current, \"next\");\n      if (!current) {\n        break;\n      }\n      range.push({ key: current.element.key, value: current.element.value });\n    }\n    return range;\n  }\n\n  /**\n   * Tests if the map is empty.\n   *\n   * @return {boolean} True if the map is empty, false otherwise.\n   */\n  isEmpty() {\n    return this.length <= 0;\n  }\n\n  /**\n   * Loop through all the values of this immutable linked ordered map in the order they were added.\n   *\n   * @param {Function} fn A callback function to call for each value stored in the map.\n   *                      The callback will receive the value as the first argument, the key as the second argument\n   *                      and the index of the item in the map as the third argument.\n   * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n   *                             from the tail node). The default is to loop through all the elements starting\n   *                             from the head node.\n   * @return {undefined}\n   */\n  forEach(fn, reversed = false) {\n    let key;\n    let value;\n    let current;\n    let nextNodeDirection;\n    let i;\n    let updateI;\n\n    this.shouldNextForEachBreak = false;\n    this.forEachNextFn = void 0;\n\n    if (reversed) {\n      current = this.tail;\n      nextNodeDirection = \"previous\";\n      i = this.length - 1;\n      updateI = () => i--;\n    } else {\n      current = this.head;\n      nextNodeDirection = \"next\";\n      i = 0;\n      updateI = () => i++;\n    }\n\n    while (current) {\n      if (!this.shouldNextForEachBreak) {\n        const element = current.element;\n        key = element.key;\n        value = element.value;\n        const result = (this.forEachNextFn || fn).call(this, value, key, i);\n        if (result === false) {\n          // Break instantly.\n          break;\n        }\n        current = ImmutableLinkedOrderedMapForMode[\n          this.mode\n        ].findMapNodeByDirection(this, current, nextNodeDirection);\n        updateI();\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Break the next \"forEach\" loop iteration occurring on this immutable linked ordered map.\n   *\n   * @return {undefined}\n   */\n  break() {\n    this.shouldNextForEachBreak = true;\n  }\n\n  /**\n   * Returns an array of values of this map.\n   *\n   * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n   *                             from the tail node). The default is to loop through all the elements starting\n   *                             from the head node.\n   *                             If \"reversed\" is set to \"true\", the returned values will be in reverse order.\n   * @return {Array} An array of all the values of this map, in the order they were added to the map.\n   */\n  values(reversed = false) {\n    const array = new Array(this.length);\n    let i = 0;\n    this.forEach(function (value) {\n      array[i] = value;\n      i++;\n    }, reversed);\n    return array;\n  }\n\n  /**\n   * Returns an array of keys of this map.\n   *\n   * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n   *                             from the tail node). The default is to loop through all the elements starting\n   *                             from the head node.\n   *                             If \"reversed\" is set to \"true\", the returned keys will be in reverse order.\n   * @return {Array} An array of all the keys of this map, in the order they were added to the map.\n   */\n  keys(reversed = false) {\n    const array = new Array(this.length);\n    let i = 0;\n    this.forEach(function (value, key) {\n      array[i] = key;\n      i++;\n    }, reversed);\n    return array;\n  }\n\n  /**\n   * Returns an array of key/value pairs for each item in the map.\n   *\n   * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n   *                             from the tail node). The default is to loop through all the elements starting\n   *                             from the head node.\n   *                             If \"reversed\" is set to \"true\", the returned key/value pairs will be in reverse order.\n   * @return {Array} An array of objects where each object has the property \"key\" (the key of the item in the map)\n   *                 and \"value\" (the value of the item in the map).\n   */\n  keysValues(reversed = false) {\n    const array = new Array(this.length);\n    let i = 0;\n    this.forEach((value, key) => {\n      array[i] = {\n        key,\n        value,\n      };\n      i++;\n    }, reversed);\n    return array;\n  }\n\n  /**\n   * Map all the values of this immutable linked ordered map in the order they were added\n   * to a new array.\n   *\n   * @param {Function} fn A callback function to call for each value stored in the map.\n   *                      The callback will receive the value as the first argument,\n   *                      the key as the second argument, and the index of the item in the map as the third argument.\n   *                      It's return value will be used as an element of the returned array for that item.\n   * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n   *                             from the tail node). The default is to loop through all the elements starting\n   *                             from the head node.\n   *                             If \"reversed\" is set to \"true\", the returned mapped values will be in reverse order.\n   * @return {Array} An array with the mapped values.\n   */\n  map(fn, reversed = false) {\n    const array = new Array(this.length);\n    let i = 0;\n    this.forEach((value, key, index) => {\n      array[i] = fn(value, key, index);\n      i++;\n    }, reversed);\n    return array;\n  }\n\n  /**\n   * Reduce all the values of this immutable linked ordered map to a single output value.\n   *\n   * @param {Function} fn A callback function to call for each value stored in the map.\n   *                      The callback will receive the accumulator as the first argument,\n   *                      the current value as the second argument, the current value's key as the third argument\n   *                      and the index of the item in the map as the fourth argument.\n   *\n   *                      It's return value is assigned to the accumulator, whose value is remembered across each iteration\n   *                      throughout the map and ultimately becomes the final, single resulting value.\n   *\n   *                      The first time the callback is called, accumulator and current value can be one of two values.\n   *                      If \"initialValue\" is provided in the call to \"reduce()\", then accumulator will be equal to \"initialValue\",\n   *                      and the current value will be equal to the first value in the map.\n   *                      If no \"initialValue\" is provided, then the accumulator will be equal to the first or last value in the map\n   *                      (if \"reversed\" is either \"false\" or \"true\", respectively), and the current value will be equal to the value of\n   *                      the next or previous item (again, if \"reversed\" is either \"false\" or \"true\", respectively).\n   * @param {*} initialValue A value to use as the first argument to the first call of the callback.\n   *                         If no \"initialValue\" is supplied, the first element in the map will be used and skipped.\n   *                         Calling \"reduce()\" on an empty map without an initial value will throw a \"TypeError\".\n   * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n   *                             from the tail node). The default is to loop through all the elements starting\n   *                             from the head node.\n   * @return {*} The single value that results from the reduction.\n   */\n  reduce(fn, initialValue, reversed = false) {\n    const hasInitialValue = arguments.length > 1;\n    let acc;\n    let skipFirst = false;\n\n    if (!hasInitialValue) {\n      if (!this.length) {\n        throw new TypeError(\n          `ImmutableLinkedOrderedMap type error: Reduce of empty map with no initial value`\n        );\n      }\n      skipFirst = true;\n      acc = (reversed ? this.last() : this.first()).value;\n    } else {\n      acc = initialValue;\n    }\n\n    const accFn = (value, key, index) => {\n      acc = fn(acc, value, key, index);\n    };\n    const overridableFn = function (value, key, index) {\n      this.forEachNextFn = accFn;\n      if (skipFirst) {\n        return;\n      }\n      accFn(value, key, index);\n    };\n    this.forEach(overridableFn, reversed);\n\n    return acc;\n  }\n\n  /**\n   * Filters the values of this immutable linked ordered map returning an array with the filtered values.\n   *\n   * @param {Function} fn A callback function to call for each value stored in the map.\n   *                      The callback will receive the value as the first argument,\n   *                      the key as the second argument, and the index of the item in the map as the third argument.\n   *                      The values for which the callback returned a falsy value will not be added to the returned\n   *                      array of filtered items.\n   * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n   *                             from the tail node). The default is to loop through all the elements starting\n   *                             from the head node.\n   *                             If \"reversed\" is set to \"true\", the returned filtered values will be in reverse order.\n   * @return {Array} An array with the filtered values.\n   */\n  filter(fn, reversed = false) {\n    const array = [];\n    let i = 0;\n    this.forEach((value, key, index) => {\n      const res = fn(value, key, index);\n      if (res) {\n        array[i] = value;\n        i++;\n      }\n    }, reversed);\n    return array;\n  }\n\n  /**\n   * Tests whether all values in the map pass the test implemented by the provided function.\n   *\n   * @param {Function} fn A callback function to call for each value stored in the map.\n   *                      The callback will receive the value as the first argument, the key as the second argument\n   *                      and the index of the item in the map as the third argument.\n   *                      If the returned value of the callback for a given value is falsy, this method will instantly return \"false\".\n   * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n   *                             from the tail node). The default is to loop through all the elements starting\n   *                             from the head node.\n   * @return {boolean} \"true\" all values in the map pass the test implemented by the provided callback function, \"false\" otherwise.\n   */\n  every(fn, reversed = false) {\n    let allTrue = true;\n    this.forEach((value, key, index) => {\n      const res = fn(value, key, index);\n      if (!res) {\n        allTrue = false;\n        return false;\n      }\n    }, reversed);\n    return allTrue;\n  }\n\n  /**\n   * Tests whether at least one element in the map passes the test implemented by the provided function.\n   *\n   * @param {Function} fn A callback function to call for each value stored in the map.\n   *                      The callback will receive the value as the first argument, the key as the second argument\n   *                      and the index of the item in the map as the third argument.\n   *                      If the returned value of the callback for a given value is truthy, this method will instantly return \"true\".\n   * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n   *                             from the tail node). The default is to loop through all the elements starting\n   *                             from the head node.\n   * @return {boolean} \"true\" if at least one element passes the test implemented by the provided callback function, \"false\" otherwise.\n   */\n  some(fn, reversed = false) {\n    let ret = false;\n    this.forEach((value, key, index) => {\n      const res = fn(value, key, index);\n      if (res) {\n        ret = true;\n        return false;\n      }\n    }, reversed);\n    return ret;\n  }\n\n  /**\n   * Static method to serialize a map to JSON.\n   *\n   * @param {ImmutableLinkedOrderedMap} map A map.\n   * @return {string} The JSON representing the given map.\n   */\n  static toJSON(map) {\n    return JSON.stringify({\n      keyPropName: map.keyPropName,\n      keysValues: map.keysValues(),\n    });\n  }\n\n  /**\n   * Static method to unserialize a map from its JSON representation.\n   *\n   * @param {string} json A map JSON representation, previously returned by `ImmutableLinkedOrderedMap.toJSON`.\n   * @return {ImmutableLinkedOrderedMap} The unserialized map.\n   */\n  static fromJSON(json) {\n    const parsed = JSON.parse(json);\n    const map = lazyMapFactory(parsed.keyPropName)(\n      parsed.keysValues.map(({ key, value }) => ({ [key]: value }))\n    );\n    return map;\n  }\n}\n\n/* ======================================================================================================== */\n\n/**\n * Binds two nodes of a map in single mode.\n *\n * @param {MultiwayModeImmutableLinkedOrderedMap} map The map.\n * @param {Object} previousNode Previous node.\n * @param {Object} nextNode Next node.\n * @return {undefined}\n */\nfunction bindSingleModeNodes(map, previousNode, nextNode) {\n  const { depth } = map;\n  previousNode.next.set(depth, nextNode, true);\n  nextNode.previous.set(depth, previousNode, true);\n}\n\n/**\n * Makes a new node for an immutable linked ordered map in single mode (used internally).\n *\n * @param {ImmutableLinkedOrderedMap} map The map.\n * @param {Object|null} previous Previous node or null if there isn't one.\n * @param {Object|null} next Next node or null if there isn't one.\n * @param {string|number} key The key of the mapped value.\n * @param {*} value The mapped value.\n * @return {Object} The node.\n */\nfunction makeSingleModeImmutableLinkedOrderedMapNode(\n  map,\n  previous,\n  next,\n  key,\n  value\n) {\n  const { depth } = map;\n\n  const previousDepthMap = new LinkedOrderedMap();\n  previousDepthMap.set(depth, previous);\n\n  const nextDepthMap = new LinkedOrderedMap();\n  nextDepthMap.set(depth, next);\n\n  const node = makeNode(previousDepthMap, nextDepthMap, {\n    key,\n    value,\n  });\n  return node;\n}\n\n/**\n * Finds a previous or next node of a node in the context of an immutable linked ordered map\n * in single mode.\n *\n * @param {SingleModeImmutableLinkedOrderedMap} map The map.\n * @param {Object} fromNode From node.\n * @param {string} nextNodeDirection The direction, either \"previous\" or \"next\".\n * @return {Object|null} The previous node if it exists, or null if it doesn't (e.g. when called on a head node).\n */\nfunction findSingleModeMapNodeByDirection(map, fromNode, nextNodeDirection) {\n  if (\n    (fromNode === map.tail && nextNodeDirection === \"next\") ||\n    (fromNode === map.head && nextNodeDirection === \"previous\")\n  ) {\n    return null;\n  }\n\n  const { depth } = map;\n  const directionMap = fromNode[nextNodeDirection];\n  let node = null;\n  directionMap.forEach((depthKey, v) => {\n    if (depth >= depthKey) {\n      node = v;\n      return false;\n    }\n  });\n  return node;\n}\n\n/**\n * Updates a heap map shared structure (structural sharing) of a map in single mode.\n *\n * @param {SingleModeImmutableLinkedOrderedMap} map The map which shared heap map should be updated.\n * @param {Object} itemNode The linked node of the item.\n * @return {undefined}\n */\nfunction updateSingleModeHeapMap(map, itemNode) {\n  const { heapMap, depth } = map;\n  const key = itemNode.element.key;\n\n  if (!heapMap[key]) {\n    // Depth map.\n    heapMap[key] = new LinkedOrderedMap();\n  }\n  heapMap[key].set(depth, itemNode, true);\n}\n\n/**\n * Lookups a node in a single mode map.\n *\n * @param {SingleModeImmutableLinkedOrderedMap} map The map.\n * @param {string|number} key The key to lookup.\n * @return {Object|undefined} The node in the heap map or undefined, if the value for that key is missing.\n */\nfunction lookupSingleMode(map, key) {\n  const { heapMap, depth } = map;\n\n  if (!heapMap[key]) {\n    return void 0;\n  }\n  const depthMap = heapMap[key];\n  let node;\n  depthMap.forEach((depthKey, v) => {\n    if (depth >= depthKey) {\n      node = v;\n      return false;\n    }\n  });\n  return nodeOrUndefined(node);\n}\n\n/**\n * Throws an error for a second mutation operation on an immutable linkerd ordered map\n * in single mode.\n *\n * @param {string} operation A string identifying the mutation operation.\n * @return {undefined}\n * @throws {Error}\n */\nfunction throwSingleModemutationOperationOccurredError(operation) {\n  throw new Error(\n    `ImmutableLinkedOrderedMap error: Mutation operation \"${operation}\" is not allowed on a map in single mode on which a mutation operation already occurred once.`\n  );\n}\n\n/**\n * Single mode immutable linked ordered map.\n */\nclass SingleModeImmutableLinkedOrderedMap extends ImmutableLinkedOrderedMap {\n  /**\n   * Constructor.\n   *\n   * @constructor\n   *\n   * @param {Object} options Options.\n   */\n  constructor(options) {\n    const instance = super(options);\n\n    instance.mutationOperationOccurred = false;\n    return instance;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  set(items, prependMissing = false) {\n    this.mutationOperationOccurred &&\n      throwSingleModemutationOperationOccurredError(\"set\");\n    const map = super.set(items, prependMissing);\n    if (this !== map) {\n      this.mutationOperationOccurred = true;\n    }\n    return map;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  replace(oldKey, item, addMissing = false, prependMissing = false) {\n    this.mutationOperationOccurred &&\n      throwSingleModemutationOperationOccurredError(\"replace\");\n    const map = super.replace(oldKey, item, addMissing, prependMissing);\n    if (this !== map) {\n      this.mutationOperationOccurred = true;\n    }\n    return map;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  unset(key) {\n    this.mutationOperationOccurred &&\n      throwSingleModemutationOperationOccurredError(\"unset\");\n    const map = super.unset(key);\n    if (this !== map) {\n      this.mutationOperationOccurred = true;\n    }\n    return map;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  empty() {\n    this.mutationOperationOccurred &&\n      throwSingleModemutationOperationOccurredError(\"empty\");\n    const map = super.empty();\n    if (this !== map) {\n      this.mutationOperationOccurred = true;\n    }\n    return map;\n  }\n}\n\n/* ======================================================================================================== */\n\n/**\n * Binds two nodes of a map in multiway mode.\n *\n * @param {MultiwayModeImmutableLinkedOrderedMap} map The map.\n * @param {Object} previousNode Previous node.\n * @param {Object} nextNode Next node.\n * @return {undefined}\n */\nfunction bindMultiwayModeNodes(map, previousNode, nextNode) {\n  const { depth, version } = map;\n\n  if (!previousNode.next.map[depth]) {\n    previousNode.next.set(depth, new LinkedOrderedMap(), true);\n  }\n  const previousNodeDepthMap = previousNode.next.get(depth);\n  previousNodeDepthMap.set(version, nextNode, true);\n\n  if (!nextNode.previous.map[depth]) {\n    nextNode.previous.set(depth, new LinkedOrderedMap(), true);\n  }\n  const nextNodeDepthMap = nextNode.previous.get(depth);\n  nextNodeDepthMap.set(version, previousNode, true);\n}\n\n/**\n * Makes a new node for an immutable linked ordered map in multiway mode (used internally).\n *\n * @param {ImmutableLinkedOrderedMap} map The map.\n * @param {Object|null} previous Previous node or null if there isn't one.\n * @param {Object|null} next Next node or null if there isn't one.\n * @param {string|number} key The key of the mapped value.\n * @param {*} value The mapped value.\n * @return {Object} The node.\n */\nfunction makeMultiwayModeImmutableLinkedOrderedMapNode(\n  map,\n  previous,\n  next,\n  key,\n  value\n) {\n  const { depth, version } = map;\n\n  const previousDepthMap = new LinkedOrderedMap();\n  const previousVersionMap = new LinkedOrderedMap();\n  previousVersionMap.set(version, previous);\n  previousDepthMap.set(depth, previousVersionMap);\n\n  const nextDepthMap = new LinkedOrderedMap();\n  const nextVersionMap = new LinkedOrderedMap();\n  nextVersionMap.set(version, next);\n  nextDepthMap.set(depth, nextVersionMap);\n\n  const node = makeNode(previousDepthMap, nextDepthMap, {\n    key,\n    value,\n  });\n  return node;\n}\n\n/**\n * Hydrates a map in multiway mode.\n *\n * @param {string} version The version of the map in the context of the version tree,\n *                         used during lookups.\n */\nfunction hydrateMultiwayMode({\n  version = MULTIWAY_MODE_INITIAL_MAP_TREE_DEPTH_VERSION,\n} = {}) {\n  this.version = version;\n}\n\n/**\n * Finds a previous or next node of a node in the context of an immutable linked ordered map\n * in multiway mode.\n *\n * @param {MultiwayModeImmutableLinkedOrderedMap} map The map.\n * @param {Object} fromNode From node.\n * @param {string} nextNodeDirection The direction, either \"previous\" or \"next\".\n * @return {Object|null} The previous node if it exists, or null if it doesn't (e.g. when called on a head node).\n */\nfunction findMultiwayModeMapNodeByDirection(map, fromNode, nextNodeDirection) {\n  if (\n    (fromNode === map.tail && nextNodeDirection === \"next\") ||\n    (fromNode === map.head && nextNodeDirection === \"previous\")\n  ) {\n    return null;\n  }\n\n  const { depth, version } = map;\n  const directionMap = fromNode[nextNodeDirection];\n  let node = null;\n  directionMap.forEach((depthKey, v) => {\n    if (depth >= depthKey) {\n      v.forEach((stackVersion, possibleNode) => {\n        if (isAncestorVersionOfDescendantVersion(stackVersion, version)) {\n          node = possibleNode;\n          return false;\n        }\n      });\n      if (node) {\n        return false;\n      }\n    }\n  });\n  return node;\n}\n\n/**\n * Updates a heap map shared structure (structural sharing) of a map in multiway mode.\n *\n * @param {MultiwayModeImmutableLinkedOrderedMap} map The map which shared heap map should be updated.\n * @param {Object} itemNode The linked node of the item.\n * @return {undefined}\n */\nfunction updateMultiWayModeHeapMap(map, itemNode) {\n  const { heapMap, depth, version } = map;\n  const key = itemNode.element.key;\n\n  if (!heapMap[key]) {\n    // Depth map.\n    heapMap[key] = new LinkedOrderedMap();\n  }\n  if (!heapMap[key].map[depth]) {\n    // This new linked ordered map functions as a stack.\n    heapMap[key].set(depth, new LinkedOrderedMap(), true);\n  }\n  const stack = heapMap[key].get(depth);\n\n  // Always prepend a new version. Indeed, \"stack\" here (which is a linked ordered map)\n  // acts like a stack data structure.\n  stack.set(version, itemNode, true);\n}\n\n/**\n * Lookups a node in a multiway mode map.\n *\n * @param {MultiwayModeImmutableLinkedOrderedMap} map The map.\n * @param {string|number} key The key to lookup.\n * @return {Object|undefined} The node in the heap map or undefined, if the value for that key is missing.\n */\nfunction lookupMultiwayMode(map, key) {\n  const { heapMap, depth, version } = map;\n\n  if (!heapMap[key]) {\n    return void 0;\n  }\n  const depthMap = heapMap[key];\n  let node = void 0;\n  depthMap.forEach((depthKey, v) => {\n    if (depth >= depthKey) {\n      v.forEach((stackVersion, possibleNode) => {\n        if (isAncestorVersionOfDescendantVersion(stackVersion, version)) {\n          node = possibleNode;\n          return false;\n        }\n      });\n      if (node) {\n        return false;\n      }\n    }\n  });\n  return nodeOrUndefined(node);\n}\n\n/**\n * Called when a map in multiway mode is forked.\n *\n * @param {ImmutableLinkedOrderedMap} ancestorMap Ancestor map.\n * @param {ImmutableLinkedOrderedMap} forkedMap The forked map.\n * @return {ImmutableLinkedOrderedMap} forkedMap The forked map.\n */\nfunction forkMultiwayModeMap(ancestorMap, forkedMap) {\n  forkedMap.version = !ancestorMap.version.length\n    ? `${++ancestorMap.childrenCount}${MULTIWAY_MODE_MAP_TREE_DEPTH_VERSION_SEPARATOR}`\n    : `${\n        ancestorMap.version\n      }${++ancestorMap.childrenCount}${MULTIWAY_MODE_MAP_TREE_DEPTH_VERSION_SEPARATOR}`;\n  return forkedMap;\n}\n\n/**\n * Tests if a version is an ancestor version of a descendant version (used internally for maps in multiway mode).\n *\n * @param {string} possibleAncestorVersion Possible ancestor version.\n * @param {string} descendantVersion Descendant version.\n * @return {boolean} True if the given possible ancestor version is in fact the ancestor version of the given descendant version,\n *                   false otherwise.\n */\nfunction isAncestorVersionOfDescendantVersion(\n  possibleAncestorVersion,\n  descendantVersion\n) {\n  return (\n    descendantVersion.substring(0, possibleAncestorVersion.length) ===\n    possibleAncestorVersion\n  );\n}\n\n/**\n * Multiway mode immutable linked ordered map.\n */\nclass MultiwayModeImmutableLinkedOrderedMap extends ImmutableLinkedOrderedMap {\n  /**\n   * Constructor.\n   *\n   * @constructor\n   *\n   * @param {Object} options Options.\n   */\n  constructor(options) {\n    const instance = super(options);\n\n    instance.childrenCount = 0;\n    return instance;\n  }\n}\n\n/* ======================================================================================================== */\n\n/**\n * Binds two nodes of a map in lightweight mode.\n *\n * @param {LightweightModeImmutableLinkedOrderedMap} map The map.\n * @param {Object} previousNode Previous node.\n * @param {Object} nextNode Next node.\n * @return {undefined}\n */\nfunction bindLightweightModeNodes(map, previousNode, nextNode) {\n  previousNode.next = nextNode;\n  nextNode.previous = previousNode;\n}\n\n/**\n * Lookups a node in a lightweight mode map.\n *\n * @param {LightweightModeImmutableLinkedOrderedMap} map The map.\n * @param {string|number} key The key to lookup.\n * @return {Object|undefined} The node in the heap map or undefined, if the value for that key is missing.\n */\nfunction lookupLightweightMode(map, key) {\n  const { heapMap } = map;\n  const node = heapMap[key];\n  return nodeOrUndefined(node);\n}\n\n/**\n * Updates a heap map shared structure (structural sharing) of a map in multiway mode.\n *\n * @param {LightweightModeImmutableLinkedOrderedMap} map The map which shared heap map should be updated.\n * @param {Object} itemNode The linked node of the item.\n * @return {undefined}\n */\nfunction updateLightweightModeHeapMap(map, itemNode) {\n  const { heapMap } = map;\n  const key = itemNode.element.key;\n  heapMap[key] = itemNode;\n}\n\n/**\n * Finds a previous or next node of a node in the context of an immutable linked ordered map\n * in lightweight mode.\n *\n * @param {LightweightModeImmutableLinkedOrderedMap} map The map.\n * @param {Object} fromNode From node.\n * @param {string} nextNodeDirection The direction, either \"previous\" or \"next\".\n * @return {Object|null} The previous node if it exists, or null if it doesn't (e.g. when called on a head node).\n */\nfunction findLightweightModeMapNodeByDirection(\n  map,\n  fromNode,\n  nextNodeDirection\n) {\n  return fromNode[nextNodeDirection];\n}\n\n/**\n * Makes a new node for an immutable linked ordered map in lightweight mode (used internally).\n *\n * @param {ImmutableLinkedOrderedMap} map The map.\n * @param {Object|null} previous Previous node or null if there isn't one.\n * @param {Object|null} next Next node or null if there isn't one.\n * @param {string|number} key The key of the mapped value.\n * @param {*} value The mapped value.\n * @return {Object} The node.\n */\nfunction makeLightweightModeImmutableLinkedOrderedMapNode(\n  map,\n  previous,\n  next,\n  key,\n  value\n) {\n  // \"map\" is not used in this function when we are in lightweight mode.\n  const node = makeNode(previous, next, {\n    key,\n    value,\n  });\n  return node;\n}\n\n/**\n * Throws an error for a second mutation operation on an immutable linkerd ordered map\n * in lightweight mode.\n *\n * @param {string} operation A string identifying the mutation operation.\n * @return {undefined}\n * @throws {Error}\n */\nfunction throwLightweightModeOperationAftermutationOperationOccurredError(\n  operation\n) {\n  throw new Error(\n    `ImmutableLinkedOrderedMap error: Operation \"${operation}\" is not allowed on a map in lightweight mode on which a mutation operation occurred once.`\n  );\n}\n\n/**\n * Lightweight mode immutable linked ordered map.\n */\nclass LightweightModeImmutableLinkedOrderedMap extends ImmutableLinkedOrderedMap {\n  /**\n   * Constructor.\n   *\n   * @constructor\n   *\n   * @param {Object} options Options.\n   */\n  constructor(options) {\n    const instance = super(options);\n\n    instance.mutationOperationOccurred = false;\n    return instance;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  set(items, prependMissing = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"set\");\n    const map = super.set(items, prependMissing);\n    if (this !== map) {\n      this.mutationOperationOccurred = true;\n    }\n    return map;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  replace(oldKey, item, addMissing = false, prependMissing = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\n        \"replace\"\n      );\n    const map = super.replace(oldKey, item, addMissing, prependMissing);\n    if (this !== map) {\n      this.mutationOperationOccurred = true;\n    }\n    return map;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  unset(key) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"unset\");\n    const map = super.unset(key);\n    if (this !== map) {\n      this.mutationOperationOccurred = true;\n    }\n    return map;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  empty() {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"empty\");\n    const map = super.empty();\n    if (this !== map) {\n      this.mutationOperationOccurred = true;\n    }\n    return map;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  get(key) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"get\");\n    return super.get(key);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  first() {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"first\");\n    return super.first();\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  last() {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"last\");\n    return super.last();\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  isEmpty() {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\n        \"isEmpty\"\n      );\n    return super.isEmpty();\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  forEach(fn, reversed = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\n        \"forEach\"\n      );\n    return super.forEach(fn, reversed);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  break() {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"break\");\n    return super.break();\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  values(reversed = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\n        \"values\"\n      );\n    return super.values(reversed);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  keys(reversed = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"keys\");\n    return super.keys(reversed);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  keysValues(reversed = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\n        \"keysValues\"\n      );\n    return super.keysValues(reversed);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  map(fn, reversed = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"map\");\n    return super.map(fn, reversed);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  reduce(fn, initialValue, reversed = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\n        \"reduce\"\n      );\n    return super.reduce(fn, initialValue, reversed);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  filter(fn, reversed = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\n        \"filter\"\n      );\n    return super.filter(fn, reversed);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  every(fn, reversed = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"every\");\n    return super.every(fn, reversed);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  some(fn, reversed = false) {\n    this.mutationOperationOccurred &&\n      throwLightweightModeOperationAftermutationOperationOccurredError(\"some\");\n    return super.some(fn, reversed);\n  }\n}\n\n/* ======================================================================================================== */\n\n/**\n * A mutable linked ordered map (used internally).\n *\n * @constructor\n */\nfunction LinkedOrderedMap() {\n  /**\n   * @property {Object} map An object used for fast key lookups.\n   */\n  this.map = {};\n\n  /**\n   * @property {LinkedList} keyValueList A list keeping the keys with the corresponding values in the order they were added while\n   *                                     adding them to this linked ordered map.\n   */\n  this.keyValueList = new LinkedList();\n\n  /**\n   * @property {Boolean} A boolean indicating whether the next \"forEach\" loop iteration should break.\n   */\n  this.shouldNextForEachBreak = false;\n}\n\n/**\n * Sets a value correlated with a key. If another value with the same key already exists,\n * it will be overwritten by the new value.\n *\n * @param {string|number} key A key used to lookup the value subsequently.\n * @param {*} value Anything The value to set.\n * @param {boolean} prepend By default, this method appends a new element to the linked list.\n *                          If set to \"true\", new elements will be prepended.\n * @return {undefined}\n */\nLinkedOrderedMap.prototype.set = function (key, value, prepend = false) {\n  if (key in this.map) {\n    // key already exists, replace value.\n    this.map[key].element.value = value;\n  } else {\n    // Insert new key and value.\n    const appendOrPrepend = prepend ? \"prepend\" : \"append\";\n    const node = this.keyValueList[appendOrPrepend]({ key, value }); // Keys are needed here too if we want to loop through them within a \"forEach\" loop.\n    this.map[key] = node; // The map will reference the node containing the key and the corresponding value.\n  }\n};\n\n/**\n * Removes an element from the map.\n *\n * @param {string|number} key The key of the element to remove.\n * @return {undefined}\n * @throws {Error} If the given key does not exist.\n */\nLinkedOrderedMap.prototype.remove = function (key) {\n  if (key in this.map) {\n    this.keyValueList.remove(this.map[key]); // Removing the node from the underlying linked list.\n    delete this.map[key]; // Removing the key from the underlying map.\n  } else {\n    throw new Error(\"key does not exist\");\n  }\n};\n\n/**\n * Empties this map.\n *\n * @return {undefined}\n */\nLinkedOrderedMap.prototype.empty = function () {\n  this.map = {};\n  this.keyValueList = new LinkedList();\n  this.shouldNextForEachBreak = false;\n};\n\n/**\n * Tests whether this map is empty.\n *\n * @return {boolean} True if empty, false otherwise.\n */\nLinkedOrderedMap.prototype.isEmpty = function () {\n  return this.getLength() <= 0;\n};\n\n/**\n * Retrieves a map value.\n *\n * @param {string|number} key The key.\n * @param {boolean} [returnWholeNode] True to return the whole node of the internal linked list,\n *                                    otherwise, returns just the value.\n * @return {*} The value correlated with the specified key or undefined if no value exists for that key.\n *             If \"returnWholeNode\" is \"true\", returns the whole node of the internal linked list.\n */\nLinkedOrderedMap.prototype.get = function (key, returnWholeNode = false) {\n  return (\n    this.map[key] &&\n    (returnWholeNode ? this.map[key] : this.map[key].element.value)\n  );\n};\n\n/**\n * Loop through the elements in the order they were added.\n *\n * @param {Function} f A callback to call for each value stored in the map. The callback will receive the key as the first argument\n *                     and the value as the second argument.\n * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n *                             from the tail node). The default is to loop through all the elements starting\n *                             from the head node.\n * @return {undefined}\n */\nLinkedOrderedMap.prototype.forEach = function (f, reversed = false) {\n  let key, value;\n  this.shouldNextForEachBreak = false;\n  // eslint-disable-next-line @typescript-eslint/no-this-alias\n  const thisMap = this;\n  this.keyValueList.forEach(function (i, element) {\n    if (!this.shouldNextForEachBreak) {\n      key = element.key;\n      value = element.value;\n      const result = f.call(thisMap, key, value);\n      if (result === false) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }, reversed);\n};\n\n/**\n * Break the next \"forEach\" loop iteration occurring on this linked ordered map.\n *\n * @return {undefined}\n */\nLinkedOrderedMap.prototype.break = function () {\n  this.shouldNextForEachBreak = true;\n};\n\n/**\n * Gets the length of the map, i.e. the number of key value pairs in it.\n *\n * @return {Number} The number of key value pairs stored in this map.\n */\nLinkedOrderedMap.prototype.getLength = function () {\n  return this.keyValueList.length;\n};\n\n/**\n * Returns an array containing the values of this ordered map in the order they were added originally.\n *\n * @return {Array<Anything>} An array containing the values stored in the map.\n */\nLinkedOrderedMap.prototype.toArray = function () {\n  const array = new Array(this.getLength());\n  let i = 0;\n  this.forEach(function (key, value) {\n    array[i] = value;\n    i++;\n  });\n  return array;\n};\n\n/**\n * Returns the keys of this ordered map in the order their corresponding values were added to this map.\n *\n * @return {Array<Number|String>} An array containing the keys of this ordered map.\n */\nLinkedOrderedMap.prototype.keys = function () {\n  const array = new Array(this.getLength());\n  let i = 0;\n  this.forEach(function (key) {\n    array[i] = key;\n    i++;\n  });\n  return array;\n};\n\n/**\n * Static method that creates a new map from an existent array of items.\n * Each item must have a property identified by the \"key\" parameter.\n *\n * @param {Array} array\n * @param {string|number} key\n * @return {LinkedOrderedMap}\n */\nLinkedOrderedMap.fromArray = function (array, key) {\n  const map = new LinkedOrderedMap();\n  for (let i = 0; i < array.length; i++) {\n    const item = array[i];\n    map.set(item[key], item);\n  }\n  return map;\n};\n\n/* ======================================================================================================== */\n\n/**\n * A mutable linked list (used internally).\n *\n * @constructor\n */\nfunction LinkedList() {\n  /**\n   * @property {Object} head The head node of this linked list.\n   */\n  this.head = null;\n\n  /**\n   * @property {Object} tail The tail node of this linked list.\n   */\n  this.tail = null;\n\n  /**\n   * @property {Number} length The length of this linked list\n   */\n  this.length = 0;\n\n  /**\n   * @property {Boolean} shouldNextForEachBreak A boolean indicating whether the next \"forEach\" loop iteration should break.\n   */\n  this.shouldNextForEachBreak = false;\n}\n\n/**\n * Adds an element to the tail of this linked list. After this method is called,\n * the tail node will reference an object containing the added element.\n *\n * @param {*} anything Anything to add to this linked list.\n * @return {Object} A reference to the new added node object of this linked list.\n */\nLinkedList.prototype.append = function (anything) {\n  this.length++;\n\n  if (this.head) {\n    const oldTail = this.tail;\n    this.tail = makeNode(oldTail, null, anything);\n    oldTail.next = this.tail;\n  } else {\n    this.tail = makeNode(null, null, anything);\n    this.head = this.tail;\n  }\n  return this.tail;\n};\n\n/**\n * Adds an element to the head of this linked list. After this method is called,\n * the head of this linked list will reference an object containing the added element.\n *\n * @param {*} anything Anything to add to this linked list.\n * @return {Object} A reference to the new added node object of this linked list.\n */\nLinkedList.prototype.prepend = function (anything) {\n  this.length++;\n\n  if (this.head) {\n    const oldHead = this.head;\n    this.head = makeNode(null, oldHead, anything);\n    oldHead.previous = this.head;\n  } else {\n    this.tail = makeNode(null, null, anything);\n    this.head = this.tail;\n  }\n  return this.head;\n};\n\n/**\n * Removes a node from this linked list.\n *\n * @param {Object} node The node to remove (not the element added, but the object\n *                      \"{ next : nextNode, previous : previousNode, element : anything }\"\n *                      previously created when adding the element to this linked list.\n * @return {LinkeList} A reference to this linked list.\n */\nLinkedList.prototype.remove = function (node) {\n  if (node !== null) {\n    if (node.previous) {\n      node.previous.next = node.next;\n      if (node.next) {\n        node.next.previous = node.previous;\n      } else {\n        this.tail = node.previous;\n      }\n      this.length--;\n    } else if (node.next) {\n      this.head = node.next;\n      this.head.previous = null;\n      this.length--;\n    } else {\n      this.head = null;\n      this.tail = null;\n      this.length = 0;\n    }\n    node = null;\n  }\n};\n\n/**\n * Removes the last element from the list (the element of the tail node) and returns it.\n *\n * @return {*} The element of the tail node of this linked list.\n */\nLinkedList.prototype.pop = function () {\n  if (this.tail) {\n    const element = this.tail.element;\n    this.remove(this.tail);\n    return element;\n  }\n};\n\n/**\n * Removes the first element from the list (the element of the tail node) and returns it.\n *\n * @return {*} The element of the head node of this linked list.\n */\nLinkedList.prototype.shift = function () {\n  if (this.head) {\n    const element = this.head.element;\n    this.remove(this.head);\n    return element;\n  }\n};\n\n/**\n * Loops on this linked list.\n *\n * @param {Function} fn A function which will be called for each element in this linked list:\n *\n *                          fn(Number i, Anything element)\n *\n *                      The function will receive two parameters:\n *                      - the first parameter will be the index of the element (starting from 0 and incrementing by 1\n *                        if the parameter \"reversed\" is false, or from the length of this linked list minus 1\n *                        and decrementing by 1 if the parameter \"reversed\" is true)\n *                      - the second parameter will be the nth element of the list.\n *\n *                      Within the function body, this will point to the linked list instance and \"this.break()\" can be\n *                      called to stop the next iteration.\n *                      Otherwise, if the function returns false, the loop will stop immediately.\n * @param {boolean} [reversed] An optional boolean indicating whether to loop in reverse order (starting\n *                             from the tail node). The default is to loop through all the elements starting\n *                             from the head node.\n * @return {undefined}\n */\nLinkedList.prototype.forEach = function (fn, reversed = false) {\n  let current, nextNodeDirection, i, updateIndexFn;\n  this.shouldNextForEachBreak = false;\n  if (reversed) {\n    i = this.length - 1;\n    current = this.tail;\n    nextNodeDirection = \"previous\";\n    updateIndexFn = function () {\n      i--;\n    };\n  } else {\n    i = 0;\n    current = this.head;\n    nextNodeDirection = \"next\";\n    updateIndexFn = function () {\n      i++;\n    };\n  }\n\n  while (current) {\n    if (!this.shouldNextForEachBreak) {\n      const element = current.element;\n      const result = fn.call(this, i, element);\n      if (result === false) {\n        break;\n      }\n      current = current[nextNodeDirection];\n      updateIndexFn();\n    } else {\n      break;\n    }\n  }\n};\n\n/**\n * Breaks the next \"forEach\" loop iteration occurring on this linked list.\n *\n * @return {undefined}\n */\nLinkedList.prototype.break = function () {\n  this.shouldNextForEachBreak = true;\n};\n\n/* ======================================================================================================== */\n\n/**\n * @type {Object}\n */\nconst ImmutableLinkedOrderedMapForMode = {\n  [ImmutableLinkedOrderedMapMode.SINGLE]: {\n    ImmutableLinkedOrderedMapClass: SingleModeImmutableLinkedOrderedMap,\n    lookup: lookupSingleMode,\n    updateHeapMap: updateSingleModeHeapMap,\n    findMapNodeByDirection: findSingleModeMapNodeByDirection,\n    makeImmutableLinkedOrderedMapNode: makeSingleModeImmutableLinkedOrderedMapNode,\n    bindNodes: bindSingleModeNodes,\n  },\n  [ImmutableLinkedOrderedMapMode.MULTIWAY]: {\n    ImmutableLinkedOrderedMapClass: MultiwayModeImmutableLinkedOrderedMap,\n    hydrate: hydrateMultiwayMode,\n    lookup: lookupMultiwayMode,\n    fork: forkMultiwayModeMap,\n    updateHeapMap: updateMultiWayModeHeapMap,\n    findMapNodeByDirection: findMultiwayModeMapNodeByDirection,\n    makeImmutableLinkedOrderedMapNode: makeMultiwayModeImmutableLinkedOrderedMapNode,\n    bindNodes: bindMultiwayModeNodes,\n  },\n  [ImmutableLinkedOrderedMapMode.LIGHTWEIGHT]: {\n    ImmutableLinkedOrderedMapClass: LightweightModeImmutableLinkedOrderedMap,\n    lookup: lookupLightweightMode,\n    updateHeapMap: updateLightweightModeHeapMap,\n    findMapNodeByDirection: findLightweightModeMapNodeByDirection,\n    makeImmutableLinkedOrderedMapNode: makeLightweightModeImmutableLinkedOrderedMapNode,\n    bindNodes: bindLightweightModeNodes,\n  },\n};\n\nImmutableLinkedOrderedMap.MODE = ImmutableLinkedOrderedMapMode;\nImmutableLinkedOrderedMap.isMap = value =>\n  !!(value && value[MAP_TAG] === MAP_TAG_VALUE);\nexport { ImmutableLinkedOrderedMap, ImmutableLinkedOrderedMapMode };\n/* ======================================================================================================== */\n","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @type {string}\n */\nexport const DEFAULT_KEY_PROP_NAME = \"id\";\n","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport { map } from \"./map\";\n\n/**\n * Shortcut function to create a lazy immutable linked ordered map.\n *\n * @param {Object} options Options.\n * @return {ImmutableLinkedOrderedMap} A new lazy immutable linked ordered map for the given options.\n */\nexport const lazyMap = (options = {}) =>\n  map({\n    ...options,\n    lazy: true,\n  });\n","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport { lazyMap } from \"./lazyMap\";\nimport { DEFAULT_KEY_PROP_NAME } from \"../constants\";\n\n/**\n * Shortcut function returning a factory function to create a lazy map for a given key property name \"keyPropName\".\n *\n * Example:\n *\n * ```\n * const mapFactory = lazyMapFactory(\"item_id\");\n *\n * let map = mapFactory([{item_id: 1, prop: \"a\"}, {item_id: 2, prop: \"b\"}, {item_id: 3, prop: \"c\"}]);\n *\n * map.get(1); // {item_id: 1, prop: \"a\"}\n *\n * map = map.set({item_id: 4, prop: \"d\"}); // Append\n * //map = map.set({item_id: 4, prop: \"d\"}, true); // Prepend\n *\n * map.get(4); // {item_id: 4, prop: \"d\"}\n *\n * map.get(5); // undefined\n *\n * map = map.unset(4);\n * map.get(4); // undefined\n * ```\n *\n * @param {string} keyPropName The key property name to use for the items in the map that will be created by the returned factory function.\n * @return {(initialItems: Array) => ImmutableLinkedOrderedMap} A factory function to create a lazy map for the given property name \"keyPropName\".\n */\nexport const lazyMapFactory = (keyPropName = DEFAULT_KEY_PROP_NAME) => (\n  initialItems = []\n) =>\n  lazyMap({\n    keyPropName,\n    initialItems,\n  });\n","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport { ImmutableLinkedOrderedMap } from \"../ImmutableLinkedOrderedMap\";\n\n/**\n * Shortcut function to create an immutable linked ordered map.\n *\n * @param {Object} options Options.\n * @return {ImmutableLinkedOrderedMap} A new immutable linked ordered map for the given options.\n */\nexport const map = (options = {}) =>\n  new ImmutableLinkedOrderedMap({\n    ...options,\n  });\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\n * Copyright (c) 2021 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport {\n  ImmutableLinkedOrderedMap,\n  ImmutableLinkedOrderedMapMode,\n} from \"./ImmutableLinkedOrderedMap\";\nimport { lazyMap } from \"./shortcuts/lazyMap\";\nimport { map } from \"./shortcuts/map\";\nimport { lazyMapFactory } from \"./shortcuts/lazyMapFactory\";\n\n[\n  [\"lazyMap\", lazyMap],\n  [\"map\", map],\n  [\"lazyMapFactory\", lazyMapFactory],\n].map(([key, value]) => (ImmutableLinkedOrderedMap[key] = value));\nexport {\n  ImmutableLinkedOrderedMap as default,\n  ImmutableLinkedOrderedMapMode,\n  lazyMap,\n  lazyMapFactory,\n};\n"],"names":[],"sourceRoot":""}