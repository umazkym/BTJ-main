!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("ImmutableLinkedOrderedMap",[],t):"object"==typeof exports?exports.ImmutableLinkedOrderedMap=t():e.ImmutableLinkedOrderedMap=t()}(this,(function(){return(()=>{"use strict";var e={660:e=>{const t=/[|\\{}()[\]^$+*?.-]/g;e.exports=e=>{if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(t,"\\$&")}}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var n={};return(()=>{r.d(n,{default:()=>be});Object.prototype.hasOwnProperty;Object.prototype.toString.call({});function e(e){return Object.prototype.toString.call(e)===Object.prototype.toString.call([])}Symbol("treeMapSubtree");function t(e){return void 0===e}!function(){let e=0}();const o=e=>Boolean("function"==typeof e?e():e);function i(t){return(()=>{let r=0;for(;r<t.length-1;r++){const e=t[r],[n,i]=e;if(o(n))return i}const n=t[r];if(e(n)&&2===n.length){const[e,t]=n;return o(e)?t:void 0}return n})()}const s=function*(e){const t=Reflect.ownKeys(e);for(const r of t){const t=e[r];yield{rule:r,pointcut:t}}},a=function*(t){for(const r of t)if(e(r)){const[e,t]=r;yield{rule:e,pointcut:t}}else yield*s(r)};class u{}class c extends u{constructor(e){super(),this.rules=e}matches(e){for(const t of this.rules)if(t.matches(e))return!0;return!1}}class l extends u{constructor(e){super(),this.regex=new RegExp(e)}matches(e){return this.regex.lastIndex=0,"symbol"!=typeof e&&this.regex.test(e)}}class d extends u{constructor(e){super(),this.property=e}matches(e){return this.property===e}}const p=e=>new l(e),h=e=>new d(e),f=e=>{let t=e;return i([[()=>e instanceof RegExp,p],[()=>{if("string"!=typeof e)return!1;const r=e.indexOf("/"),n=e.lastIndexOf("/");if(0===r&&n>0){const r=e.substring(1,n),o=e.substring(n+1)||void 0;return t=new RegExp(r,o),!0}return!1},p],h])(t)},m=e=>{const t=[];for(const r of e){const e=f(r);t.push(e)}return new c(t)};function y(t){return i([[e(t),m],f])(t)}class x{constructor(){var e,t,r;r=[],(t="advices")in(e=this)?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r}}class v{constructor(e){this.fn=e}}class g extends v{}class b extends v{}class O extends v{}class k extends x{before(e){return this.advices.push(new g(e)),this}after(e){return this.advices.push(new b(e)),this}around(e){return this.advices.push(new O(e)),this}}class A extends x{before(e){return this.advices.push(new g(e)),this}after(e){return this.advices.push(new b(e)),this}around(e){return this.advices.push(new O(e)),this}}class w extends x{before(e){return this.advices.push(new g(e)),this}after(e){return this.advices.push(new b(e)),this}around(e){return this.advices.push(new O(e)),this}}class M extends x{before(e){return this.advices.push(new g(e)),this}after(e){return this.advices.push(new b(e)),this}around(e){return this.advices.push(new O(e)),this}}class N extends x{before(e){return this.advices.push(new g(e)),this}after(e){return this.advices.push(new b(e)),this}around(e){return this.advices.push(new O(e)),this}}const E=Symbol("applyRule"),C=Symbol("constructRule");function P(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const I=Symbol("noReturnValue");class D{constructor(){P(this,"execContextStack",[]),P(this,"execContextID",-1)}execute(e,t,r,n){this.newExecutionContext(),this.setUpExecutionContext(t,r),this.startExecutionContext(e),this.beforePhase(e,t),this.aroundPhase(e,r);const o=this.proceedPhase(e);return this.afterPhase(e,n,o),this.endExecutionContext(e),this.cleanUpExecutionContext(),o}newExecutionContext(){const e={proceeds:[],hasAtLeastOneAroundAdvice:!1,hasAtLeastOneBeforeAdvice:!1,returnValue:I};this.execContextStack.push(e),this.execContextID++}setUpExecutionContext(e,t){this.execContextStack[this.execContextID].hasAtLeastOneBeforeAdvice=!!e.length,this.execContextStack[this.execContextID].hasAtLeastOneAroundAdvice=!!t.length}startExecutionContext(e){}endExecutionContext(e){}cleanUpExecutionContext(){this.execContextStack.pop(),this.execContextID--}unsupportedMultipleProceeds(e,t){console.error("pigretto - Multiple proceeds for the same advice are not supported, subsequent proceed has been ignored.","\n\tadvice: ",e,"\n\trule: ",t)}executeBeforeAdvice(e,t,r){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeBeforeAdvice".`)}executeAroundAdvice(e,t,r,n){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeAroundAdvice".`)}executeAfterAdvice(e,t,r,n){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeAfterAdvice".`)}performUnderlyingOperation(e){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "performUnderlyingOperation".`)}executeProceedCallback(e,t,r,n){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeProceedCallback".`)}beforePhase(e,t){for(const{rule:r,advice:n}of t)this.executeBefore(e,n,r)}executeBefore(e,t,r){this.executeBeforeAdvice(e,t,r)}aroundPhase(e,t){for(const{rule:r,advice:n}of t)if(this.executeAround(e,n,r),this.execContextStack[this.execContextID].returnValue!==I)break}executeAround(t,r,n){let o=!1;const i=this.executeAroundAdvice(t,r,n,(t,i)=>{if(o)return void this.unsupportedMultipleProceeds(r,n);o=!0;let s=void 0,a=void 0;e(t)?(s=t,a="function"==typeof i?i:void 0):"function"==typeof t&&(a=t),this.execContextStack[this.execContextID].proceeds.push({params:s,fn:a,rule:n})});o||(this.execContextStack[this.execContextID].returnValue=i)}afterPhase(e,t,r){for(const{rule:n,advice:o}of t)this.executeAfter(e,o,n,r)}executeAfter(e,t,r,n){this.executeAfterAdvice(e,t,r,n)}proceedPhase(e){if(this.execContextStack[this.execContextID].returnValue!==I)return this.return(e,this.execContextStack[this.execContextID].returnValue);let t=this.performUnderlyingOperation(e);for(const{fn:r,rule:n}of this.execContextStack[this.execContextID].proceeds)"function"==typeof r&&(t=this.executeProceedCallback(e,n,t,r));return this.return(e,t)}return(e,t){return t}}const L=(e,t,r)=>{if("function"!=typeof e[t])throw new Error(`pigretto - ${r.name} trap executor does not implement "${t}".`)};function B(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const S=r=>{const n=class extends r{constructor(...e){super(...e),B(this,"executedAtLeastOnce",!1),B(this,"lastProceedWithParamsIndexMap",{}),B(this,"finalTrapArgsMap",{})}startExecutionContext(e){if(!this.executedAtLeastOnce&&L(r.prototype,"startExecutionContext",r),super.startExecutionContext(e),!this.executedAtLeastOnce&&!Object.prototype.hasOwnProperty.call(this,"execContextID"))throw new Error(`pigretto - ${r.name} trap executor does not have "execContextID" property.`);this.lastProceedWithParamsIndexMap[this.execContextID]=-1,this.finalTrapArgsMap[this.execContextID]=void 0}endExecutionContext(e){!this.executedAtLeastOnce&&L(r.prototype,"endExecutionContext",r),super.endExecutionContext(e),this.finalTrapArgsMap[this.execContextID]=void 0,this.executedAtLeastOnce=!0}getFinalTrapArgs(n){!this.executedAtLeastOnce&&L(this,"getTrapArgsArgumentsListIndex",r);const o=this.getTrapArgsArgumentsListIndex();if(!this.executedAtLeastOnce&&!Object.prototype.hasOwnProperty.call(this,"execContextStack"))throw new Error(`pigretto - ${r.name} trap executor does not have "execContextStack" property.`);const i=this.execContextStack[this.execContextID].proceeds.length;if(i){let t=!1;for(let r=i-1;r>this.lastProceedWithParamsIndexMap[this.execContextID];r--){const{params:i}=this.execContextStack[this.execContextID].proceeds[r];if(e(i)){t=!0,this.lastProceedWithParamsIndexMap[this.execContextID]=r,(n=[...n])[o]=i,this.finalTrapArgsMap[this.execContextID]=n;break}}t||(this.lastProceedWithParamsIndexMap[this.execContextID]=i-1)}return t(this.finalTrapArgsMap[this.execContextID])?n:this.finalTrapArgsMap[this.execContextID]}executeAroundAdvice(e,t,n,o){return e=this.getFinalTrapArgs(e),!this.executedAtLeastOnce&&L(r.prototype,"executeAroundAdvice",r),super.executeAroundAdvice(e,t,n,o)}executeAfterAdvice(e,t,n,o){e=this.getFinalTrapArgs(e),!this.executedAtLeastOnce&&L(r.prototype,"executeAfterAdvice",r),super.executeAfterAdvice(e,t,n,o)}performUnderlyingOperation(e){return e=this.getFinalTrapArgs(e),!this.executedAtLeastOnce&&L(r.prototype,"performUnderlyingOperation",r),super.performUnderlyingOperation(e)}executeProceedCallback(e,t,n,o){return e=this.getFinalTrapArgs(e),!this.executedAtLeastOnce&&L(r.prototype,"executeProceedCallback",r),super.executeProceedCallback(e,t,n,o)}};return Object.defineProperty(n,"name",{value:`WithFunctionTrapExecutor(${r.name})`,configurable:!0}),n},T=S(class extends D{getTrapArgsArgumentsListIndex(){return 4}execute([e,t,r,n],o,i,s){if("function"==typeof n&&[o,i,s].some(e=>{return!(!(t=e)||0===t.length);var t})){const a=e=>super.execute(e,o,i,s);return function(...o){let i;i=this!==r?this:e,n=n.bind(i);return a([e,t,r,n,o])}}return n}executeBeforeAdvice([e,t,r,,n],o,i){const s={target:e,property:t,receiver:r,rule:i};o.fn.apply(s,n)}executeAroundAdvice([e,t,r,,n],o,i,s){const a={target:e,property:t,receiver:r,rule:i};return o.fn.call(a,s).apply(a,n)}executeAfterAdvice([e,t,r,,n],o,i,s){const a={target:e,property:t,receiver:r,rule:i};o.fn.call(a,...n).apply(a,[s])}performUnderlyingOperation([,,,e,t]){return e(...t)}executeProceedCallback([e,t,r,,n],o,i,s){const a={target:e,property:t,receiver:r,rule:o,argumentsList:n};return s.apply(a,[i])}});function j(e,t,r){return Reflect.get(e,t,r)}class V extends D{executeBeforeAdvice([e,t,r],n,o){const i={target:e,property:t,receiver:r,rule:o};n.fn.apply(i)}executeAroundAdvice([e,t,r],n,o,i){const s={target:e,property:t,receiver:r,rule:o};return n.fn.apply(s,[i])}executeAfterAdvice([e,t,r],n,o,i){const s={target:e,property:t,receiver:r,rule:o};n.fn.apply(s,[i])}performUnderlyingOperation([e,t,r]){return j(e,t,r)}executeProceedCallback([e,t,r],n,o,i){const s={target:e,property:t,receiver:r,rule:n};return i.apply(s,[o])}}function F(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class U extends D{constructor(...e){super(...e),F(this,"previousPropertyValueMap",{}),F(this,"returnNewPropertyValueMap",{}),F(this,"updateWasSuccessfulMap",{})}startExecutionContext([e,t,,r]){if(!Object.prototype.hasOwnProperty.call(this.previousPropertyValueMap,this.execContextID)){const n=j(e,t,r);this.previousPropertyValueMap[this.execContextID]=n,this.returnNewPropertyValueMap[this.execContextID]=void 0,this.updateWasSuccessfulMap[this.execContextID]=!1}}endExecutionContext([,,,]){delete this.previousPropertyValueMap[this.execContextID],delete this.returnNewPropertyValueMap[this.execContextID],delete this.updateWasSuccessfulMap[this.execContextID]}executeBeforeAdvice([e,t,r,n],o,i){const s=this.previousPropertyValueMap[this.execContextID],a={target:e,property:t,value:r,receiver:n,rule:i};o.fn.apply(a,[s])}executeAroundAdvice([e,t,r,n],o,i,s){const a=this.previousPropertyValueMap[this.execContextID],u={target:e,property:t,value:r,receiver:n,rule:i};return o.fn.call(u,s).apply(u,[a])}executeAfterAdvice([e,t,r,n],o,i,s){const a=this.previousPropertyValueMap[this.execContextID],u=this.returnNewPropertyValueMap[this.execContextID],c={target:e,property:t,value:r,receiver:n,rule:i,updateWasSuccessful:s};o.fn.call(c,a).apply(c,[u])}performUnderlyingOperation([e,t,r,n]){const o=function(e,t,r,n){return Reflect.set(e,t,r,n)}(e,t,r,n);return this.updateWasSuccessfulMap[this.execContextID]=o,this.returnNewPropertyValueMap[this.execContextID]=r,r}executeProceedCallback([e,t,r,n],o,i,s){const a={target:e,property:t,value:r,receiver:n,rule:o};return s.apply(a,[i])}return([e,t,,r],n){return n!==this.returnNewPropertyValueMap[this.execContextID]&&this.performUnderlyingOperation([e,t,n,r]),this.updateWasSuccessfulMap[this.execContextID]}}const W=S(class extends D{getTrapArgsArgumentsListIndex(){return 2}executeBeforeAdvice([e,t,r],n,o){const i={target:e,thisArg:t,rule:o};n.fn.apply(i,r)}executeAroundAdvice([e,t,r],n,o,i){const s={target:e,thisArg:t,rule:o};return n.fn.call(s,i).apply(s,r)}executeAfterAdvice([e,t,r],n,o,i){const s={target:e,thisArg:t,rule:o};n.fn.call(s,...r).apply(s,[i])}performUnderlyingOperation([e,t,r]){return function(e,t,r){return Reflect.apply(e,t,r)}(e,t,r)}executeProceedCallback([e,t,r],n,o,i){const s={target:e,thisArg:t,rule:n,argumentsList:r};return i.apply(s,[o])}});const $=S(class extends D{getTrapArgsArgumentsListIndex(){return 1}executeBeforeAdvice([e,t,r],n,o){const i={target:e,newTarget:r,rule:o};n.fn.apply(i,t)}executeAroundAdvice([e,t,r],n,o,i){const s={target:e,newTarget:r,rule:o};return n.fn.call(s,i).apply(s,t)}executeAfterAdvice([e,t,r],n,o,i){const s={target:e,newTarget:r,rule:o};n.fn.call(s,...t).apply(s,[i])}performUnderlyingOperation([e,t,r]){return function(e,t,r){return r?Reflect.construct(e,t,r):new e(...t)}(e,t,r)}executeProceedCallback([e,t,r],n,o,i){const s={target:e,newTarget:r,rule:n,argumentsList:t};return i.apply(s,[o])}});function H(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class R{constructor(){H(this,"advices",{call:[],get:[],set:[],apply:[],construct:[]}),H(this,"distributedAdvices",{call:{before:void 0,around:void 0,after:void 0},get:{before:void 0,around:void 0,after:void 0},set:{before:void 0,around:void 0,after:void 0},apply:{before:void 0,around:void 0,after:void 0},construct:{before:void 0,around:void 0,after:void 0}}),H(this,"matchedDistributedAdvices",{call:new Map,get:new Map,set:new Map}),H(this,"trapExecutors",{call:new T,get:new V,set:new U,apply:new W,construct:new $})}hasAtLeastOneAdviceOfPointcutType(e){return!!this.advices[e].length}addAdvices(e,t,r=[]){r.map(r=>this.advices[e].push({rule:t,advice:r}))}lazilyDistributeAdvices(e){if(t(this.distributedAdvices[e].before)){this.distributedAdvices[e].before=[],this.distributedAdvices[e].around=[],this.distributedAdvices[e].after=[];for(const{rule:t,advice:r}of this.advices[e]){const n=i([[()=>r instanceof g,"before"],[()=>r instanceof O,"around"],"after"]);this.distributedAdvices[e][n].push({rule:t,advice:r})}}}lazilyMatchAdvices(e,t){this.lazilyDistributeAdvices(e);const r=this.matchedDistributedAdvices[e];if(!r.has(t)){const n={before:[],around:[],after:[]};r.set(t,n);const o=this.distributedAdvices[e].before,i=this.distributedAdvices[e].around,s=this.distributedAdvices[e].after,a=e=>r=>{for(const{rule:o,advice:i}of e){o.matches(t)&&n[r].push({rule:o,advice:i})}};a(o)("before"),a(i)("around"),a(s)("after")}}addPointcutRule(e,t){const r=()=>"function"==typeof e&&t instanceof d,n=i([[()=>e instanceof k,"call"],[()=>e instanceof A,"get"],[()=>e instanceof w,"set"],[()=>{const n=r()&&t.property===E;return!!(n||e instanceof M)&&(n&&(e=(new M).before(e)),!0)},"apply"],[()=>{const n=r()&&t.property===C;return!!(n||e instanceof N)&&(n&&(e=(new N).before(e)),!0)},"construct"]]);if(n){const{advices:r}=e;this.addAdvices(n,t,r)}return this}hasGets(){return this.hasAtLeastOneAdviceOfPointcutType("call")||this.hasAtLeastOneAdviceOfPointcutType("get")}hasSets(){return this.hasAtLeastOneAdviceOfPointcutType("set")}hasApplies(){return this.hasAtLeastOneAdviceOfPointcutType("apply")}hasConstructs(){return this.hasAtLeastOneAdviceOfPointcutType("construct")}get(e,t,r){this.lazilyMatchAdvices("get",t),this.lazilyMatchAdvices("call",t);const{before:n,around:o,after:i}=this.matchedDistributedAdvices.get.get(t),s=this.trapExecutors.get.execute([e,t,r],n,o,i),{before:a,around:u,after:c}=this.matchedDistributedAdvices.call.get(t);return this.trapExecutors.call.execute([e,t,r,s],a,u,c)}set(e,t,r,n){this.lazilyMatchAdvices("set",t);const{before:o,around:i,after:s}=this.matchedDistributedAdvices.set.get(t);return this.trapExecutors.set.execute([e,t,r,n],o,i,s)}apply(e,t,r){this.lazilyDistributeAdvices("apply");const{before:n,around:o,after:i}=this.distributedAdvices.apply;return this.trapExecutors.apply.execute([e,t,r],n,o,i)}construct(e,t,r){this.lazilyDistributeAdvices("construct");const{before:n,around:o,after:i}=this.distributedAdvices.construct;return this.trapExecutors.construct.execute([e,t,r],n,o,i)}}function z(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function K(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?z(Object(r),!0).forEach((function(t){G(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):z(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function G(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function J(t){const r=new R,n=function*(t){const r=i([[e(t),a],s]);yield*r(t)}(t);for(const{rule:e,pointcut:t}of n){const n=y(e);r.addPointcutRule(t,n)}return K(K(K(K({},r.hasGets()?{get:(e,t,n)=>r.get(e,t,n)}:{}),r.hasSets()?{set:(e,t,n,o)=>r.set(e,t,n,o)}:{}),r.hasApplies()?{apply:(e,t,n)=>r.apply(e,t,n)}:{}),r.hasConstructs()?{construct:(e,t,n)=>r.construct(e,t,n)}:{})}function Y(e,t){const r=function(e){return J(e)}(t);return new Proxy(e,r)}function Q(){return new k}function _(){return new w}function q(){return new A}var X=r(660),Z=r.n(X);const ee=(e={})=>new be({...e}),te=(e={})=>ee({...e,lazy:!0}),re=(e="id")=>(t=[])=>te({keyPropName:e,initialItems:t}),ne="ImmutableLinkedOrderedMapEWoFkvQyQsM32wK4a5Kd",oe={SINGLE:1,MULTIWAY:2,LIGHTWEIGHT:3},ie=oe.MULTIWAY;function se({initialItems:e=[],keyPropName:t="id",mode:r=ie,lazy:n=!1}={}){let o=ae(r=Ne[r]&&r||(r=ie));return le.call(o,{keyPropName:t,mode:r}),n?o=function(e,t=[]){e.length=t.length;return function(e,{onceCallback:t,ignoredTypes:r=[Object],interceptConstructor:n=!1,propertiesToIgnore:o=[],pointcuts:i=[Q,q,_]}={}){let s=!1,a=!1,u=!1;const c=[],l={},d=r.map(e=>e.prototype.constructor);let p=e,h=!1;for(;p;){const t=p.constructor;if(!h||!d.includes(t)){Reflect.ownKeys(p).map(t=>l[t]={isMethod:"constructor"!==t&&"function"==typeof e[t]})}p=Object.getPrototypeOf(p),h=!0}o.map(e=>delete l[e]),!n&&delete l.constructor,i.map(e=>{e===Q?s=!0:e===q?a=!0:e===_&&(u=!0)});const f=Object.keys(l);let m=!0;const y=function(...e){m&&(m=!1,t.apply(this,e))},x=e=>e.map(Z()),v=e=>new RegExp(`^(${e.join("|")})$`),g=e=>t=>c.push([e,t().before(y)]);if(s){g(v(x(f.filter(e=>l[e].isMethod))))(Q)}if(a||u){const e=x(f.filter(e=>!l[e].isMethod));a&&g(v(e))(q),u&&g(v(e))(_)}return Y(e,c)}(e,{onceCallback:()=>{e.length=0,he(e,t)}})}(o,e):he(o,e),o}function ae(e){return new(0,Ne[e].ImmutableLinkedOrderedMapClass)}function ue(e,t,r,n){const o={};o[t]={get:r,set:n},Object.defineProperties(e,o)}function ce(e,t,r){return{previous:e,next:t,element:r}}function le({keyPropName:e,mode:t}){de.call(this,{heapMap:{},depth:0,length:0,keyPropName:e,mode:t});const r=Ne[t].hydrate;r&&r.call(this)}function de({heapMap:e,depth:t,length:r,keyPropName:n,mode:o,head:i,tail:s,ancestorMap:a}={}){ue(this,"heapMap",()=>e),this.depth=t||0,this.length=r||0,this.keyPropName=n,ue(this,"mode",()=>o),this.head=i||null,this.tail=s||null,this.ancestorMap=a||null,this.shouldNextForEachBreak=!1,this.forEachNextFn=void 0,this.change=null,this[ne]=!0}function pe(e){return e&&!function(e){return e.isOrphanNode}(e)?e:void 0}function he(e,t=[]){const{mode:r,keyPropName:n}=e,o={},i=t.length;if(i){const s=t[i-1],{key:a,value:u}=fe(n,s),c=Ne[r].makeImmutableLinkedOrderedMapNode(e,null,null,a,u);Ne[r].updateHeapMap(e,c);const l=e.tail;if(e.tail=c,o[a]||e.length++&&(o[a]=!0),i>1){let s=e.tail;for(let a=i-2;a>=0;a--){const i=t[a],{key:u,value:c}=fe(n,i);if(!o[u]){const t=Ne[r].makeImmutableLinkedOrderedMapNode(e,null,null,u,c);Ne[r].updateHeapMap(e,t),Ne[r].bindNodes(e,t,s),s=t,e.length++&&(o[u]=!0)}}null===e.head&&(e.head=s)}else null===l?e.head=c:Ne[r].bindNodes(e,l,e.tail)}}function fe(e,t){let r,n;if(t)if(r=t[e],void 0!==r)n=t;else{for(const e in t){r=e;break}n=t[r]}return{key:r,value:n}}function me(e,t,r=!0){e.change={[t]:r}}let ye=!1;function xe(e){ye=!0;const t=ae(e.mode);ye=!1,de.call(t,{heapMap:e.heapMap,depth:e.depth,length:e.length,keyPropName:e.keyPropName,mode:e.mode,head:e.head,tail:e.tail,ancestorMap:e}),t.depth++;const r=Ne[e.mode].fork;return r&&r(e,t),t}function ve(e,t){const r=Ne[e.mode].makeImmutableLinkedOrderedMapNode(e,null,null,t,void 0);r.isOrphanNode=!0,Ne[e.mode].updateHeapMap(e,r)}let ge=!1;class be{constructor(e){if(!ye){if(ge)return ge=!1,this;ge=!0;return se(e)}}get[Symbol.toStringTag](){return this.constructor.name}set(e,t=!1){const r=Array.isArray(e);if(r&&!e.length||!e)return this;let n;r||(e=[e]);let o=!1;const i=[],s=[],a={};let u=e.length-1;let c,l,d,p;const h=({map:e,newNode:t,newNext:r})=>{Ne[e.mode].bindNodes(e,t,r)};if(p=()=>{},t)c=(e,t)=>{const r=e.head;return e.head=t,{newNext:r}};else{let e=!0;c=(t,r)=>{let n;return e?(e=!1,null!==t.tail&&(l=t.tail),t.tail=r,n=!1):n={newNext:d},d=r,n},p=()=>{d&&(null===n.head&&(n.head=d),l&&Ne[n.mode].bindNodes(n,l,d))}}for(;u>=0;u--){const r=e[u],{key:d,value:p}=fe(this.keyPropName,r);if(a[d])continue;a[d]=!0;const f=Ne[this.mode].lookup(this,d);if(f){if(f.element.value!==p){n=n&&(o=!1)||n||(o=!0)&&xe(this);const e=!o&&Ne[n.mode].findMapNodeByDirection(n,f,"previous")||Ne[n.mode].findMapNodeByDirection(this,f,"previous"),t=!o&&Ne[n.mode].findMapNodeByDirection(n,f,"next")||Ne[n.mode].findMapNodeByDirection(this,f,"next"),r=Ne[n.mode].makeImmutableLinkedOrderedMapNode(n,null,null,d,p);Ne[this.mode].updateHeapMap(n,r),null!==e?Ne[n.mode].bindNodes(n,e,r):n.head=r,null!==t?Ne[n.mode].bindNodes(n,r,t):l?l=r:n.tail=r,s.unshift({key:d,value:p})}}else{n=n&&((o=!1)||n)||(o=!0)&&xe(this);const e=Ne[n.mode].makeImmutableLinkedOrderedMapNode(n,null,null,d,p);if(Ne[n.mode].updateHeapMap(n,e),null===n.tail&&t)n.tail=e,n.head=e;else{const t=c(n,e);if(t){const{newNext:r}=t;h({map:n,newNode:e,newNext:r})}}n.length++,i.unshift({key:d,value:p})}}return p(),n?(me(n,"set",{inserted:i,updated:s,prependMissing:t}),n):this}replace(e,t,r=!1,n=!1){const o=Ne[this.mode].lookup(this,e);let i,s,a,u=!1,c=!1,l=!1;if(o){const r=fe(this.keyPropName,t);if(s=r.key,a=r.value,o.element.value!==a){i=i||xe(this);const t=Ne[i.mode].makeImmutableLinkedOrderedMapNode(i,null,null,s,a),r=Ne[this.mode].findMapNodeByDirection(this,o,"previous"),n=Ne[this.mode].findMapNodeByDirection(this,o,"next");if(e+""!=s+""){ve(i,e);const u=Ne[this.mode].lookup(this,s);if(u){if(l=!0,u.element.value!==a){u===i.head&&(i.head=t),u===i.tail&&(i.tail=t);const e=Ne[this.mode].findMapNodeByDirection(this,u,"previous"),s=Ne[this.mode].findMapNodeByDirection(this,u,"next");null!==e&&(o!==e?Ne[i.mode].bindNodes(i,e,t):null!==r?Ne[i.mode].bindNodes(i,r,t):i.head=t),null!==s&&(o!==s?Ne[i.mode].bindNodes(i,t,s):null!==n?Ne[i.mode].bindNodes(i,t,n):i.tail=t)}i.length--}}l||(null===r?(i.head=t,null===n?i.tail=t:Ne[i.mode].bindNodes(i,t,n)):null===n?(i.tail=t,Ne[i.mode].bindNodes(i,r,t)):(Ne[i.mode].bindNodes(i,r,t),Ne[i.mode].bindNodes(i,t,n))),Ne[i.mode].updateHeapMap(i,t),c=!0}}else if(r){i=i||xe(this);const e=Ne[this.mode].lookup(this,s),r=fe(i.keyPropName,t);s=r.key,a=r.value;const o=Ne[i.mode].makeImmutableLinkedOrderedMapNode(i,null,null,s,a);if(Ne[i.mode].updateHeapMap(i,o),e&&(l=!0,e.element.value!==a)){e===i.head&&(i.head=o),e===i.tail&&(i.tail=o);const t=Ne[this.mode].findMapNodeByDirection(this,e,"previous"),r=Ne[this.mode].findMapNodeByDirection(this,e,"next");null!==t&&Ne[i.mode].bindNodes(i,t,o),null!==r&&Ne[i.mode].bindNodes(i,o,r),c=!0}if(!l)if(i.length++,u=!0,n){const e=i.head;i.head=o,null===e?i.tail=i.head:Ne[i.mode].bindNodes(i,o,e)}else{const e=i.tail;i.tail=o,null===e?i.head=i.tail:Ne[i.mode].bindNodes(i,e,o)}}return i?(me(i,"replace",{oldKey:e,key:s,value:a,wasInserted:u,wasUpdated:c,hadExistentNodeForKey:l,prependMissing:n}),i):this}unset(e){const t=typeof e;if("number"===t||"string"===t)return this.unsetKey(e);const r=this.keyPropName;if(Array.isArray(e)){let t=this;for(const n of e)t=t.unsetKey(n[r]);return t}return this.unsetKey(e[r])}unsetKey(e){const t=Ne[this.mode].lookup(this,e);let r,n;if(t){r=r||xe(this),n=t.element.value,ve(r,e);const o=Ne[r.mode].findMapNodeByDirection(this,t,"previous"),i=Ne[r.mode].findMapNodeByDirection(this,t,"next");if(null===o)if(null===i)r.head=null,r.tail=null,r.length=0;else{const e=Ne[r.mode].makeImmutableLinkedOrderedMapNode(r,null,null,i.element.key,i.element.value);Ne[r.mode].updateHeapMap(r,e),r.head=e;const t=Ne[r.mode].findMapNodeByDirection(this,i,"next");null===t?r.tail=e:Ne[r.mode].bindNodes(r,e,t),r.length--}else if(null===i){const e=Ne[r.mode].makeImmutableLinkedOrderedMapNode(r,null,null,o.element.key,o.element.value);Ne[r.mode].updateHeapMap(r,e),r.tail=e;const t=Ne[r.mode].findMapNodeByDirection(this,o,"previous");null===t?r.head=e:Ne[r.mode].bindNodes(r,t,e),r.length--}else Ne[r.mode].bindNodes(r,o,i),r.length--}return r?(me(r,"unset",{key:e,value:n}),r):this}empty(){if(this.length<=0)return this;const e=new be({initialItems:[],keyPropName:this.keyPropName,mode:this.mode});return e.length=0,e.depth=this.depth+1,e.ancestorMap=this,me(e,"empty"),e}get(e){const t=Ne[this.mode].lookup(this,e);if(t)return t.element.value}first(){return this.head?{key:this.head.element.key,value:this.head.element.value}:void 0}last(){return this.tail?{key:this.tail.element.key,value:this.tail.element.value}:void 0}rangeBefore(e,t=1/0,r=!0){const n=Ne[this.mode].lookup(this,e);if(!n||t<=0)return[];let o=r?n:Ne[this.mode].findMapNodeByDirection(this,n,"previous");if(!o)return[];const i=[{key:o.element.key,value:o.element.value}];for(;o&&i.length<t&&(o=Ne[this.mode].findMapNodeByDirection(this,o,"previous"),o);)i.push({key:o.element.key,value:o.element.value});return i.reverse()}rangeAfter(e,t=1/0,r=!0){const n=Ne[this.mode].lookup(this,e);if(!n||t<=0)return[];let o=r?n:Ne[this.mode].findMapNodeByDirection(this,n,"next");if(!o)return[];const i=[{key:o.element.key,value:o.element.value}];for(;o&&i.length<t&&(o=Ne[this.mode].findMapNodeByDirection(this,o,"next"),o);)i.push({key:o.element.key,value:o.element.value});return i}isEmpty(){return this.length<=0}forEach(e,t=!1){let r,n,o,i,s,a;for(this.shouldNextForEachBreak=!1,this.forEachNextFn=void 0,t?(o=this.tail,i="previous",s=this.length-1,a=()=>s--):(o=this.head,i="next",s=0,a=()=>s++);o&&!this.shouldNextForEachBreak;){const t=o.element;r=t.key,n=t.value;if(!1===(this.forEachNextFn||e).call(this,n,r,s))break;o=Ne[this.mode].findMapNodeByDirection(this,o,i),a()}}break(){this.shouldNextForEachBreak=!0}values(e=!1){const t=new Array(this.length);let r=0;return this.forEach((function(e){t[r]=e,r++}),e),t}keys(e=!1){const t=new Array(this.length);let r=0;return this.forEach((function(e,n){t[r]=n,r++}),e),t}keysValues(e=!1){const t=new Array(this.length);let r=0;return this.forEach((e,n)=>{t[r]={key:n,value:e},r++},e),t}map(e,t=!1){const r=new Array(this.length);let n=0;return this.forEach((t,o,i)=>{r[n]=e(t,o,i),n++},t),r}reduce(e,t,r=!1){let n,o=!1;if(arguments.length>1)n=t;else{if(!this.length)throw new TypeError("ImmutableLinkedOrderedMap type error: Reduce of empty map with no initial value");o=!0,n=(r?this.last():this.first()).value}const i=(t,r,o)=>{n=e(n,t,r,o)};return this.forEach((function(e,t,r){this.forEachNextFn=i,o||i(e,t,r)}),r),n}filter(e,t=!1){const r=[];let n=0;return this.forEach((t,o,i)=>{e(t,o,i)&&(r[n]=t,n++)},t),r}every(e,t=!1){let r=!0;return this.forEach((t,n,o)=>{if(!e(t,n,o))return r=!1,!1},t),r}some(e,t=!1){let r=!1;return this.forEach((t,n,o)=>{if(e(t,n,o))return r=!0,!1},t),r}static toJSON(e){return JSON.stringify({keyPropName:e.keyPropName,keysValues:e.keysValues()})}static fromJSON(e){const t=JSON.parse(e);return re(t.keyPropName)(t.keysValues.map(({key:e,value:t})=>({[e]:t})))}}function Oe(e){throw new Error(`ImmutableLinkedOrderedMap error: Mutation operation "${e}" is not allowed on a map in single mode on which a mutation operation already occurred once.`)}function ke(e,t){return t.substring(0,e.length)===e}function Ae(e){throw new Error(`ImmutableLinkedOrderedMap error: Operation "${e}" is not allowed on a map in lightweight mode on which a mutation operation occurred once.`)}function we(){this.map={},this.keyValueList=new Me,this.shouldNextForEachBreak=!1}function Me(){this.head=null,this.tail=null,this.length=0,this.shouldNextForEachBreak=!1}we.prototype.set=function(e,t,r=!1){if(e in this.map)this.map[e].element.value=t;else{const n=r?"prepend":"append",o=this.keyValueList[n]({key:e,value:t});this.map[e]=o}},we.prototype.remove=function(e){if(!(e in this.map))throw new Error("key does not exist");this.keyValueList.remove(this.map[e]),delete this.map[e]},we.prototype.empty=function(){this.map={},this.keyValueList=new Me,this.shouldNextForEachBreak=!1},we.prototype.isEmpty=function(){return this.getLength()<=0},we.prototype.get=function(e,t=!1){return this.map[e]&&(t?this.map[e]:this.map[e].element.value)},we.prototype.forEach=function(e,t=!1){let r,n;this.shouldNextForEachBreak=!1;const o=this;this.keyValueList.forEach((function(t,i){if(this.shouldNextForEachBreak)return!1;r=i.key,n=i.value;if(!1===e.call(o,r,n))return!1}),t)},we.prototype.break=function(){this.shouldNextForEachBreak=!0},we.prototype.getLength=function(){return this.keyValueList.length},we.prototype.toArray=function(){const e=new Array(this.getLength());let t=0;return this.forEach((function(r,n){e[t]=n,t++})),e},we.prototype.keys=function(){const e=new Array(this.getLength());let t=0;return this.forEach((function(r){e[t]=r,t++})),e},we.fromArray=function(e,t){const r=new we;for(let n=0;n<e.length;n++){const o=e[n];r.set(o[t],o)}return r},Me.prototype.append=function(e){if(this.length++,this.head){const t=this.tail;this.tail=ce(t,null,e),t.next=this.tail}else this.tail=ce(null,null,e),this.head=this.tail;return this.tail},Me.prototype.prepend=function(e){if(this.length++,this.head){const t=this.head;this.head=ce(null,t,e),t.previous=this.head}else this.tail=ce(null,null,e),this.head=this.tail;return this.head},Me.prototype.remove=function(e){null!==e&&(e.previous?(e.previous.next=e.next,e.next?e.next.previous=e.previous:this.tail=e.previous,this.length--):e.next?(this.head=e.next,this.head.previous=null,this.length--):(this.head=null,this.tail=null,this.length=0),e=null)},Me.prototype.pop=function(){if(this.tail){const e=this.tail.element;return this.remove(this.tail),e}},Me.prototype.shift=function(){if(this.head){const e=this.head.element;return this.remove(this.head),e}},Me.prototype.forEach=function(e,t=!1){let r,n,o,i;for(this.shouldNextForEachBreak=!1,t?(o=this.length-1,r=this.tail,n="previous",i=function(){o--}):(o=0,r=this.head,n="next",i=function(){o++});r&&!this.shouldNextForEachBreak;){const t=r.element;if(!1===e.call(this,o,t))break;r=r[n],i()}},Me.prototype.break=function(){this.shouldNextForEachBreak=!0};const Ne={[oe.SINGLE]:{ImmutableLinkedOrderedMapClass:class extends be{constructor(e){const t=super(e);return t.mutationOperationOccurred=!1,t}set(e,t=!1){this.mutationOperationOccurred&&Oe("set");const r=super.set(e,t);return this!==r&&(this.mutationOperationOccurred=!0),r}replace(e,t,r=!1,n=!1){this.mutationOperationOccurred&&Oe("replace");const o=super.replace(e,t,r,n);return this!==o&&(this.mutationOperationOccurred=!0),o}unset(e){this.mutationOperationOccurred&&Oe("unset");const t=super.unset(e);return this!==t&&(this.mutationOperationOccurred=!0),t}empty(){this.mutationOperationOccurred&&Oe("empty");const e=super.empty();return this!==e&&(this.mutationOperationOccurred=!0),e}},lookup:function(e,t){const{heapMap:r,depth:n}=e;if(!r[t])return;let o;return r[t].forEach((e,t)=>{if(n>=e)return o=t,!1}),pe(o)},updateHeapMap:function(e,t){const{heapMap:r,depth:n}=e,o=t.element.key;r[o]||(r[o]=new we),r[o].set(n,t,!0)},findMapNodeByDirection:function(e,t,r){if(t===e.tail&&"next"===r||t===e.head&&"previous"===r)return null;const{depth:n}=e,o=t[r];let i=null;return o.forEach((e,t)=>{if(n>=e)return i=t,!1}),i},makeImmutableLinkedOrderedMapNode:function(e,t,r,n,o){const{depth:i}=e,s=new we;s.set(i,t);const a=new we;return a.set(i,r),ce(s,a,{key:n,value:o})},bindNodes:function(e,t,r){const{depth:n}=e;t.next.set(n,r,!0),r.previous.set(n,t,!0)}},[oe.MULTIWAY]:{ImmutableLinkedOrderedMapClass:class extends be{constructor(e){const t=super(e);return t.childrenCount=0,t}},hydrate:function({version:e=""}={}){this.version=e},lookup:function(e,t){const{heapMap:r,depth:n,version:o}=e;if(!r[t])return;const i=r[t];let s=void 0;return i.forEach((e,t)=>{if(n>=e&&(t.forEach((e,t)=>{if(ke(e,o))return s=t,!1}),s))return!1}),pe(s)},fork:function(e,t){return t.version=e.version.length?`${e.version}${++e.childrenCount}#`:++e.childrenCount+"#",t},updateHeapMap:function(e,t){const{heapMap:r,depth:n,version:o}=e,i=t.element.key;r[i]||(r[i]=new we),r[i].map[n]||r[i].set(n,new we,!0),r[i].get(n).set(o,t,!0)},findMapNodeByDirection:function(e,t,r){if(t===e.tail&&"next"===r||t===e.head&&"previous"===r)return null;const{depth:n,version:o}=e,i=t[r];let s=null;return i.forEach((e,t)=>{if(n>=e&&(t.forEach((e,t)=>{if(ke(e,o))return s=t,!1}),s))return!1}),s},makeImmutableLinkedOrderedMapNode:function(e,t,r,n,o){const{depth:i,version:s}=e,a=new we,u=new we;u.set(s,t),a.set(i,u);const c=new we,l=new we;return l.set(s,r),c.set(i,l),ce(a,c,{key:n,value:o})},bindNodes:function(e,t,r){const{depth:n,version:o}=e;t.next.map[n]||t.next.set(n,new we,!0),t.next.get(n).set(o,r,!0),r.previous.map[n]||r.previous.set(n,new we,!0),r.previous.get(n).set(o,t,!0)}},[oe.LIGHTWEIGHT]:{ImmutableLinkedOrderedMapClass:class extends be{constructor(e){const t=super(e);return t.mutationOperationOccurred=!1,t}set(e,t=!1){this.mutationOperationOccurred&&Ae("set");const r=super.set(e,t);return this!==r&&(this.mutationOperationOccurred=!0),r}replace(e,t,r=!1,n=!1){this.mutationOperationOccurred&&Ae("replace");const o=super.replace(e,t,r,n);return this!==o&&(this.mutationOperationOccurred=!0),o}unset(e){this.mutationOperationOccurred&&Ae("unset");const t=super.unset(e);return this!==t&&(this.mutationOperationOccurred=!0),t}empty(){this.mutationOperationOccurred&&Ae("empty");const e=super.empty();return this!==e&&(this.mutationOperationOccurred=!0),e}get(e){return this.mutationOperationOccurred&&Ae("get"),super.get(e)}first(){return this.mutationOperationOccurred&&Ae("first"),super.first()}last(){return this.mutationOperationOccurred&&Ae("last"),super.last()}isEmpty(){return this.mutationOperationOccurred&&Ae("isEmpty"),super.isEmpty()}forEach(e,t=!1){return this.mutationOperationOccurred&&Ae("forEach"),super.forEach(e,t)}break(){return this.mutationOperationOccurred&&Ae("break"),super.break()}values(e=!1){return this.mutationOperationOccurred&&Ae("values"),super.values(e)}keys(e=!1){return this.mutationOperationOccurred&&Ae("keys"),super.keys(e)}keysValues(e=!1){return this.mutationOperationOccurred&&Ae("keysValues"),super.keysValues(e)}map(e,t=!1){return this.mutationOperationOccurred&&Ae("map"),super.map(e,t)}reduce(e,t,r=!1){return this.mutationOperationOccurred&&Ae("reduce"),super.reduce(e,t,r)}filter(e,t=!1){return this.mutationOperationOccurred&&Ae("filter"),super.filter(e,t)}every(e,t=!1){return this.mutationOperationOccurred&&Ae("every"),super.every(e,t)}some(e,t=!1){return this.mutationOperationOccurred&&Ae("some"),super.some(e,t)}},lookup:function(e,t){const{heapMap:r}=e;return pe(r[t])},updateHeapMap:function(e,t){const{heapMap:r}=e;r[t.element.key]=t},findMapNodeByDirection:function(e,t,r){return t[r]},makeImmutableLinkedOrderedMapNode:function(e,t,r,n,o){return ce(t,r,{key:n,value:o})},bindNodes:function(e,t,r){t.next=r,r.previous=t}}};be.MODE=oe,be.isMap=e=>!(!e||!0!==e[ne]),[["lazyMap",te],["map",ee],["lazyMapFactory",re]].map(([e,t])=>be[e]=t)})(),n=n.default})()}));