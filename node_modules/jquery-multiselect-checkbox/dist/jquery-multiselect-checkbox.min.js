/*! For license information please see jquery-multiselect-checkbox.min.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("jquery")):"function"==typeof define&&define.amd?define("jQueryMultiselectCheckbox",["jquery"],t):"object"==typeof exports?exports.jQueryMultiselectCheckbox=t(require("jquery")):e.jQueryMultiselectCheckbox=t(e.jQuery)}("undefined"!=typeof self?self:"undefined"!=typeof global?global:this,(function(e){return(()=>{"use strict";var t={660:e=>{const t=/[|\\{}()[\]^$+*?.-]/g;e.exports=e=>{if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(t,"\\$&")}},47:t=>{t.exports=e}},n={};function r(e){var o=n[e];if(void 0!==o)return o.exports;var i=n[e]={exports:{}};return t[e](i,i.exports,r),i.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var o={};return(()=>{r.d(o,{default:()=>Ge});var e=r(47),t=r.n(e);Object.prototype.hasOwnProperty;Object.prototype.toString.call({});function n(e){return Object.prototype.toString.call(e)===Object.prototype.toString.call([])}Symbol("treeMapSubtree");function i(e){return void 0===e}!function(){let e=0}();const s=e=>Boolean("function"==typeof e?e():e);function c(e){return(()=>{let t=0;for(;t<e.length-1;t++){const n=e[t],[r,o]=n;if(s(r))return o}const r=e[t];if(n(r)&&2===r.length){const[e,t]=r;return s(e)?t:void 0}return r})()}const a=function*(e){const t=Reflect.ownKeys(e);for(const n of t){const t=e[n];yield{rule:n,pointcut:t}}},u=function*(e){for(const t of e)if(n(t)){const[e,n]=t;yield{rule:e,pointcut:n}}else yield*a(t)};class l{}class h extends l{constructor(e){super(),this.rules=e}matches(e){for(const t of this.rules)if(t.matches(e))return!0;return!1}}class p extends l{constructor(e){super(),this.regex=new RegExp(e)}matches(e){return this.regex.lastIndex=0,"symbol"!=typeof e&&this.regex.test(e)}}class d extends l{constructor(e){super(),this.property=e}matches(e){return this.property===e}}const f=e=>new p(e),x=e=>new d(e),m=e=>{let t=e;return c([[()=>e instanceof RegExp,f],[()=>{if("string"!=typeof e)return!1;const n=e.indexOf("/"),r=e.lastIndexOf("/");if(0===n&&r>0){const n=e.substring(1,r),o=e.substring(r+1)||void 0;return t=new RegExp(n,o),!0}return!1},f],x])(t)},y=e=>{const t=[];for(const n of e){const e=m(n);t.push(e)}return new h(t)};function v(e){return c([[n(e),y],m])(e)}class k{constructor(){var e,t,n;n=[],(t="advices")in(e=this)?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n}}class g{constructor(e){this.fn=e}}class b extends g{}class A extends g{}class O extends g{}class C extends k{before(e){return this.advices.push(new b(e)),this}after(e){return this.advices.push(new A(e)),this}around(e){return this.advices.push(new O(e)),this}}class w extends k{before(e){return this.advices.push(new b(e)),this}after(e){return this.advices.push(new A(e)),this}around(e){return this.advices.push(new O(e)),this}}class M extends k{before(e){return this.advices.push(new b(e)),this}after(e){return this.advices.push(new A(e)),this}around(e){return this.advices.push(new O(e)),this}}class N extends k{before(e){return this.advices.push(new b(e)),this}after(e){return this.advices.push(new A(e)),this}around(e){return this.advices.push(new O(e)),this}}class E extends k{before(e){return this.advices.push(new b(e)),this}after(e){return this.advices.push(new A(e)),this}around(e){return this.advices.push(new O(e)),this}}const P=Symbol("applyRule"),I=Symbol("constructRule");function D(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const L=Symbol("noReturnValue");class S{constructor(){D(this,"execContextStack",[]),D(this,"execContextID",-1)}execute(e,t,n,r){this.newExecutionContext(),this.setUpExecutionContext(t,n),this.startExecutionContext(e),this.beforePhase(e,t),this.aroundPhase(e,n);const o=this.proceedPhase(e);return this.afterPhase(e,r,o),this.endExecutionContext(e),this.cleanUpExecutionContext(),o}newExecutionContext(){const e={proceeds:[],hasAtLeastOneAroundAdvice:!1,hasAtLeastOneBeforeAdvice:!1,returnValue:L};this.execContextStack.push(e),this.execContextID++}setUpExecutionContext(e,t){this.execContextStack[this.execContextID].hasAtLeastOneBeforeAdvice=!!e.length,this.execContextStack[this.execContextID].hasAtLeastOneAroundAdvice=!!t.length}startExecutionContext(e){}endExecutionContext(e){}cleanUpExecutionContext(){this.execContextStack.pop(),this.execContextID--}unsupportedMultipleProceeds(e,t){console.error("pigretto - Multiple proceeds for the same advice are not supported, subsequent proceed has been ignored.","\n\tadvice: ",e,"\n\trule: ",t)}executeBeforeAdvice(e,t,n){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeBeforeAdvice".`)}executeAroundAdvice(e,t,n,r){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeAroundAdvice".`)}executeAfterAdvice(e,t,n,r){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeAfterAdvice".`)}performUnderlyingOperation(e){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "performUnderlyingOperation".`)}executeProceedCallback(e,t,n,r){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeProceedCallback".`)}beforePhase(e,t){for(const{rule:n,advice:r}of t)this.executeBefore(e,r,n)}executeBefore(e,t,n){this.executeBeforeAdvice(e,t,n)}aroundPhase(e,t){for(const{rule:n,advice:r}of t)if(this.executeAround(e,r,n),this.execContextStack[this.execContextID].returnValue!==L)break}executeAround(e,t,r){let o=!1;const i=this.executeAroundAdvice(e,t,r,(e,i)=>{if(o)return void this.unsupportedMultipleProceeds(t,r);o=!0;let s=void 0,c=void 0;n(e)?(s=e,c="function"==typeof i?i:void 0):"function"==typeof e&&(c=e),this.execContextStack[this.execContextID].proceeds.push({params:s,fn:c,rule:r})});o||(this.execContextStack[this.execContextID].returnValue=i)}afterPhase(e,t,n){for(const{rule:r,advice:o}of t)this.executeAfter(e,o,r,n)}executeAfter(e,t,n,r){this.executeAfterAdvice(e,t,n,r)}proceedPhase(e){if(this.execContextStack[this.execContextID].returnValue!==L)return this.return(e,this.execContextStack[this.execContextID].returnValue);let t=this.performUnderlyingOperation(e);for(const{fn:n,rule:r}of this.execContextStack[this.execContextID].proceeds)"function"==typeof n&&(t=this.executeProceedCallback(e,r,t,n));return this.return(e,t)}return(e,t){return t}}const j=(e,t,n)=>{if("function"!=typeof e[t])throw new Error(`pigretto - ${n.name} trap executor does not implement "${t}".`)};function B(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const T=e=>{const t=class extends e{constructor(...e){super(...e),B(this,"executedAtLeastOnce",!1),B(this,"lastProceedWithParamsIndexMap",{}),B(this,"finalTrapArgsMap",{})}startExecutionContext(t){if(!this.executedAtLeastOnce&&j(e.prototype,"startExecutionContext",e),super.startExecutionContext(t),!this.executedAtLeastOnce&&!Object.prototype.hasOwnProperty.call(this,"execContextID"))throw new Error(`pigretto - ${e.name} trap executor does not have "execContextID" property.`);this.lastProceedWithParamsIndexMap[this.execContextID]=-1,this.finalTrapArgsMap[this.execContextID]=void 0}endExecutionContext(t){!this.executedAtLeastOnce&&j(e.prototype,"endExecutionContext",e),super.endExecutionContext(t),this.finalTrapArgsMap[this.execContextID]=void 0,this.executedAtLeastOnce=!0}getFinalTrapArgs(t){!this.executedAtLeastOnce&&j(this,"getTrapArgsArgumentsListIndex",e);const r=this.getTrapArgsArgumentsListIndex();if(!this.executedAtLeastOnce&&!Object.prototype.hasOwnProperty.call(this,"execContextStack"))throw new Error(`pigretto - ${e.name} trap executor does not have "execContextStack" property.`);const o=this.execContextStack[this.execContextID].proceeds.length;if(o){let e=!1;for(let i=o-1;i>this.lastProceedWithParamsIndexMap[this.execContextID];i--){const{params:o}=this.execContextStack[this.execContextID].proceeds[i];if(n(o)){e=!0,this.lastProceedWithParamsIndexMap[this.execContextID]=i,(t=[...t])[r]=o,this.finalTrapArgsMap[this.execContextID]=t;break}}e||(this.lastProceedWithParamsIndexMap[this.execContextID]=o-1)}return i(this.finalTrapArgsMap[this.execContextID])?t:this.finalTrapArgsMap[this.execContextID]}executeAroundAdvice(t,n,r,o){return t=this.getFinalTrapArgs(t),!this.executedAtLeastOnce&&j(e.prototype,"executeAroundAdvice",e),super.executeAroundAdvice(t,n,r,o)}executeAfterAdvice(t,n,r,o){t=this.getFinalTrapArgs(t),!this.executedAtLeastOnce&&j(e.prototype,"executeAfterAdvice",e),super.executeAfterAdvice(t,n,r,o)}performUnderlyingOperation(t){return t=this.getFinalTrapArgs(t),!this.executedAtLeastOnce&&j(e.prototype,"performUnderlyingOperation",e),super.performUnderlyingOperation(t)}executeProceedCallback(t,n,r,o){return t=this.getFinalTrapArgs(t),!this.executedAtLeastOnce&&j(e.prototype,"executeProceedCallback",e),super.executeProceedCallback(t,n,r,o)}};return Object.defineProperty(t,"name",{value:`WithFunctionTrapExecutor(${e.name})`,configurable:!0}),t},F=T(class extends S{getTrapArgsArgumentsListIndex(){return 4}execute([e,t,n,r],o,i,s){if("function"==typeof r&&[o,i,s].some(e=>{return!(!(t=e)||0===t.length);var t})){const c=e=>super.execute(e,o,i,s);return function(...o){let i;i=this!==n?this:e,r=r.bind(i);return c([e,t,n,r,o])}}return r}executeBeforeAdvice([e,t,n,,r],o,i){const s={target:e,property:t,receiver:n,rule:i};o.fn.apply(s,r)}executeAroundAdvice([e,t,n,,r],o,i,s){const c={target:e,property:t,receiver:n,rule:i};return o.fn.call(c,s).apply(c,r)}executeAfterAdvice([e,t,n,,r],o,i,s){const c={target:e,property:t,receiver:n,rule:i};o.fn.call(c,...r).apply(c,[s])}performUnderlyingOperation([,,,e,t]){return e(...t)}executeProceedCallback([e,t,n,,r],o,i,s){const c={target:e,property:t,receiver:n,rule:o,argumentsList:r};return s.apply(c,[i])}});function R(e,t,n){return Reflect.get(e,t,n)}class U extends S{executeBeforeAdvice([e,t,n],r,o){const i={target:e,property:t,receiver:n,rule:o};r.fn.apply(i)}executeAroundAdvice([e,t,n],r,o,i){const s={target:e,property:t,receiver:n,rule:o};return r.fn.apply(s,[i])}executeAfterAdvice([e,t,n],r,o,i){const s={target:e,property:t,receiver:n,rule:o};r.fn.apply(s,[i])}performUnderlyingOperation([e,t,n]){return R(e,t,n)}executeProceedCallback([e,t,n],r,o,i){const s={target:e,property:t,receiver:n,rule:r};return i.apply(s,[o])}}function $(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class V extends S{constructor(...e){super(...e),$(this,"previousPropertyValueMap",{}),$(this,"returnNewPropertyValueMap",{}),$(this,"updateWasSuccessfulMap",{})}startExecutionContext([e,t,,n]){if(!Object.prototype.hasOwnProperty.call(this.previousPropertyValueMap,this.execContextID)){const r=R(e,t,n);this.previousPropertyValueMap[this.execContextID]=r,this.returnNewPropertyValueMap[this.execContextID]=void 0,this.updateWasSuccessfulMap[this.execContextID]=!1}}endExecutionContext([,,,]){delete this.previousPropertyValueMap[this.execContextID],delete this.returnNewPropertyValueMap[this.execContextID],delete this.updateWasSuccessfulMap[this.execContextID]}executeBeforeAdvice([e,t,n,r],o,i){const s=this.previousPropertyValueMap[this.execContextID],c={target:e,property:t,value:n,receiver:r,rule:i};o.fn.apply(c,[s])}executeAroundAdvice([e,t,n,r],o,i,s){const c=this.previousPropertyValueMap[this.execContextID],a={target:e,property:t,value:n,receiver:r,rule:i};return o.fn.call(a,s).apply(a,[c])}executeAfterAdvice([e,t,n,r],o,i,s){const c=this.previousPropertyValueMap[this.execContextID],a=this.returnNewPropertyValueMap[this.execContextID],u={target:e,property:t,value:n,receiver:r,rule:i,updateWasSuccessful:s};o.fn.call(u,c).apply(u,[a])}performUnderlyingOperation([e,t,n,r]){const o=function(e,t,n,r){return Reflect.set(e,t,n,r)}(e,t,n,r);return this.updateWasSuccessfulMap[this.execContextID]=o,this.returnNewPropertyValueMap[this.execContextID]=n,n}executeProceedCallback([e,t,n,r],o,i,s){const c={target:e,property:t,value:n,receiver:r,rule:o};return s.apply(c,[i])}return([e,t,,n],r){return r!==this.returnNewPropertyValueMap[this.execContextID]&&this.performUnderlyingOperation([e,t,r,n]),this.updateWasSuccessfulMap[this.execContextID]}}const W=T(class extends S{getTrapArgsArgumentsListIndex(){return 2}executeBeforeAdvice([e,t,n],r,o){const i={target:e,thisArg:t,rule:o};r.fn.apply(i,n)}executeAroundAdvice([e,t,n],r,o,i){const s={target:e,thisArg:t,rule:o};return r.fn.call(s,i).apply(s,n)}executeAfterAdvice([e,t,n],r,o,i){const s={target:e,thisArg:t,rule:o};r.fn.call(s,...n).apply(s,[i])}performUnderlyingOperation([e,t,n]){return function(e,t,n){return Reflect.apply(e,t,n)}(e,t,n)}executeProceedCallback([e,t,n],r,o,i){const s={target:e,thisArg:t,rule:r,argumentsList:n};return i.apply(s,[o])}});const H=T(class extends S{getTrapArgsArgumentsListIndex(){return 1}executeBeforeAdvice([e,t,n],r,o){const i={target:e,newTarget:n,rule:o};r.fn.apply(i,t)}executeAroundAdvice([e,t,n],r,o,i){const s={target:e,newTarget:n,rule:o};return r.fn.call(s,i).apply(s,t)}executeAfterAdvice([e,t,n],r,o,i){const s={target:e,newTarget:n,rule:o};r.fn.call(s,...t).apply(s,[i])}performUnderlyingOperation([e,t,n]){return function(e,t,n){return n?Reflect.construct(e,t,n):new e(...t)}(e,t,n)}executeProceedCallback([e,t,n],r,o,i){const s={target:e,newTarget:n,rule:r,argumentsList:t};return i.apply(s,[o])}});function K(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class q{constructor(){K(this,"advices",{call:[],get:[],set:[],apply:[],construct:[]}),K(this,"distributedAdvices",{call:{before:void 0,around:void 0,after:void 0},get:{before:void 0,around:void 0,after:void 0},set:{before:void 0,around:void 0,after:void 0},apply:{before:void 0,around:void 0,after:void 0},construct:{before:void 0,around:void 0,after:void 0}}),K(this,"matchedDistributedAdvices",{call:new Map,get:new Map,set:new Map}),K(this,"trapExecutors",{call:new F,get:new U,set:new V,apply:new W,construct:new H})}hasAtLeastOneAdviceOfPointcutType(e){return!!this.advices[e].length}addAdvices(e,t,n=[]){n.map(n=>this.advices[e].push({rule:t,advice:n}))}lazilyDistributeAdvices(e){if(i(this.distributedAdvices[e].before)){this.distributedAdvices[e].before=[],this.distributedAdvices[e].around=[],this.distributedAdvices[e].after=[];for(const{rule:t,advice:n}of this.advices[e]){const r=c([[()=>n instanceof b,"before"],[()=>n instanceof O,"around"],"after"]);this.distributedAdvices[e][r].push({rule:t,advice:n})}}}lazilyMatchAdvices(e,t){this.lazilyDistributeAdvices(e);const n=this.matchedDistributedAdvices[e];if(!n.has(t)){const r={before:[],around:[],after:[]};n.set(t,r);const o=this.distributedAdvices[e].before,i=this.distributedAdvices[e].around,s=this.distributedAdvices[e].after,c=e=>n=>{for(const{rule:o,advice:i}of e){o.matches(t)&&r[n].push({rule:o,advice:i})}};c(o)("before"),c(i)("around"),c(s)("after")}}addPointcutRule(e,t){const n=()=>"function"==typeof e&&t instanceof d,r=c([[()=>e instanceof C,"call"],[()=>e instanceof w,"get"],[()=>e instanceof M,"set"],[()=>{const r=n()&&t.property===P;return!!(r||e instanceof N)&&(r&&(e=(new N).before(e)),!0)},"apply"],[()=>{const r=n()&&t.property===I;return!!(r||e instanceof E)&&(r&&(e=(new E).before(e)),!0)},"construct"]]);if(r){const{advices:n}=e;this.addAdvices(r,t,n)}return this}hasGets(){return this.hasAtLeastOneAdviceOfPointcutType("call")||this.hasAtLeastOneAdviceOfPointcutType("get")}hasSets(){return this.hasAtLeastOneAdviceOfPointcutType("set")}hasApplies(){return this.hasAtLeastOneAdviceOfPointcutType("apply")}hasConstructs(){return this.hasAtLeastOneAdviceOfPointcutType("construct")}get(e,t,n){this.lazilyMatchAdvices("get",t),this.lazilyMatchAdvices("call",t);const{before:r,around:o,after:i}=this.matchedDistributedAdvices.get.get(t),s=this.trapExecutors.get.execute([e,t,n],r,o,i),{before:c,around:a,after:u}=this.matchedDistributedAdvices.call.get(t);return this.trapExecutors.call.execute([e,t,n,s],c,a,u)}set(e,t,n,r){this.lazilyMatchAdvices("set",t);const{before:o,around:i,after:s}=this.matchedDistributedAdvices.set.get(t);return this.trapExecutors.set.execute([e,t,n,r],o,i,s)}apply(e,t,n){this.lazilyDistributeAdvices("apply");const{before:r,around:o,after:i}=this.distributedAdvices.apply;return this.trapExecutors.apply.execute([e,t,n],r,o,i)}construct(e,t,n){this.lazilyDistributeAdvices("construct");const{before:r,around:o,after:i}=this.distributedAdvices.construct;return this.trapExecutors.construct.execute([e,t,n],r,o,i)}}function z(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function G(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?z(Object(n),!0).forEach((function(t){Q(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):z(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Q(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Y(e){const t=new q,r=function*(e){const t=c([[n(e),u],a]);yield*t(e)}(e);for(const{rule:e,pointcut:n}of r){const r=v(e);t.addPointcutRule(n,r)}return G(G(G(G({},t.hasGets()?{get:(e,n,r)=>t.get(e,n,r)}:{}),t.hasSets()?{set:(e,n,r,o)=>t.set(e,n,r,o)}:{}),t.hasApplies()?{apply:(e,n,r)=>t.apply(e,n,r)}:{}),t.hasConstructs()?{construct:(e,n,r)=>t.construct(e,n,r)}:{})}function _(e,t){const n=function(e){return Y(e)}(t);return new Proxy(e,n)}function J(){return new C}function X(){return new M}function Z(){return new w}var ee=r(660),te=r.n(ee);const ne="ImmutableLinkedOrderedMapEWoFkvQyQsM32wK4a5Kd",re={SINGLE:1,MULTIWAY:2,LIGHTWEIGHT:3},oe=re.MULTIWAY;function ie({initialItems:e=[],keyPropName:t="id",mode:n=oe,lazy:r=!1}={}){let o=se(n=we[n]&&n||(n=oe));return ue.call(o,{keyPropName:t,mode:n}),r?o=function(e,t=[]){e.length=t.length;return function(e,{onceCallback:t,ignoredTypes:n=[Object],interceptConstructor:r=!1,propertiesToIgnore:o=[],pointcuts:i=[J,Z,X]}={}){let s=!1,c=!1,a=!1;const u=[],l={},h=n.map(e=>e.prototype.constructor);let p=e,d=!1;for(;p;){const t=p.constructor;if(!d||!h.includes(t)){Reflect.ownKeys(p).map(t=>l[t]={isMethod:"constructor"!==t&&"function"==typeof e[t]})}p=Object.getPrototypeOf(p),d=!0}o.map(e=>delete l[e]),!r&&delete l.constructor,i.map(e=>{e===J?s=!0:e===Z?c=!0:e===X&&(a=!0)});const f=Object.keys(l);let x=!0;const m=function(...e){x&&(x=!1,t.apply(this,e))},y=e=>e.map(te()),v=e=>new RegExp(`^(${e.join("|")})$`),k=e=>t=>u.push([e,t().before(m)]);if(s){k(v(y(f.filter(e=>l[e].isMethod))))(J)}if(c||a){const e=y(f.filter(e=>!l[e].isMethod));c&&k(v(e))(Z),a&&k(v(e))(X)}return _(e,u)}(e,{onceCallback:()=>{e.length=0,pe(e,t)}})}(o,e):pe(o,e),o}function se(e){return new(0,we[e].ImmutableLinkedOrderedMapClass)}function ce(e,t,n,r){const o={};o[t]={get:n,set:r},Object.defineProperties(e,o)}function ae(e,t,n){return{previous:e,next:t,element:n}}function ue({keyPropName:e,mode:t}){le.call(this,{heapMap:{},depth:0,length:0,keyPropName:e,mode:t});const n=we[t].hydrate;n&&n.call(this)}function le({heapMap:e,depth:t,length:n,keyPropName:r,mode:o,head:i,tail:s,ancestorMap:c}={}){ce(this,"heapMap",()=>e),this.depth=t||0,this.length=n||0,this.keyPropName=r,ce(this,"mode",()=>o),this.head=i||null,this.tail=s||null,this.ancestorMap=c||null,this.shouldNextForEachBreak=!1,this.forEachNextFn=void 0,this.change=null,this[ne]=!0}function he(e){return e&&!function(e){return e.isOrphanNode}(e)?e:void 0}function pe(e,t=[]){const{mode:n,keyPropName:r}=e,o={},i=t.length;if(i){const s=t[i-1],{key:c,value:a}=de(r,s),u=we[n].makeImmutableLinkedOrderedMapNode(e,null,null,c,a);we[n].updateHeapMap(e,u);const l=e.tail;if(e.tail=u,o[c]||e.length++&&(o[c]=!0),i>1){let s=e.tail;for(let c=i-2;c>=0;c--){const i=t[c],{key:a,value:u}=de(r,i);if(!o[a]){const t=we[n].makeImmutableLinkedOrderedMapNode(e,null,null,a,u);we[n].updateHeapMap(e,t),we[n].bindNodes(e,t,s),s=t,e.length++&&(o[a]=!0)}}null===e.head&&(e.head=s)}else null===l?e.head=u:we[n].bindNodes(e,l,e.tail)}}function de(e,t){let n,r;if(t)if(n=t[e],void 0!==n)r=t;else{for(const e in t){n=e;break}r=t[n]}return{key:n,value:r}}function fe(e,t,n=!0){e.change={[t]:n}}let xe=!1;function me(e){xe=!0;const t=se(e.mode);xe=!1,le.call(t,{heapMap:e.heapMap,depth:e.depth,length:e.length,keyPropName:e.keyPropName,mode:e.mode,head:e.head,tail:e.tail,ancestorMap:e}),t.depth++;const n=we[e.mode].fork;return n&&n(e,t),t}function ye(e,t){const n=we[e.mode].makeImmutableLinkedOrderedMapNode(e,null,null,t,void 0);n.isOrphanNode=!0,we[e.mode].updateHeapMap(e,n)}let ve=!1;class ke{constructor(e){if(!xe){if(ve)return ve=!1,this;ve=!0;return ie(e)}}get[Symbol.toStringTag](){return this.constructor.name}set(e,t=!1){const n=Array.isArray(e);if(n&&!e.length||!e)return this;let r;n||(e=[e]);let o=!1;const i=[],s=[],c={};let a=e.length-1;let u,l,h,p;const d=({map:e,newNode:t,newNext:n})=>{we[e.mode].bindNodes(e,t,n)};if(p=()=>{},t)u=(e,t)=>{const n=e.head;return e.head=t,{newNext:n}};else{let e=!0;u=(t,n)=>{let r;return e?(e=!1,null!==t.tail&&(l=t.tail),t.tail=n,r=!1):r={newNext:h},h=n,r},p=()=>{h&&(null===r.head&&(r.head=h),l&&we[r.mode].bindNodes(r,l,h))}}for(;a>=0;a--){const n=e[a],{key:h,value:p}=de(this.keyPropName,n);if(c[h])continue;c[h]=!0;const f=we[this.mode].lookup(this,h);if(f){if(f.element.value!==p){r=r&&(o=!1)||r||(o=!0)&&me(this);const e=!o&&we[r.mode].findMapNodeByDirection(r,f,"previous")||we[r.mode].findMapNodeByDirection(this,f,"previous"),t=!o&&we[r.mode].findMapNodeByDirection(r,f,"next")||we[r.mode].findMapNodeByDirection(this,f,"next"),n=we[r.mode].makeImmutableLinkedOrderedMapNode(r,null,null,h,p);we[this.mode].updateHeapMap(r,n),null!==e?we[r.mode].bindNodes(r,e,n):r.head=n,null!==t?we[r.mode].bindNodes(r,n,t):l?l=n:r.tail=n,s.unshift({key:h,value:p})}}else{r=r&&((o=!1)||r)||(o=!0)&&me(this);const e=we[r.mode].makeImmutableLinkedOrderedMapNode(r,null,null,h,p);if(we[r.mode].updateHeapMap(r,e),null===r.tail&&t)r.tail=e,r.head=e;else{const t=u(r,e);if(t){const{newNext:n}=t;d({map:r,newNode:e,newNext:n})}}r.length++,i.unshift({key:h,value:p})}}return p(),r?(fe(r,"set",{inserted:i,updated:s,prependMissing:t}),r):this}replace(e,t,n=!1,r=!1){const o=we[this.mode].lookup(this,e);let i,s,c,a=!1,u=!1,l=!1;if(o){const n=de(this.keyPropName,t);if(s=n.key,c=n.value,o.element.value!==c){i=i||me(this);const t=we[i.mode].makeImmutableLinkedOrderedMapNode(i,null,null,s,c),n=we[this.mode].findMapNodeByDirection(this,o,"previous"),r=we[this.mode].findMapNodeByDirection(this,o,"next");if(e+""!=s+""){ye(i,e);const a=we[this.mode].lookup(this,s);if(a){if(l=!0,a.element.value!==c){a===i.head&&(i.head=t),a===i.tail&&(i.tail=t);const e=we[this.mode].findMapNodeByDirection(this,a,"previous"),s=we[this.mode].findMapNodeByDirection(this,a,"next");null!==e&&(o!==e?we[i.mode].bindNodes(i,e,t):null!==n?we[i.mode].bindNodes(i,n,t):i.head=t),null!==s&&(o!==s?we[i.mode].bindNodes(i,t,s):null!==r?we[i.mode].bindNodes(i,t,r):i.tail=t)}i.length--}}l||(null===n?(i.head=t,null===r?i.tail=t:we[i.mode].bindNodes(i,t,r)):null===r?(i.tail=t,we[i.mode].bindNodes(i,n,t)):(we[i.mode].bindNodes(i,n,t),we[i.mode].bindNodes(i,t,r))),we[i.mode].updateHeapMap(i,t),u=!0}}else if(n){i=i||me(this);const e=we[this.mode].lookup(this,s),n=de(i.keyPropName,t);s=n.key,c=n.value;const o=we[i.mode].makeImmutableLinkedOrderedMapNode(i,null,null,s,c);if(we[i.mode].updateHeapMap(i,o),e&&(l=!0,e.element.value!==c)){e===i.head&&(i.head=o),e===i.tail&&(i.tail=o);const t=we[this.mode].findMapNodeByDirection(this,e,"previous"),n=we[this.mode].findMapNodeByDirection(this,e,"next");null!==t&&we[i.mode].bindNodes(i,t,o),null!==n&&we[i.mode].bindNodes(i,o,n),u=!0}if(!l)if(i.length++,a=!0,r){const e=i.head;i.head=o,null===e?i.tail=i.head:we[i.mode].bindNodes(i,o,e)}else{const e=i.tail;i.tail=o,null===e?i.head=i.tail:we[i.mode].bindNodes(i,e,o)}}return i?(fe(i,"replace",{oldKey:e,key:s,value:c,wasInserted:a,wasUpdated:u,hadExistentNodeForKey:l,prependMissing:r}),i):this}unset(e){const t=typeof e;if("number"===t||"string"===t)return this.unsetKey(e);const n=this.keyPropName;if(Array.isArray(e)){let t=this;for(const r of e)t=t.unsetKey(r[n]);return t}return this.unsetKey(e[n])}unsetKey(e){const t=we[this.mode].lookup(this,e);let n,r;if(t){n=n||me(this),r=t.element.value,ye(n,e);const o=we[n.mode].findMapNodeByDirection(this,t,"previous"),i=we[n.mode].findMapNodeByDirection(this,t,"next");if(null===o)if(null===i)n.head=null,n.tail=null,n.length=0;else{const e=we[n.mode].makeImmutableLinkedOrderedMapNode(n,null,null,i.element.key,i.element.value);we[n.mode].updateHeapMap(n,e),n.head=e;const t=we[n.mode].findMapNodeByDirection(this,i,"next");null===t?n.tail=e:we[n.mode].bindNodes(n,e,t),n.length--}else if(null===i){const e=we[n.mode].makeImmutableLinkedOrderedMapNode(n,null,null,o.element.key,o.element.value);we[n.mode].updateHeapMap(n,e),n.tail=e;const t=we[n.mode].findMapNodeByDirection(this,o,"previous");null===t?n.head=e:we[n.mode].bindNodes(n,t,e),n.length--}else we[n.mode].bindNodes(n,o,i),n.length--}return n?(fe(n,"unset",{key:e,value:r}),n):this}empty(){if(this.length<=0)return this;const e=new ke({initialItems:[],keyPropName:this.keyPropName,mode:this.mode});return e.length=0,e.depth=this.depth+1,e.ancestorMap=this,fe(e,"empty"),e}get(e){const t=we[this.mode].lookup(this,e);if(t)return t.element.value}first(){return this.head?{key:this.head.element.key,value:this.head.element.value}:void 0}last(){return this.tail?{key:this.tail.element.key,value:this.tail.element.value}:void 0}rangeBefore(e,t=1/0,n=!0){const r=we[this.mode].lookup(this,e);if(!r||t<=0)return[];let o=n?r:we[this.mode].findMapNodeByDirection(this,r,"previous");if(!o)return[];const i=[{key:o.element.key,value:o.element.value}];for(;o&&i.length<t&&(o=we[this.mode].findMapNodeByDirection(this,o,"previous"),o);)i.push({key:o.element.key,value:o.element.value});return i.reverse()}rangeAfter(e,t=1/0,n=!0){const r=we[this.mode].lookup(this,e);if(!r||t<=0)return[];let o=n?r:we[this.mode].findMapNodeByDirection(this,r,"next");if(!o)return[];const i=[{key:o.element.key,value:o.element.value}];for(;o&&i.length<t&&(o=we[this.mode].findMapNodeByDirection(this,o,"next"),o);)i.push({key:o.element.key,value:o.element.value});return i}isEmpty(){return this.length<=0}forEach(e,t=!1){let n,r,o,i,s,c;for(this.shouldNextForEachBreak=!1,this.forEachNextFn=void 0,t?(o=this.tail,i="previous",s=this.length-1,c=()=>s--):(o=this.head,i="next",s=0,c=()=>s++);o&&!this.shouldNextForEachBreak;){const t=o.element;n=t.key,r=t.value;if(!1===(this.forEachNextFn||e).call(this,r,n,s))break;o=we[this.mode].findMapNodeByDirection(this,o,i),c()}}break(){this.shouldNextForEachBreak=!0}values(e=!1){const t=new Array(this.length);let n=0;return this.forEach((function(e){t[n]=e,n++}),e),t}keys(e=!1){const t=new Array(this.length);let n=0;return this.forEach((function(e,r){t[n]=r,n++}),e),t}keysValues(e=!1){const t=new Array(this.length);let n=0;return this.forEach((e,r)=>{t[n]={key:r,value:e},n++},e),t}map(e,t=!1){const n=new Array(this.length);let r=0;return this.forEach((t,o,i)=>{n[r]=e(t,o,i),r++},t),n}reduce(e,t,n=!1){let r,o=!1;if(arguments.length>1)r=t;else{if(!this.length)throw new TypeError("ImmutableLinkedOrderedMap type error: Reduce of empty map with no initial value");o=!0,r=(n?this.last():this.first()).value}const i=(t,n,o)=>{r=e(r,t,n,o)};return this.forEach((function(e,t,n){this.forEachNextFn=i,o||i(e,t,n)}),n),r}filter(e,t=!1){const n=[];let r=0;return this.forEach((t,o,i)=>{e(t,o,i)&&(n[r]=t,r++)},t),n}every(e,t=!1){let n=!0;return this.forEach((t,r,o)=>{if(!e(t,r,o))return n=!1,!1},t),n}some(e,t=!1){let n=!1;return this.forEach((t,r,o)=>{if(e(t,r,o))return n=!0,!1},t),n}}function ge(e){throw new Error(`ImmutableLinkedOrderedMap error: Mutation operation "${e}" is not allowed on a map in single mode on which a mutation operation already occurred once.`)}function be(e,t){return t.substring(0,e.length)===e}function Ae(e){throw new Error(`ImmutableLinkedOrderedMap error: Operation "${e}" is not allowed on a map in lightweight mode on which a mutation operation occurred once.`)}function Oe(){this.map={},this.keyValueList=new Ce,this.shouldNextForEachBreak=!1}function Ce(){this.head=null,this.tail=null,this.length=0,this.shouldNextForEachBreak=!1}Oe.prototype.set=function(e,t,n=!1){if(e in this.map)this.map[e].element.value=t;else{const r=n?"prepend":"append",o=this.keyValueList[r]({key:e,value:t});this.map[e]=o}},Oe.prototype.remove=function(e){if(!(e in this.map))throw new Error("key does not exist");this.keyValueList.remove(this.map[e]),delete this.map[e]},Oe.prototype.empty=function(){this.map={},this.keyValueList=new Ce,this.shouldNextForEachBreak=!1},Oe.prototype.isEmpty=function(){return this.getLength()<=0},Oe.prototype.get=function(e,t=!1){return this.map[e]&&(t?this.map[e]:this.map[e].element.value)},Oe.prototype.forEach=function(e,t=!1){let n,r;this.shouldNextForEachBreak=!1;const o=this;this.keyValueList.forEach((function(t,i){if(this.shouldNextForEachBreak)return!1;n=i.key,r=i.value;if(!1===e.call(o,n,r))return!1}),t)},Oe.prototype.break=function(){this.shouldNextForEachBreak=!0},Oe.prototype.getLength=function(){return this.keyValueList.length},Oe.prototype.toArray=function(){const e=new Array(this.getLength());let t=0;return this.forEach((function(n,r){e[t]=r,t++})),e},Oe.prototype.keys=function(){const e=new Array(this.getLength());let t=0;return this.forEach((function(n){e[t]=n,t++})),e},Oe.fromArray=function(e,t){const n=new Oe;for(let r=0;r<e.length;r++){const o=e[r];n.set(o[t],o)}return n},Ce.prototype.append=function(e){if(this.length++,this.head){const t=this.tail;this.tail=ae(t,null,e),t.next=this.tail}else this.tail=ae(null,null,e),this.head=this.tail;return this.tail},Ce.prototype.prepend=function(e){if(this.length++,this.head){const t=this.head;this.head=ae(null,t,e),t.previous=this.head}else this.tail=ae(null,null,e),this.head=this.tail;return this.head},Ce.prototype.remove=function(e){null!==e&&(e.previous?(e.previous.next=e.next,e.next?e.next.previous=e.previous:this.tail=e.previous,this.length--):e.next?(this.head=e.next,this.head.previous=null,this.length--):(this.head=null,this.tail=null,this.length=0),e=null)},Ce.prototype.pop=function(){if(this.tail){const e=this.tail.element;return this.remove(this.tail),e}},Ce.prototype.shift=function(){if(this.head){const e=this.head.element;return this.remove(this.head),e}},Ce.prototype.forEach=function(e,t=!1){let n,r,o,i;for(this.shouldNextForEachBreak=!1,t?(o=this.length-1,n=this.tail,r="previous",i=function(){o--}):(o=0,n=this.head,r="next",i=function(){o++});n&&!this.shouldNextForEachBreak;){const t=n.element;if(!1===e.call(this,o,t))break;n=n[r],i()}},Ce.prototype.break=function(){this.shouldNextForEachBreak=!0};const we={[re.SINGLE]:{ImmutableLinkedOrderedMapClass:class extends ke{constructor(e){const t=super(e);return t.mutationOperationOccurred=!1,t}set(e,t=!1){this.mutationOperationOccurred&&ge("set");const n=super.set(e,t);return this!==n&&(this.mutationOperationOccurred=!0),n}replace(e,t,n=!1,r=!1){this.mutationOperationOccurred&&ge("replace");const o=super.replace(e,t,n,r);return this!==o&&(this.mutationOperationOccurred=!0),o}unset(e){this.mutationOperationOccurred&&ge("unset");const t=super.unset(e);return this!==t&&(this.mutationOperationOccurred=!0),t}empty(){this.mutationOperationOccurred&&ge("empty");const e=super.empty();return this!==e&&(this.mutationOperationOccurred=!0),e}},lookup:function(e,t){const{heapMap:n,depth:r}=e;if(!n[t])return;let o;return n[t].forEach((e,t)=>{if(r>=e)return o=t,!1}),he(o)},updateHeapMap:function(e,t){const{heapMap:n,depth:r}=e,o=t.element.key;n[o]||(n[o]=new Oe),n[o].set(r,t,!0)},findMapNodeByDirection:function(e,t,n){if(t===e.tail&&"next"===n||t===e.head&&"previous"===n)return null;const{depth:r}=e,o=t[n];let i=null;return o.forEach((e,t)=>{if(r>=e)return i=t,!1}),i},makeImmutableLinkedOrderedMapNode:function(e,t,n,r,o){const{depth:i}=e,s=new Oe;s.set(i,t);const c=new Oe;return c.set(i,n),ae(s,c,{key:r,value:o})},bindNodes:function(e,t,n){const{depth:r}=e;t.next.set(r,n,!0),n.previous.set(r,t,!0)}},[re.MULTIWAY]:{ImmutableLinkedOrderedMapClass:class extends ke{constructor(e){const t=super(e);return t.childrenCount=0,t}},hydrate:function({version:e=""}={}){this.version=e},lookup:function(e,t){const{heapMap:n,depth:r,version:o}=e;if(!n[t])return;const i=n[t];let s=void 0;return i.forEach((e,t)=>{if(r>=e&&(t.forEach((e,t)=>{if(be(e,o))return s=t,!1}),s))return!1}),he(s)},fork:function(e,t){return t.version=e.version.length?`${e.version}${++e.childrenCount}#`:++e.childrenCount+"#",t},updateHeapMap:function(e,t){const{heapMap:n,depth:r,version:o}=e,i=t.element.key;n[i]||(n[i]=new Oe),n[i].map[r]||n[i].set(r,new Oe,!0),n[i].get(r).set(o,t,!0)},findMapNodeByDirection:function(e,t,n){if(t===e.tail&&"next"===n||t===e.head&&"previous"===n)return null;const{depth:r,version:o}=e,i=t[n];let s=null;return i.forEach((e,t)=>{if(r>=e&&(t.forEach((e,t)=>{if(be(e,o))return s=t,!1}),s))return!1}),s},makeImmutableLinkedOrderedMapNode:function(e,t,n,r,o){const{depth:i,version:s}=e,c=new Oe,a=new Oe;a.set(s,t),c.set(i,a);const u=new Oe,l=new Oe;return l.set(s,n),u.set(i,l),ae(c,u,{key:r,value:o})},bindNodes:function(e,t,n){const{depth:r,version:o}=e;t.next.map[r]||t.next.set(r,new Oe,!0),t.next.get(r).set(o,n,!0),n.previous.map[r]||n.previous.set(r,new Oe,!0),n.previous.get(r).set(o,t,!0)}},[re.LIGHTWEIGHT]:{ImmutableLinkedOrderedMapClass:class extends ke{constructor(e){const t=super(e);return t.mutationOperationOccurred=!1,t}set(e,t=!1){this.mutationOperationOccurred&&Ae("set");const n=super.set(e,t);return this!==n&&(this.mutationOperationOccurred=!0),n}replace(e,t,n=!1,r=!1){this.mutationOperationOccurred&&Ae("replace");const o=super.replace(e,t,n,r);return this!==o&&(this.mutationOperationOccurred=!0),o}unset(e){this.mutationOperationOccurred&&Ae("unset");const t=super.unset(e);return this!==t&&(this.mutationOperationOccurred=!0),t}empty(){this.mutationOperationOccurred&&Ae("empty");const e=super.empty();return this!==e&&(this.mutationOperationOccurred=!0),e}get(e){return this.mutationOperationOccurred&&Ae("get"),super.get(e)}first(){return this.mutationOperationOccurred&&Ae("first"),super.first()}last(){return this.mutationOperationOccurred&&Ae("last"),super.last()}isEmpty(){return this.mutationOperationOccurred&&Ae("isEmpty"),super.isEmpty()}forEach(e,t=!1){return this.mutationOperationOccurred&&Ae("forEach"),super.forEach(e,t)}break(){return this.mutationOperationOccurred&&Ae("break"),super.break()}values(e=!1){return this.mutationOperationOccurred&&Ae("values"),super.values(e)}keys(e=!1){return this.mutationOperationOccurred&&Ae("keys"),super.keys(e)}keysValues(e=!1){return this.mutationOperationOccurred&&Ae("keysValues"),super.keysValues(e)}map(e,t=!1){return this.mutationOperationOccurred&&Ae("map"),super.map(e,t)}reduce(e,t,n=!1){return this.mutationOperationOccurred&&Ae("reduce"),super.reduce(e,t,n)}filter(e,t=!1){return this.mutationOperationOccurred&&Ae("filter"),super.filter(e,t)}every(e,t=!1){return this.mutationOperationOccurred&&Ae("every"),super.every(e,t)}some(e,t=!1){return this.mutationOperationOccurred&&Ae("some"),super.some(e,t)}},lookup:function(e,t){const{heapMap:n}=e;return he(n[t])},updateHeapMap:function(e,t){const{heapMap:n}=e;n[t.element.key]=t},findMapNodeByDirection:function(e,t,n){return t[n]},makeImmutableLinkedOrderedMapNode:function(e,t,n,r,o){return ae(t,n,{key:r,value:o})},bindNodes:function(e,t,n){t.next=n,n.previous=t}}};ke.MODE=re,ke.isMap=e=>!(!e||!0!==e[ne]);const Me=(e={})=>new ke({...e});function Ne(e,t,n){e.prop("checked",t),e.trigger("change")}function Ee(e){return null===e&&(e=[]),e}function Pe(e,t,n,r){return e.nextUntil(t)}function Ie(e,t,n,r){return e.prevUntil(t)}function De(e){return e.orderedByI=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return e.values().sort((function(e,n){return t?n.i-e.i:e.i-n.i}))},e}[["lazyMap",(e={})=>Me({...e,lazy:!0})],["map",Me]].map(([e,t])=>ke[e]=t);var Le=0;function Se(e,t){var n=t,r=e.data(n.options.checkedKeyDataAttributeName);n.selectedMap.get(r)&&(n.selectedMap=De(n.selectedMap.unset(r)));var o=e.data(n.options.keyDataAttributeName)||++Le;e.data(n.options.checkedKeyDataAttributeName,o);var i=e.val(),s=n.selectedMap.set(function(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}({},o,{$el:e,key:o,value:i||void 0,i:e.index(n.options.checkboxes)}));n.selectedMap=De(s)}function je(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}const Be=function(e,t,n){return function(){function t(n,r){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this.$el=e(n),this.options=r,this.selectedMap=De(new ke({mode:ke.MODE.LIGHTWEIGHT})),this.selectedRanges=[],this.$lastSelected=void 0,this.$beforeLastSelected=void 0,this.init()}var r,o,i;return r=t,(o=[{key:"init",value:function(){this.options.checkboxes=Ee(this.options.checkboxes),this.options.sync=Ee(this.options.sync),this.initListeners(),this.initState()}},{key:"initListeners",value:function(){var t=this;this.selectCheckboxListenerFn=function(n){t.selectCheckboxListener(e(this),n)},this.$el.on("change",(function(n){return t.onChangeCheckboxSelectAll(e(this),n)})),this.options.eventsElement?(this.options.checkboxes&&e(this.options.eventsElement).on("click",this.options.checkboxes,this.selectCheckboxListenerFn),this.options.sync&&e(this.options.eventsElement).on(this.options.syncEvent,this.options.sync,this.selectCheckboxListenerFn)):(this.options.checkboxes&&e(this.options.checkboxes).on("click",this.selectCheckboxListenerFn),this.options.sync&&e(this.options.sync).on(this.options.syncEvent,this.selectCheckboxListenerFn)),e(n).on("mousedown",this.options.sync,(function(e){e.shiftKey&&e.preventDefault()}))}},{key:"initState",value:function(){if(this.$el.prop("checked"))this.checkAll();else{var t=e(this.options.checkboxes),n=t.filter(":checked");t.length===n.length?this.checkAll():n.length&&n.each((function(){e(this).click()}))}}},{key:"uncheckAll",value:function(){Ne(this.$el,!1)}},{key:"checkAll",value:function(){Ne(this.$el,!0)}},{key:"destroy",value:function(){this.$el.off("change"),this.options.eventsElement?(this.options.checkboxes&&e(this.options.eventsElement).off("click",this.options.checkboxes,this.selectCheckboxListenerFn),this.options.sync&&e(this.options.eventsElement).off(this.options.syncEvent,this.options.sync,this.selectCheckboxListenerFn)):(this.options.checkboxes&&e(this.options.checkboxes).off("click",this.selectCheckboxListenerFn),this.options.sync&&e(this.options.sync).off(this.options.syncEvent,this.selectCheckboxListenerFn))}},{key:"selectCheckboxListener",value:function(t,n){var r=n.ctrlKey||n.metaKey,o=n.shiftKey,i=e(n.target),s=t.is(this.options.checkboxes)?t:this.options.checkboxResolve(t,this),c=t.is(this.options.sync)?t:this.options.itemResolve(t,this),a=i.is(this.options.checkboxes);a&&this.options.targetCheckStopPropagation(n,this);var u=a||r||o||this.options.syncEvenWithoutCtrl;u&&(this.toggle(e,s,void 0),this.toggle(e,c,void 0,o)),function(e,t,n){var r=!0,o=!0,i=n;e(i.options.checkboxes).each((function(){e(this).prop("checked")?o=!1:r=!1})),i.$el.prop("checked",r),t&&(r?i.options.onAllChecked(i.selectedMap):o?i.options.onAllUnchecked(i.selectedMap):i.options.onNotAllChecked(i.selectedMap))}(e,u,this)}},{key:"onChangeCheckboxSelectAll",value:function(t,n){var r=t.prop("checked"),o=this;e(this.options.checkboxes).each((function(){o.toggle(e,e(this),r)})),e(this.options.sync).each((function(){o.toggle(e,e(this),r)})),r?this.options.onAllChecked(this.selectedMap):(this.selectedMap=De(this.selectedMap.empty()),this.selectedRanges=[],this.options.onAllUnchecked(this.selectedMap))}},{key:"toggle",value:function(e,t,n,r){if(t.hasClass(this.options.checkedClassName)){if(!0!==n&&(t.removeClass(this.options.checkedClassName),t.is(this.options.checkboxes))){t.prop("checked",!1);var o=t.data(this.options.checkedKeyDataAttributeName);this.selectedMap.get(o)&&(this.selectedMap=De(this.selectedMap.unset(o)))}}else!0!==n&&void 0!==n||(t.addClass(this.options.checkedClassName),t.is(this.options.checkboxes)&&(t.prop("checked",!0),Se(t,this)),this.$beforeLastSelected=this.$lastSelected,this.$lastSelected=t);r&&(t.is(this.options.checkboxes)&&this.options.handleShiftForCheckbox||!t.is(this.options.checkboxes)&&!this.options.handleShiftForCheckbox)&&function(e,t,n){var r,o=n,i={prev:o.options.prev,next:o.options.next};if(o.options.usePrevUntilNextUntilForSync?(r=e(o.options.sync),i.prev=Ie,i.next=Pe):r=e(o.options.checkboxes),!(r.filter(".".concat(o.options.checkedClassName)).length<=1)){var s=t.hasClass(o.options.checkedClassName),c=o.selectedMap.values();if(s&&o.selectedMap.length>1){var a,u,l,h=o.options.usePrevUntilNextUntilForSync?o.options.itemResolve(c[c.length-2].$el,o):(t.is(o.options.sync)?(t=o.options.checkboxResolve(t,o))&&void 0:void 0)||c[c.length-2].$el,p=r.index(h),d=r.index(t);if(p>d?(u=!0,a="next"):(u=!1,a="prev"),i[a](t,h,r,o).each((function(){var t=e(this);o.toggle(e,t,!0),t.is(o.options.checkboxes)?o.toggle(e,o.options.itemResolve(t,o),!0):o.toggle(e,o.options.checkboxResolve(t,o),!0)})),u){for(var f=r.index(t)+1,x=r.eq(f);x.length&&f<=r.length-1&&x.hasClass(o.options.checkedClassName);)f=r.index(x)+1,x=r.eq(f);l=f-1}else{for(var m=r.index(t)-1,y=r.eq(m);y.length&&m>=0&&y.hasClass(o.options.checkedClassName);)m=r.index(y)-1,y=r.eq(m);l=m+1}o.selectedRanges.unshift({from:l,to:d})}else{t.is(o.options.sync)&&(t=o.options.checkboxResolve(t,o)),o.options.usePrevUntilNextUntilForSync&&t.is(o.options.checkboxes)&&(t=o.options.itemResolve(t,o));for(var v=r.index(t),k=0;k<o.selectedRanges.length;k++){var g=o.selectedRanges[k],b=g.from,A=g.to;if(v>=b&&v<=A||v>=A&&v<=b){(A>v?r.slice(v+1,A+1):r.slice(A,v)).each((function(){var t=e(this);o.toggle(e,t,!1),t.is(o.options.checkboxes)?o.toggle(e,o.options.itemResolve(t,o),!1):o.toggle(e,o.options.checkboxResolve(t,o),!1)}));break}}}}}(e,t,this)}}])&&je(r.prototype,o),i&&je(r,i),t}()},Te=function(e){return function(t,n){var r=n;return t.find("*").filter((function(){return e(this).is(r.options.checkboxes)}))}};function Fe(e,t){var n=t;return e.closest(n.options.sync)}function Re(e,t){e.stopPropagation()}const Ue=function(e){return function(t,n,r,o){var i=e([]),s=!1;return r.each((function(){var r=e(this);if(!r.is(t))return!r.is(n)&&void(s&&(i=i.add(r)));s=!0})),i}},$e=function(e){return function(t,n,r,o){var i=e([]),s=!1;return r.each((function(){var r=e(this);if(!r.is(n))return!r.is(t)&&void(s&&(i=i.add(r)));s=!0})),i}},Ve=function(e,t,n){return{checkboxes:null,sync:null,onAllChecked:function(){},onAllUnchecked:function(){},onNotAllChecked:function(){},checkboxResolve:Te(e),itemResolve:Fe,targetCheckStopPropagation:Re,eventsElement:n,syncEvent:"click",handleShiftForCheckbox:!1,usePrevUntilNextUntilForSync:!0,next:Ue,prev:$e,checkedClassName:"jquery-multi-select-checkbox-checked",checkedKeyDataAttributeName:"jquery-multi-select-checkbox-checked-key",keyDataAttributeName:"key"}};var We,He=void 0!==r.g?r.g:window,Ke=t()&&t().fn&&t()||void 0,qe=(We=0,function(e){return e.fn.multiselectCheckboxInitPluginID||(We++,e.fn.multiselectCheckboxInitPluginID=We),e.fn.multiselectCheckboxInitPluginID}),ze={};function Ge(e){var t=e.fn.multiselectCheckbox,n=e.fn.multiselectCheckboxInitPluginID,r=qe(e);ze[r]=ze[r]?ze[r]:{defaultOptions:Ve(e,0,He.document),jQueryMultiselectCheckbox:Be(e,0,He.document)};var o=ze[r],i=o.defaultOptions,s=o.jQueryMultiselectCheckbox;e.fn.multiselectCheckbox=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];var c;return this.each((function(n,o){var a=e(o),u="destroy"===t,l=a.data("multiselectCheckbox");if(!l){if(u)return;var h=e.extend({},i,a.data(),e.isPlainObject(t)&&t);l=new s(o,h),a.data("multiselectCheckbox",l)}if("string"==typeof t){var p=l[t];"function"==typeof p&&(c=p.apply(l,r))===l&&(c=void 0),u&&a.removeData("multiselectCheckbox")}})),void 0!==c?c:this},e.fn.multiselectCheckbox.Constructor=s,e.fn.multiselectCheckbox.setDefaults=function(t){var n="function"==typeof t?t(e,He,He.document):t;e.extend(i,e.isPlainObject(n)&&n)},e.fn.multiselectCheckbox.noConflict=function(){return e.fn.multiselectCheckbox=t,e.fn.multiselectCheckboxInitPluginID=n,e.fn.multiselectCheckbox}}Ke&&Ge(Ke)})(),o=o.default})()}));