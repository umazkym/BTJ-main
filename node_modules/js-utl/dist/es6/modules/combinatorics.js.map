{"version":3,"sources":["../../../src/modules/combinatorics.js"],"names":["nestedMapSet","nestedMapHas","mapYield","arrayOrArrayLike","yieldCombinationsWithoutRepetition","items","numberOfItemsPerCombination","yieldCopy","l","length","prefix","recurse","nextIndex","i","push","pop","uniqueProgressiveIncrementalCombinations","len","last","ret","map","item","combination","yieldUniqueProgressiveIncrementalCombinations","yieldAllSubsequences","yieldUniqueSubsequences","Map","subsequence","yieldPermutations","currentPermutationPrefix","currentPermutationIndicesMap","permute"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2022 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Combinatorics utility functions.\n */\n\nimport { nestedMapSet, nestedMapHas, mapYield } from \"./core\";\nimport { arrayOrArrayLike } from \"./array\";\n\n/**\n * Yields all the combinations of an array without repetitions (binomial coefficient).\n *\n * @generator\n * @param {Array} items An array.\n * @param {number} numberOfItemsPerCombination The number of elements in each combination\n *                                             (this function assumes it to be less than \"items.length\"\n *                                             and greater than 0).\n * @param {boolean} yieldCopy True if the yielded combination should be a copy (default) or\n *                            the internal array used during the generation of the current combination.\n * @yields {Array} The next combination.\n */\nexport const yieldCombinationsWithoutRepetition = function* (\n  items,\n  numberOfItemsPerCombination,\n  yieldCopy = true\n) {\n  const l = items.length;\n  const prefix = [];\n\n  const recurse = function* recurse(\n    items,\n    l,\n    prefix,\n    numberOfItemsPerCombination,\n    nextIndex = 0\n  ) {\n    // Same as:\n    // if (nextIndex === numberOfItemsPerCombination) {\n    if (prefix.length === numberOfItemsPerCombination) {\n      // Base case:\n      yield yieldCopy ? arrayOrArrayLike(prefix) : prefix;\n    } else {\n      // Recurrent case:\n      for (\n        let i = nextIndex;\n        i < l &&\n        // Remaining needed items\n        numberOfItemsPerCombination - prefix.length <=\n          // Remaining available items\n          l - i;\n        i++\n      ) {\n        prefix.push(items[i]);\n        yield* recurse(items, l, prefix, numberOfItemsPerCombination, i + 1);\n        prefix.pop();\n      }\n    }\n  };\n\n  yield* recurse(items, l, prefix, numberOfItemsPerCombination);\n};\n\n/**\n * Generate unique, progressive and incremental combinations.\n *\n * @param {Array} items An array of items.\n * @return {Array[]} An array of arrays, each representing a unique progressive incremental combination.\n *                   An empty array is returned if the given items array is empty.\n */\nexport const uniqueProgressiveIncrementalCombinations = items => {\n  const len = items.length;\n  if (len === 0) {\n    return [];\n  }\n\n  const last = arrayOrArrayLike(items); // Shallow copy/clone of the given array.\n  if (len === 1) {\n    // [1] => [[1]]\n    return [last];\n  }\n\n  const ret = [];\n  // [1], [2], [3], ..., [n]\n  items.map(item => ret.push([item]));\n\n  if (len > 2) {\n    // There  are at least three items.\n    for (\n      let numberOfItemsPerCombination = 2;\n      numberOfItemsPerCombination < len;\n      numberOfItemsPerCombination++\n    ) {\n      for (const combination of yieldCombinationsWithoutRepetition(\n        items,\n        numberOfItemsPerCombination\n      )) {\n        ret.push(combination);\n      }\n    }\n  }\n\n  ret.push(last);\n  return ret;\n};\n\n/**\n * Yields unique, progressive and incremental combinations.\n *\n * @generator\n * @param {Array} items An array of items.\n * @param {boolean} yieldCopy True if some of the yielded combinations should be a copy (default)\n *                         of the corresponding internal array used during the generation of the current combination\n *                         or that same array should be returned (if \"yieldCopy\" is \"false\").\n * @yields {Array} An array, each representing the next unique progressive incremental combination.\n *                 An empty array is yielded if the given items array is empty.\n */\nexport const yieldUniqueProgressiveIncrementalCombinations = function* (\n  items,\n  yieldCopy = true\n) {\n  const len = items.length;\n  if (len === 0) {\n    return;\n  }\n\n  const last = yieldCopy ? arrayOrArrayLike(items) : items; // Shallow copy/clone of the given array.\n  if (len === 1) {\n    // [1] => [[1]]\n    yield last;\n    return;\n  }\n\n  // [1], [2], [3], ..., [n]\n  yield* mapYield(items, item => [item]);\n\n  if (len > 2) {\n    // There  are at least three items.\n    for (\n      let numberOfItemsPerCombination = 2;\n      numberOfItemsPerCombination < len;\n      numberOfItemsPerCombination++\n    ) {\n      for (const combination of yieldCombinationsWithoutRepetition(\n        items,\n        numberOfItemsPerCombination,\n        yieldCopy\n      )) {\n        yield combination;\n      }\n    }\n  }\n\n  yield last;\n};\n\n/**\n * Yields all the subsequences of the given array of items.\n *\n * @generator\n * @param {Array} items An array of items to use to yield subsequences.\n * @yields {Array} The next subsequence.\n */\nexport const yieldAllSubsequences = function* (items) {\n  const l = items.length;\n  for (let i = 0; i <= l; i++) {\n    for (const combination of yieldCombinationsWithoutRepetition(items, i)) {\n      yield combination;\n    }\n  }\n};\n\n/**\n * Yields only the unique subsequences of the given array of items.\n *\n * @generator\n * @param {Array} items An array of items to use to yield subsequences.\n * @yields {Array} The next unique subsequence.\n */\nexport const yieldUniqueSubsequences = function* (items) {\n  const map = new Map();\n  yield [];\n  for (const subsequence of yieldAllSubsequences(items)) {\n    if (!nestedMapHas(map, subsequence)) {\n      nestedMapSet(map, subsequence, true);\n      yield subsequence;\n    }\n  }\n};\n\n/**\n * Yields all the permutations of the given array of items.\n *\n * @generator\n * @param {Array} items An array of items to use to yield permutations.\n * @param {boolean} yieldCopy True if the yielded permutation should be a copy (default) or\n *                            the internal array used during the generation of the current permutation.\n * @yields {Array} The next permutation.\n */\nexport const yieldPermutations = function* (items, yieldCopy = true) {\n  const currentPermutationPrefix = [];\n  const currentPermutationIndicesMap = {};\n  const permute = function* () {\n    if (currentPermutationPrefix.length === items.length) {\n      yield yieldCopy\n        ? arrayOrArrayLike(currentPermutationPrefix)\n        : currentPermutationPrefix;\n    } else {\n      for (let i = 0; i < items.length; i++) {\n        if (currentPermutationIndicesMap[i]) {\n          continue;\n        }\n        currentPermutationPrefix.push(items[i]);\n        currentPermutationIndicesMap[i] = true;\n        yield* permute();\n        delete currentPermutationIndicesMap[i];\n        currentPermutationPrefix.pop();\n      }\n    }\n  };\n  yield* permute();\n};\n"],"file":"combinatorics.js"}