{"version":3,"sources":["../../../../src/modules/core/index.js"],"names":["shallowEqual","objectPropEqual","is","config","uniqueIdPrefix","elementUniqueIdPrefix","checkNetworkURI","isObjectEmpty","obj","prop","Object","prototype","hasOwnProperty","call","objPrototypeToString","toString","isObject","isPlainObject","constructor","isArray","something","isCallable","v","isEmpty","data","length","isEmptyOr0","getGlobalObject","global","window","JSUtlUniqueIdCounterProp","uniqueId","globalObject","uniqueIdCounter","nestedPropertyValue","props","root","i","getNestedPropertyValue","hasNestedPropertyValue","setNestedPropertyValue","value","prev","nestedMapSet","map","keys","current","key","nested","get","Map","WeakMap","newMap","set","nestedMapHas","l","has","nestedMapGet","treeMapSubtree","Symbol","nestedTreeMapSet","rootMap","MapConstructor","node","nestedTreeMapHas","nestedTreeMapGet","lastIndex","lastKey","mapYield","items","fn","thisArg","boundFn","bind","deepArrayCompare","arr1","arr2","arrayToStringStr","deepObjectCompare","obj1","obj2","property","nestedObjectConstructValue","nestedPropsDef","isRootArrayIfRootFalsy","leaf","propDef","propKey","propDefault","cloneDeeplyJSON","JSON","parse","stringify","isReferenceType","isPrimitiveType","hasCyclicReference","stackSet","detected","detect","indexOfObj","indexOf","push","k","splice","typeToStr","type","cloneObjDeeply","object","newObject","clone","Error","deepObjectExtend","destinationObject","sourceObject","options","extendArrays","deepObjectCloningExtend","args","extend","destinationObj","sourceObjects","last","pop","extendDecorate","rest","rules","initialRetValue","matchedRulesMap","callbacksMap","paths","mapKeys","currentStack","currentPath","path","matchRule","rule","RegExp","match","matchArrayRule","arrayRule","ruleMatches","matchRules","callbacks","callback","retValue","shallowExtend","includesTypeCoercion","array","valueOfArray","isUndefined","isInt","Number","isInteger","ctypeDigit","a","Boolean","isIntegerOrIntegerStr","findIndex","el","firstPropValue","isStrictlyTrue","isTruthy","allTruthy","values","every","allNotUndefined","isJSONString","str","e","noOpFn","partialShallowEqual","partialObj","reduce","carry","shallowObjectDiff","objA","objB","diff","keysA","keysB","mapObject","fromEntries","entries","index","mapToObject","arr","res","propSelection","prototypeChainProperties","stopAtPrototype","stopAtPrototypeInclude","isStopPrototype","stop","properties","getOwnPropertyNames","getPrototypeOf","propname","getfn","setfn","propObj","defineProperties","defineProperty","o","p","descriptor","configurable","enumerable","writable","completeObjectAssign","target","sources","forEach","source","descriptors","getOwnPropertyDescriptor","getOwnPropertySymbols","sym"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2022 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport { shallowEqual, objectPropEqual, is } from \"./compare\";\nexport { shallowEqual, objectPropEqual, is };\n\n/**\n * Core utility functions.\n */\n\n/**\n * Optional configuration with useful properties.\n *\n * @type {Object}\n */\nexport const config = {\n  uniqueIdPrefix: \"\",\n  elementUniqueIdPrefix: \"\",\n  checkNetworkURI: null,\n};\n\n/**\n * Tests if an object is empty.\n *\n * @param {Object} obj The object to test.\n * @return {boolean} \"true\" if the given object is empty (does not have own properties), \"false\" otherwise.\n */\nexport function isObjectEmpty(obj) {\n  for (const prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @type {string}\n */\nconst objPrototypeToString = Object.prototype.toString.call({});\n\n/**\n * Tests if a variable is an object.\n *\n * @param {*} obj The variable to test.\n * @return {boolean} \"true\" if \"obj\" is indeed an object, \"false\" otherwise.\n */\nexport const isObject = function (obj) {\n  return objPrototypeToString === Object.prototype.toString.call(obj);\n};\n\n/**\n * Tests if a variable is a plain object (i.e. \"{}\", an object literal).\n *\n * @param {*} obj The variable to test.\n * @return {boolean} \"true\" if \"obj\" is a plain object, \"false\" otherwise.\n */\nexport const isPlainObject = obj => {\n  return (\n    obj !== null &&\n    typeof obj === \"object\" &&\n    obj.constructor === Object &&\n    isObject(obj)\n  );\n};\n\n/**\n * Tests to see whether something is an array or not.\n *\n * @param {*} something A variable to check whether it is an array or not.\n * @return {boolean} True if the parameter passed in is an array, false otherwise.\n */\nexport function isArray(something) {\n  return (\n    Object.prototype.toString.call(something) ===\n    Object.prototype.toString.call([])\n  );\n}\n\n/**\n * Tests if the given value is callable.\n *\n * @param {*} v The value.\n * @return {boolean} True if callable, false otherwise.\n */\nexport function isCallable(v) {\n  return typeof v === \"function\";\n}\n\n/**\n * Tests if a variable is empty returning true for empty strings and empty arrays.\n *\n * @param {*} data The variable to test.\n * @return {boolean} True if the variable is empty, false otherwise.\n */\nexport function isEmpty(data) {\n  return !data || data.length === 0;\n}\n\n/**\n * Tests if a variable is empty or 0 (\"0\" string) returning true for empty strings,\n * empty arrays, the \"0\" string and empty values.\n *\n * @param {*} data The variable to test.\n * @return {boolean} True if the variable is empty or \"0\", false otherwise.\n */\nexport function isEmptyOr0(data) {\n  return !data || data === \"0\" || data.length === 0;\n}\n\n/**\n * Returns a reference to the global object.\n *\n * @return {Window|global} The global object (this function is cross-platform aware).\n */\nexport function getGlobalObject() {\n  return typeof global !== \"undefined\" ? global : window;\n}\n\n/**\n * @type {string}\n */\nconst JSUtlUniqueIdCounterProp = \"JSUtlUniqueIdCounterLEzKKl87QCDxwVH\";\n\n/**\n * Generates a unique ID which can be used as an \"id\" attribute.\n *\n * @param {string|undefined} [uniqueIdPrefix] Local unique ID prefix which overrides the prefix\n *                                            set on the \"config\" configuration object.\n * @return {string} The unique ID.\n */\nexport function uniqueId(uniqueIdPrefix = void 0) {\n  const globalObject = getGlobalObject();\n  globalObject[JSUtlUniqueIdCounterProp] =\n    globalObject[JSUtlUniqueIdCounterProp] || 0;\n  globalObject[JSUtlUniqueIdCounterProp]++;\n  const uniqueIdCounter = globalObject[JSUtlUniqueIdCounterProp];\n  const uniqueId = (uniqueIdPrefix || config.uniqueIdPrefix) + uniqueIdCounter;\n  return uniqueId;\n}\n\n/**\n * Gets a nested value of an object given an array of nested property names (keys).\n *\n * @param {Object} data JS POJO object.\n * @param {Array} props Array of object nested keys.\n * @return {*} The leaf value.\n */\nexport function nestedPropertyValue(data, props) {\n  let root = data;\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i];\n    root = root[prop];\n  }\n  return root;\n}\n\n/**\n * Alias for \"nestedPropertyValue\".\n *\n * @alias\n */\nexport const getNestedPropertyValue = nestedPropertyValue;\n\n/**\n * Checks if a nested value of an object given an array of nested property names (keys) exists.\n *\n * @param {Object} data JS POJO object.\n * @param {Array} props Array of object nested keys.\n * @return {boolean} True if the nested key exists, false otherwise.\n */\nexport function hasNestedPropertyValue(data, props) {\n  if (!props.length) {\n    return false;\n  }\n  let root = data;\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i];\n    if (!root[prop]) {\n      return false;\n    }\n    root = root[prop];\n  }\n  return true;\n}\n\n/**\n * Sets a nested value of an object given an array of nested property names (keys).\n *\n * @param {Object} data JS POJO object.\n * @param {Array} props Array of object nested keys.\n * @param {*} value Leaf value.\n * @return {undefined}\n */\nexport function setNestedPropertyValue(data, props, value) {\n  if (!props.length) {\n    return;\n  }\n  let root = data;\n  let prev = null;\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i];\n    if (typeof root[prop] !== \"object\") {\n      root[prop] = {};\n    }\n    prev = root;\n    root = root[prop];\n  }\n  if (prev) {\n    prev[props[props.length - 1]] = value;\n  }\n}\n\n/**\n * Sets a nested value on a nested map.\n *\n * @param {Map|WeakMap} map A map or weak map.\n * @param {Array} keys Array of keys to traverse. Each key will lead to a nested map.\n * @param {*} value The value to set at the inner key.\n * @return {undefined}\n */\nexport const nestedMapSet = (map, keys, value) => {\n  let i = 0;\n  let current = map;\n  while (i < keys.length - 1) {\n    const key = keys[i];\n    const nested = current.get(key);\n    if (nested instanceof Map || nested instanceof WeakMap) {\n      current = nested;\n    } else {\n      const newMap = new Map();\n      current.set(key, newMap);\n      current = newMap;\n    }\n    i++;\n  }\n  current.set(keys[i], value);\n};\n\n/**\n * Tests if a map has the given nested keys.\n *\n * @param {Map|WeakMap} map A map or weak map.\n * @param {Array} keys Array of keys to check. Each key represents a nested map.\n * @return {boolean} \"true\" if all the nested keys exist, false otherwise.\n */\nexport const nestedMapHas = (map, keys) => {\n  let current = map;\n  let i = 0;\n  const l = keys.length;\n  while (\n    (current instanceof Map || current instanceof WeakMap) &&\n    current.has(keys[i]) &&\n    i < l\n  ) {\n    current = current.get(keys[i]);\n    i++;\n  }\n  return i == l;\n};\n\n/**\n * Gets a value from a nested map.\n *\n * @param {Map|WeakMap} map A map or weak map.\n * @param {Array} keys Array of keys. Each key represents a nested map.\n * @return {*} The value of the map or \"undefined\" if there is no value for the given nested keys.\n */\nexport const nestedMapGet = (map, keys) => {\n  let current = map;\n  let i = 0;\n  const l = keys.length;\n  while (\n    (current instanceof Map || current instanceof WeakMap) &&\n    current.has(keys[i]) &&\n    i < l\n  ) {\n    current = current.get(keys[i]);\n    i++;\n  }\n  return i == l ? current : void 0;\n};\n\n/**\n * @type {Symbol}\n */\nconst treeMapSubtree = Symbol(\"treeMapSubtree\");\n\n/**\n * Sets a nested value on a nested tree map.\n *\n * @param {Map|WeakMap} rootMap A map or weak map to use as the root.\n * @param {Array} keys Array of keys to traverse. Each key will lead to a nested node of the tree map.\n * @param {*} value The value to set at the inner nested key.\n * @return {undefined}\n */\nexport const nestedTreeMapSet = (rootMap, keys, value) => {\n  let i = 0;\n  let current = rootMap;\n  const MapConstructor = rootMap instanceof WeakMap ? WeakMap : Map;\n  while (i < keys.length - 1) {\n    const key = keys[i];\n    const nested = current.get(key);\n    if (nested) {\n      current =\n        nested[treeMapSubtree] ||\n        (nested[treeMapSubtree] = new MapConstructor());\n    } else {\n      const newMap = new MapConstructor();\n      const node = {\n        [treeMapSubtree]: newMap,\n        value: void 0,\n      };\n      current.set(key, node);\n      current = newMap;\n    }\n    i++;\n  }\n  const key = keys[i];\n  !current.has(key)\n    ? current.set(key, {\n        value,\n      })\n    : (current.get(key).value = value);\n};\n\n/**\n * Tests if a tree map has the given nested keys.\n *\n * @param {Map|WeakMap} rootMap The root of the map or weak map.\n * @param {Array} keys Array of keys to check. Each key represents a nested node of the tree map.\n * @return {boolean} \"true\" if all the nested keys exist, false otherwise.\n */\nexport const nestedTreeMapHas = (rootMap, keys) => {\n  let current = rootMap;\n  let i = 0;\n  const l = keys.length;\n  while (\n    (current instanceof Map || current instanceof WeakMap) &&\n    current.has(keys[i]) &&\n    i < l\n  ) {\n    current = current.get(keys[i])[treeMapSubtree];\n    i++;\n  }\n  return i == l;\n};\n\n/**\n * Gets a value from a nested tree map.\n *\n * @param {Map|WeakMap} rootMap The root of the map or weak map.\n * @param {Array} keys Array of keys. Each key represents a nested node of the tree map.\n * @return {*} The value of the tree map or \"undefined\" if there is no value for the given nested keys.\n */\nexport const nestedTreeMapGet = (rootMap, keys) => {\n  let current = rootMap;\n  let i = 0;\n  const lastIndex = keys.length - 1;\n  while (\n    (current instanceof Map || current instanceof WeakMap) &&\n    current.has(keys[i]) &&\n    i < lastIndex\n  ) {\n    current = current.get(keys[i])[treeMapSubtree];\n    i++;\n  }\n  if (i === lastIndex && current) {\n    const lastKey = keys[i];\n    if (current.has(lastKey)) {\n      const nested = current.get(lastKey);\n      return nested.value;\n    }\n  }\n  return void 0;\n};\n\n/**\n * Yields values of an array mapping the yielded value.\n *\n * @generator\n * @param {Array} items An array of items.\n * @param {*} fn The function to call.\n *               The function will receive, in order the nth item,\n *               the index of the item in the array of items and the whole items array\n *               as parameters.\n * @param {*} thisArg Optional this arg of the called function (defaults to undefined).\n * @yields {*} The next yielded mapped item.\n */\nexport function* mapYield(items, fn, thisArg = void 0) {\n  items.map();\n  const boundFn = fn.bind(thisArg);\n  for (let i = 0; i < items.length; i++) {\n    yield boundFn(items[i], i, items);\n  }\n}\n\n/**\n * Compares two arrays deeply.\n *\n * @param {Array} arr1 First array.\n * @param {Array} arr2 Second array.\n * @return {boolean} True if they are equal (same indexes and same values), false otherwise.\n */\nexport function deepArrayCompare(arr1, arr2) {\n  if (arr1.length != arr2.length) {\n    return false;\n  }\n  const toString = Object.prototype.toString;\n  const arrayToStringStr = toString.call([]);\n  for (let i = 0; i < arr1.length; i++) {\n    if (!(i in arr2)) {\n      return false;\n    } else if (isPlainObject(arr1[i])) {\n      if (\n        !isPlainObject(arr2[i]) ||\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        !deepObjectCompare(arr1[i], arr2[i])\n      ) {\n        return false;\n      }\n    } else if (arrayToStringStr === toString.call(arr1[i])) {\n      if (\n        arrayToStringStr !== toString.call(arr2[i]) ||\n        !deepArrayCompare(arr1[i], arr2[i])\n      ) {\n        return false;\n      }\n    } else {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Compare two objects deeply.\n *\n * @param {Object} obj1 First object.\n * @param {Object} obj2 Second object.\n * @return {boolean} True if they are equal (same properties and same values), false otherwise.\n */\nexport function deepObjectCompare(obj1, obj2) {\n  const toString = Object.prototype.toString;\n  const arrayToStringStr = toString.call([]);\n  for (const property in obj1) {\n    if (!(property in obj2)) {\n      // `obj2[property]` does not contain the property of `obj1`.\n      return false;\n    } else if (isPlainObject(obj1[property])) {\n      // `obj1[property]` is an object.\n      if (\n        !isPlainObject(obj2[property]) ||\n        !deepObjectCompare(obj1[property], obj2[property])\n      ) {\n        // `obj2[property]` is not an object or the branches are different.\n        return false;\n      }\n    } else if (arrayToStringStr === toString.call(obj1[property])) {\n      // `obj1[property]` is an array.\n      if (\n        arrayToStringStr !== toString.call(obj2[property]) ||\n        !deepArrayCompare(obj1[property], obj2[property])\n      ) {\n        // `obj2[property]` is not an array or the two objects are different.\n        return false;\n      }\n    } else {\n      // `obj1[property]` is not an object and is not an array.\n      if (obj1[property] !== obj2[property]) {\n        return false;\n      }\n    }\n  }\n  // `obj1` equals `obj2` (has the same properties and the same values).\n  return true;\n}\n\n/**\n * Nests the properties of an object using an array of props definitions and defaults.\n * Returns the leaf.\n *\n * Example:\n *\n * ```\n * const obj = {};\n * let nest = [{a: {}}, {b: {}}, {c: {}}, {d: {}}, {e: {}}, {f: {}}, {g: {}}, {h: {}} ];\n * const leaf = nestedObjectConstructValue(obj, nest);\n * leaf.i = 'i';\n * leaf.l = { m: \"m\" };\n * JSON.stringify(obj); // {\"a\":{\"b\":{\"c\":{\"d\":{\"e\":{\"f\":{\"g\":{\"h\":{\"i\":\"i\",\"l\":{\"m\":\"m\"}}}}}}}}}}\n * nest = nest.concat([ {n: {}}, {o: {}}, {p: {}} ]);\n * var pLeaf = nestedObjectConstructValue(obj, nest);\n * pLeaf.q = 'q';\n * nest = nest.concat([ {q: {}} ]);\n * nestedObjectConstructValue(obj, nest); // 'q'\n * ```\n *\n * @param {Object} root The root object.\n * @param {Array} nestedPropsDef The nexted props definitions.\n * @param {boolean} [isRootArrayIfRootFalsy] True if the root should be an array if the first argument \"root\" is falsy.\n * @return {*} The leaf.\n */\nexport function nestedObjectConstructValue(\n  root,\n  nestedPropsDef,\n  isRootArrayIfRootFalsy\n) {\n  root = root || (isRootArrayIfRootFalsy ? [] : {});\n  let leaf = root;\n  for (let i = 0; i < nestedPropsDef.length; i++) {\n    const propDef = nestedPropsDef[i];\n    const propKey = Object.keys(propDef)[0];\n    const propDefault = propDef[propKey];\n    leaf[propKey] = leaf[propKey] || propDefault;\n    leaf = leaf[propKey];\n  }\n  return leaf;\n}\n\n/**\n * Clones an object deeply using the JSON API.\n *\n * @param {Object} obj The object to clone.\n * @return {Object} The cloned object.\n */\nexport function cloneDeeplyJSON(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Tests whether the given value is a reference type or not.\n *\n * @param {*} value Any value which can be an object or a primitive type.\n * @return {boolean} True if the given value is a reference type, false otherwise.\n */\nexport function isReferenceType(value) {\n  return new Object(value) === value;\n}\n\n/**\n * Tests whether the given value is a primitive type or not.\n *\n * @param {*} value Any value which can be an object or a primitive type.\n * @return {boolean} True if the given value is a primitive type, false otherwise.\n */\nexport function isPrimitiveType(value) {\n  return new Object(value) !== value;\n}\n\n/**\n * Checks whether an object has a cyclic reference or not.\n *\n * @param {Object} obj The object to check for a cyclic reference.\n * @return {boolean} True if the object has a cyclic reference, false otherwise.\n */\nexport function hasCyclicReference(obj) {\n  const stackSet = [];\n  let detected = false;\n\n  function detect(obj) {\n    if (detected) {\n      return;\n    }\n\n    if (typeof obj !== \"object\") {\n      return;\n    }\n\n    const indexOfObj = stackSet.indexOf(obj);\n    if (indexOfObj !== -1) {\n      detected = true;\n      return;\n    }\n\n    stackSet.push(obj);\n    for (const k in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, k)) {\n        detect(obj[k]);\n      }\n    }\n\n    stackSet.splice(indexOfObj, 1);\n    return;\n  }\n  detect(obj);\n  return detected;\n}\n\n/**\n * Converts a type to its string representation.\n *\n * @param {*} type A variable.\n * @return {string} The string representation of \"type\".\n */\nexport function typeToStr(type) {\n  return Object.prototype.toString.call(type);\n}\n\n/**\n * Clones an object deeply and returns the clone.\n *\n * @param {Object} object The object to clone.\n * @return {Object} The clone.\n * @throws {Error} If a circular reference if even only one property is of an unkown type\n *                 (this should never happen) or a circular reference is detected.\n */\nexport function cloneObjDeeply(object) {\n  const newObject = new object.constructor();\n  for (const prop in object) {\n    // If the property is defined on the prototype, ignore it. We don't want to assign it for each clone instance.\n    if (!Object.prototype.hasOwnProperty.call(object, prop)) {\n      continue;\n    }\n\n    const property = object[prop];\n    if (isPrimitiveType(property)) {\n      newObject[prop] = property;\n    } else if (isReferenceType(property)) {\n      if (!hasCyclicReference(property)) {\n        const clone = cloneObjDeeply(property);\n        newObject[prop] = clone;\n      } else {\n        throw new Error(\n          \"Circular reference detected inside of property '\" +\n            prop +\n            \"' (\" +\n            typeToStr(property) +\n            \") in object (\" +\n            typeToStr(object) +\n            \")\"\n        );\n      }\n    } else {\n      throw new Error(\n        \"Oops! Unknown type for property '\" +\n          prop +\n          \"' (\" +\n          typeToStr(property) +\n          \") in object (\" +\n          typeToStr(object) +\n          \")\"\n      );\n    }\n  }\n  return newObject;\n}\n\n/**\n * Deep object extension implementation.\n * Nothing is returned, but the destination object will be modified and merged with the source object\n * so that properties of the source object which are objects will recursively merge with the corresponding\n * destination property while the other properties with all the other types will replace the properties of the\n * destination object.\n * Note that this method should not be used for inheritance via the Prototypal Combination Inheritance pattern.\n * Also, this method doesn't perform a deep object cloning, it just extends the destinationObject by adding properties\n * it doesn't have in a deep way.\n *\n * @param {Object} destinationObject The destination object which will be modified and merged with the source object.\n * @param {Object} sourceObject The source object which will be used to extend the destination object.\n * @param {Object} [options] An object containing the options for the extension.\n *                           The currently available options are:\n *\n *                               - extendsArrays (boolean: false): Whether or not to extend nested arrays too (defaults to false);\n *\n * @return {undefined}\n */\nexport function deepObjectExtend(\n  destinationObject,\n  sourceObject,\n  options = {}\n) {\n  for (const property in sourceObject) {\n    if (sourceObject[property] && isPlainObject(sourceObject[property])) {\n      destinationObject[property] = destinationObject[property] || {};\n      deepObjectExtend(\n        destinationObject[property],\n        sourceObject[property],\n        options\n      );\n    } else if (\n      options.extendArrays &&\n      sourceObject[property] &&\n      isArray(sourceObject[property])\n    ) {\n      destinationObject[property] = destinationObject[property] || [];\n      deepObjectExtend(\n        destinationObject[property],\n        sourceObject[property],\n        options\n      );\n    } else {\n      destinationObject[property] = sourceObject[property];\n    }\n  }\n}\n\n/**\n * Deep object cloning extension implementation. If the source objects contain a property with a reference type, a clone object\n * of the same type of that property will be created and then merged with the property object of the destination object.\n *\n * @param {Object} destinationObject The destination object which will be modified and merged with the source object.\n * @param {...Object} sourceObject One or more objects which will be used to extend the destination object.\n * @return {undefined}\n */\nexport function deepObjectCloningExtend(...args) {\n  const destinationObject = args[0];\n  let sourceObject;\n  for (let i = 1; args[i]; i++) {\n    sourceObject = args[i];\n    for (const property in sourceObject) {\n      if (sourceObject[property] && isPlainObject(sourceObject[property])) {\n        destinationObject[property] = destinationObject[property] || {};\n        deepObjectExtend(\n          destinationObject[property],\n          cloneObjDeeply(sourceObject[property])\n        );\n      } else {\n        destinationObject[property] = sourceObject[property];\n      }\n    }\n  }\n}\n\n/**\n * Extends a destination object with the provided source objects.\n *\n * @param {Object} destinationObj The destination object.\n * @param {...Object|Array} sourceObjects The source objects. If the last argument is an array containing one single truthy element,\n *                                        it will be treated as an options parameter and its single first truthy element will be treated as object\n *                                        containing the options for the extension.\n *                                        The currently available options are:\n *\n *                                            - extendsArrays (boolean: false): Whether or not to extend nested arrays too (defaults to false);\n *\n * @return {Object} The destination object \"destinationObj\" given as parameter after extension.\n */\nexport function extend(destinationObj, ...sourceObjects) {\n  let options = {};\n  if (sourceObjects.length) {\n    const last = sourceObjects.pop();\n    if (isArray(last) && last.length === 1 && isPlainObject(last[0])) {\n      options = last[0];\n    } else {\n      sourceObjects.push(last);\n    }\n  }\n  for (const sourceObject of sourceObjects) {\n    deepObjectExtend(destinationObj, sourceObject, options);\n  }\n  return destinationObj;\n}\n\n/**\n * Extends a destination object with the provided source objects.\n *\n * @param {Object} destinationObject The destination object.\n * @param {...*} rest The source objects with the last parameter being an array of rules,\n *                    each rule being a tuple array where the first element is an array of \"ORed\" property names (strings or numbers)\n *                    or regexes matching property names for which the corresponding values should be decorated\n *                    (or a single property name or regex matching a property name if the decoration should only happen on a single property),\n *                    and where the second element is a callback to execute for each value which is a value of a property\n *                    of a source object.\n *                    The callback has the following signature:\n *\n *                        (value: *, prop: string|number, parent: Object) => *|undefined\n *\n *                    The callback will receive the final value after extension, its associated property and the parent object\n *                    where that property is set with that value.\n *                    Its returned value will be used as the final value of the property for that object in \"destinationObject\".\n *\n *                    If the last parameter is not an array of rules, it will be treated as the last source object to use for the extension\n *                    (the \"extend\" function will be simply called under the hood without any decoration logic).\n * @return {Object} The destination object \"destinationObject\" given as parameter after extension and, if the callback is given\n *                  as the last parameter, after applying the given callback.\n */\nexport function extendDecorate(destinationObject, ...rest) {\n  const rules = rest[rest.length - 1];\n  if (isArray(rules)) {\n    rest.pop();\n    const sourceObjects = rest;\n    const initialRetValue = {};\n    const matchedRulesMap = new Map();\n    const callbacksMap = new Map();\n    const paths = [];\n    const mapKeys = (\n      destinationObject,\n      sourceObject,\n      currentStack,\n      currentPath\n    ) => {\n      for (const key in sourceObject) {\n        currentStack.push({\n          destinationObject,\n          sourceObject,\n          property: key,\n          path: [...currentPath, key],\n        });\n      }\n    };\n    const matchRule = (rule, property) => {\n      if (rule instanceof RegExp && typeof property === \"string\") {\n        return property.match(rule);\n      } else {\n        return rule === property;\n      }\n    };\n    const matchArrayRule = (arrayRule, property) => {\n      for (const rule of arrayRule) {\n        if (matchRule(rule, property)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const ruleMatches = (rule, property) => {\n      if (isArray(rule)) {\n        return matchArrayRule(rule, property);\n      } else {\n        return matchRule(rule, property);\n      }\n    };\n    const matchRules = property => {\n      if (!matchedRulesMap.has(property)) {\n        const callbacks = [];\n        for (const [rule, callback] of rules) {\n          if (ruleMatches(rule, property)) {\n            callbacks.push(callback);\n          }\n        }\n        matchedRulesMap.set(property, callbacks);\n      }\n      return matchedRulesMap.get(property);\n    };\n\n    for (const sourceObject of sourceObjects) {\n      const currentStack = [];\n      const currentPath = [];\n      mapKeys(destinationObject, sourceObject, currentStack, currentPath);\n      while (currentStack.length) {\n        const {\n          destinationObject,\n          sourceObject,\n          property,\n          path: currentPath,\n        } = currentStack.pop();\n        if (sourceObject[property] && isPlainObject(sourceObject[property])) {\n          // \"sourceObject[property]\" is an object of class \"Object\".\n          destinationObject[property] = isPlainObject(\n            destinationObject[property]\n          )\n            ? destinationObject[property]\n            : {};\n          mapKeys(\n            destinationObject[property],\n            sourceObject[property],\n            currentStack,\n            currentPath\n          );\n        } else {\n          // \"sourceObject[property]\" is not an object.\n          destinationObject[property] = sourceObject[property];\n        }\n        const callbacks = matchRules(property);\n        if (callbacks && callbacks.length) {\n          if (!nestedTreeMapHas(callbacksMap, currentPath)) {\n            paths.push([...currentPath]);\n          }\n          nestedTreeMapSet(\n            callbacksMap,\n            currentPath,\n            callbacks.map(callback => retValue => path => {\n              const value =\n                retValue === initialRetValue\n                  ? destinationObject[property]\n                  : retValue;\n              return callback(value, property, destinationObject, path);\n            })\n          );\n        }\n      }\n    }\n\n    // Decorating the final nested values.\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const path = paths[i];\n      const callbacks = nestedTreeMapGet(callbacksMap, path) || [];\n      let retValue = initialRetValue;\n      for (const callback of callbacks) {\n        retValue = callback(retValue)(path);\n      }\n      if (retValue !== initialRetValue) {\n        setNestedPropertyValue(destinationObject, path, retValue);\n      }\n    }\n\n    return destinationObject;\n  } else {\n    return extend(destinationObject, ...rest);\n  }\n}\n\n/**\n * Shallowly extends a destination object with the provided source objects (first dimension).\n *\n * @param {Object} destinationObject The destination object.\n * @param {...Object} sourceObjects The source objects.\n * @return {Object} The destination object \"destinationObject\" given as parameter after shallow extension.\n */\nexport function shallowExtend(destinationObject, ...sourceObjects) {\n  sourceObjects.map(obj =>\n    Object.keys(obj).map(key => (destinationObject[key] = obj[key]))\n  );\n  return destinationObject;\n}\n\n/**\n * Like \"Array.prototype.includes\", but with type coercion.\n *\n * @param {Array} array The array.\n * @param {Anything} value The value.\n * @return {boolean} True if the value is included within the array (checking with type coercion`==`).\n */\nexport function includesTypeCoercion(array, value) {\n  for (const valueOfArray of array) {\n    if (valueOfArray == value) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Tests whether a value is undefined or not.\n *\n * @param {*} value A value\n * @return {boolean} True value is undefined, false otherwise.\n */\nexport function isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n\n/**\n * Tests if the given value is an int.\n *\n * @param {*} value The value.\n * @return {boolean} True if value is an int, false otherwise.\n */\nexport function isInt(value) {\n  return Number.isInteger(value);\n}\n\n/**\n * Tests if the given string is an integer string.\n *\n * @param {*} a The string.\n * @return {boolean} True if the given string is an integer string, false otherwise.\n */\nexport function ctypeDigit(a) {\n  return Boolean(a.match(/^[0-9]+$/));\n}\n\n/**\n * Tests if the given value is an int or an integer string.\n *\n * @param {*} a The value.\n * @return {boolean} True if the value is an int or an integer string, false otherwise.\n */\nexport function isIntegerOrIntegerStr(a) {\n  return Number.isInteger(a) || ctypeDigit(a);\n}\n\n/**\n * Finds the index of a value in an array without type juggling\n * (i.e. like \"Array.prototype.indexOf\", but using \"==\" for equality comparison).\n *\n * @param {Array} array An array.\n * @param {*} value A value.\n * @return {number} -1 if the value is not in array, otherwise the index of value in array.\n */\nexport function findIndex(array, value) {\n  return array.findIndex(el => el == value);\n}\n\n/**\n * Returns the first value of the first property of an object.\n *\n * @param {Object} obj The object.\n * @return {*} The value of the first property of the given object.\n */\nexport function firstPropValue(obj) {\n  let prop;\n  for (prop in obj) {\n    break;\n  }\n  return obj[prop];\n}\n\n/**\n * Tests if a value is strictly a boolean \"true\".\n *\n * @param {*} value A value.\n * @return {boolean} \"true\" if the value is a boolean \"true\", \"false\" otherwise.\n */\nexport function isStrictlyTrue(value) {\n  return value === true;\n}\n\n/**\n * Tests if a value is truthy or not.\n *\n * @param {*} value The value.\n * @return {boolean} \"true\" if the value is truthy (evaluates to boolean \"true\"), \"false\" otherwise.\n */\nexport function isTruthy(value) {\n  return Boolean(value);\n}\n\n/**\n * Tests if all the given values are truthy.\n *\n * @param {...*} values The values.\n * @return {boolean} \"true\" if and only if all the values are truthy.\n */\nexport function allTruthy(...values) {\n  return values.every(isTruthy);\n}\n\n/**\n * Tests if all the given values are not undefined.\n *\n * @param {...*} values The values.\n * @return {boolean} \"true\" if and only if all the values are not undefined.\n */\nexport function allNotUndefined(...values) {\n  return values.every(value => typeof value !== \"undefined\");\n}\n\n/**\n * Tests if a string is a valid JSON string.\n *\n * @param {string} str A string.\n * @return {boolean} \"true\" if the string represents a valid JSON string, \"false\" otherwise.\n */\nexport function isJSONString(str) {\n  try {\n    JSON.parse(str);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * No-op function.\n *\n * @return {undefined}\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noOpFn() {}\n\n/**\n * Tests if a partial object is a subset of another object.\n *\n * @param {Object} obj An object.\n * @param {Object} partialObj A partial object which may not have all the keys of \"obj\"\n *                            or may even have different keys, or keys with different values.\n * @return {boolean} False if \"partialObj\" has a key which is not in \"obj\",\n *                   or has at least one key which is also in \"obj\" but with a different value\n *                   (shallow comparison), true otherwise.\n */\nexport function partialShallowEqual(obj, partialObj) {\n  return shallowEqual(\n    Object.keys(partialObj).reduce((carry, key) => {\n      carry[key] = obj[key];\n      return carry;\n    }, {}),\n    partialObj\n  );\n}\n\n/**\n * Returns a shallow object diff, returning an object with two keys \"objA\" and \"objB\",\n * each containing an object with all the properties of one of the two objects which are not within\n * the other object, respectively.\n * If a property is on both objects but each object has a different value for that same property\n * (using shallow equality comparison), the returned property will be set on both objects with their\n * respective values.\n *\n * @param {Object} objA First object.\n * @param {Object} objB Second object.\n * @return {Object} An object containing the shallow diff, with two keys \"objA\" and \"objB\".\n */\nexport function shallowObjectDiff(objA, objB) {\n  const diff = {\n    objA: {},\n    objB: {},\n  };\n  if (shallowEqual(objA, objB)) {\n    return diff;\n  }\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  for (let i = 0; i < keysA.length; i++) {\n    const prop = keysA[i];\n    if (!objectPropEqual(objA, objB, prop)) {\n      diff.objA[prop] = objA[prop];\n      if (hasOwnProperty.call(objB, prop)) {\n        diff.objB[prop] = objB[prop];\n      }\n    }\n  }\n  for (let i = 0; i < keysB.length; i++) {\n    const prop = keysB[i];\n    if (!objectPropEqual(objB, objA, prop)) {\n      diff.objB[prop] = objB[prop];\n      if (hasOwnProperty.call(objA, prop)) {\n        diff.objA[prop] = objA[prop];\n      }\n    }\n  }\n  return diff;\n}\n\n/**\n * Casts a value to a string.\n *\n * @param {*} v A value.\n * @return {string} The string representation of the value.\n */\nexport function str(v) {\n  return \"\" + v;\n}\n\n/**\n * Maps an object, executing a function on each of its properties\n * returning a new mapped object.\n *\n * @param {Object} obj The object to map.\n * @param {Function} fn The function to use for the mapping.\n * @return {Object} The new mapped object.\n */\nexport const mapObject = (obj, fn) =>\n  Object.fromEntries(\n    Object.entries(obj).map(([key, value], index) => [\n      key,\n      fn(value, key, index),\n    ])\n  );\n\n/**\n * Maps an array to an object.\n *\n * @param {Array} arr An array.\n * @param {Function} fn A function receiving the current value, its index as well as the whole array \"arr\"\n *                      as parameters returning a tuple with the key at index 0 and the value at index 1 to set on the object.\n * @returns {Object} The array mapped to an object.\n */\nexport const mapToObject = (arr, fn) => {\n  let res;\n  return arr.reduce(\n    (carry, ...rest) =>\n      ((res = fn(...rest)) && false) ||\n      ((carry[res[0]] = res[1]) && false) ||\n      carry,\n    {}\n  );\n};\n\n/**\n * Selects the truthy properties of an object or the properties of an object\n * passing a test specified with a callback function.\n *\n * @param {Object} obj The input object.\n * @param {Function} fn A function which will receive two parameters:\n *\n *                          - value: The current value of the input object for a given property;\n *                          - prop: The name of the current property of the input object.\n *\n *                      The function will have to return a boolean \"true\" indicating that this value\n *                      and property has to be included in the returned object, or \"false\" otherwise.\n *\n * @return {Object} An object having only the properties which passed the test\n *                  implemented by the \"fn\" callback function.\n */\nexport const propSelection = (obj, fn = isTruthy) =>\n  Object.keys(obj).reduce((carry, key) => {\n    if (fn(obj[key], key)) {\n      carry[key] = obj[key];\n    }\n    return carry;\n  }, {});\n\n/**\n * Returns all the properties of the given object traversing its prototype chain.\n *\n * @param {Object} obj The object.\n * @param {Object} [options] An object with options.\n * @param {?Object} [options.stopAtPrototype] The prototype in the chain at which to stop the traversing.\n *                                            Defaults to null, in which case the whole prototype chain will be traversed.\n * @param {boolean} [options.stopAtPrototypeInclude] Whether or not to include the properties of the given prototype at which to stop.\n *                                                   Works only if \"stopAtPrototype\" is set to a valid prototype object in the prototype chain\n *                                                   of \"obj\".\n *                                                   Defaults to true, in which case the properties of the prototype at which to stop will be included\n *                                                   in the returned array.\n * @return {string[]} An array of containing the names of the properties.\n */\nexport function prototypeChainProperties(\n  obj,\n  { stopAtPrototype = null, stopAtPrototypeInclude = true } = {}\n) {\n  let current = obj;\n  const map = {};\n  let isStopPrototype = false;\n  let stop = false;\n  while (!stop && current && (!isStopPrototype || stopAtPrototypeInclude)) {\n    if (isStopPrototype) {\n      stop = true;\n    }\n    const properties = Object.getOwnPropertyNames(current);\n    properties.map(property => (map[property] = true));\n    current = Object.getPrototypeOf(current);\n    if (stopAtPrototype) {\n      isStopPrototype = current === stopAtPrototype;\n    }\n  }\n  const properties = Object.keys(map);\n  return properties;\n}\n\n/**\n * Defines an object's property with a getter and an optional setter.\n *\n * @param {Object} obj An object (may be a prototype).\n * @param {string} propname The property name.\n * @param {Function} getfn Getter function.\n * @param {Function|undefined} [setfn] Setter function.\n * @return {undefined}\n */\nexport function prop(obj, propname, getfn, setfn = void 0) {\n  const propObj = {};\n  propObj[propname] = {\n    get: getfn,\n    set: setfn,\n  };\n  Object.defineProperties(obj, propObj);\n}\n\n/**\n * Defines a property on an object.\n *\n * @param {Object} o An object.\n * @param {string} p The property to define.\n * @param {Object} descriptor Optional object containing the descriptor's properties to use to override the default properties.\n * @return {Object} The object that was passed to the function.\n */\nexport function defineProperty(o, p, descriptor = {}) {\n  return Object.defineProperty(o, p, {\n    configurable: false,\n    enumerable: false,\n    writable: true,\n    ...descriptor,\n  });\n}\n\n/**\n * Assigns the properties of the given source objects to the target object.\n *\n * @source https://stackoverflow.com/questions/39515321/spread-operator-issues-with-property-accessors-getters#answer-39521418\n *\n * @param {Object} target The target object.\n * @param {...Object} sources The source objects.\n * @return {Object} The target object.\n */\nexport function completeObjectAssign(target, ...sources) {\n  sources.forEach(source => {\n    const descriptors = Object.keys(source).reduce((descriptors, key) => {\n      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);\n      return descriptors;\n    }, {});\n    // By default, Object.assign copies enumerable Symbols too.\n    Object.getOwnPropertySymbols(source).forEach(sym => {\n      const descriptor = Object.getOwnPropertyDescriptor(source, sym);\n      if (descriptor.enumerable) {\n        descriptors[sym] = descriptor;\n      }\n    });\n    Object.defineProperties(target, descriptors);\n  });\n  return target;\n}\n"],"file":"index.js"}