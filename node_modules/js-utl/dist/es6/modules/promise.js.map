{"version":3,"sources":["../../../src/modules/promise.js"],"names":["uniqueId","isArray","noOpFn","timeout","delayMs","value","Promise","resolve","setTimeout","minDelayPromise","promise","minDelay","all","then","catch","e","maxDelayFallbackPromise","maxDelayMs","onFallback","fallbackMinDelayMs","uniqueIdentifier","race","applyAsync","acc","onfulfilled","onrejected","composeAsync","funcs","x","reduce","func","asSoonAtLeastSomeFulfilled","promises","minNumberOfFulfilledPromises","length","unresolvablePromise","promiseToReturn","settledCount","isPromiseSettled","reject","fulfilled","rejected","map","index","isFulfilled","push","reason"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2022 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Promise-related utility functions.\n */\n\nimport { uniqueId, isArray, noOpFn } from \"./core\";\n\n/**\n * Creates a new timeout promise which will resolve after the given milliseconds timeout.\n *\n * @param {number} delayMs Delay in milliseconds after which the promise will resolve.\n * @param {*} [value] Optional value to resolve with.\n * @return {Promise} A new promise which resolves right after \"delayMs\" have elapsed.\n */\nexport function timeout(delayMs, value) {\n  return new Promise(resolve => setTimeout(resolve, delayMs, value));\n}\n\n/**\n * Creates a new promise with a minimum delay before it is fulfilled.\n *\n * @param {Promise} promise A promise.\n * @param {number} minDelay Minumum delay in milliseconds.\n * @return {Promise} A new promise which resolves with the given value of the given promise\n *                   or rejects with the rejected value of the promise if it rejects.\n */\nexport function minDelayPromise(promise, minDelay) {\n  return Promise.all([promise, timeout(minDelay)])\n    .then(([value]) => {\n      return value;\n    })\n    .catch(e => {\n      throw e;\n    });\n}\n\n/**\n * Resolves a promise with an optional fallback which fires if the promise does not resolve\n * under a certain time constraint.\n *\n * @param {Object} obj An object.\n * @param {Promise} obj.promise A promise.\n * @param {number} obj.maxDelayMs Max delay in milliseconds to wait before executing \"onFallback\" code if the time elapses.\n * @param {Function} obj.onFallback Function to execute if the given \"promise\" takes more than \"maxDelayMs\" to resolve.\n * @param {number} obj.fallbackMinDelayMs Number of milliseconds to wait if the fallback code gets executed before resolving the promise.\n * @return {Promise} A promise which resolves with the value of \"promise\" or rejects with the error of the given \"promise\".\n */\nexport function maxDelayFallbackPromise({\n  promise,\n  maxDelayMs,\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  onFallback = () => {},\n  fallbackMinDelayMs,\n} = {}) {\n  const uniqueIdentifier = uniqueId();\n  return Promise.race([\n    promise,\n    timeout(maxDelayMs).then(() => uniqueIdentifier),\n  ]).then(value => {\n    if (value === uniqueIdentifier) {\n      onFallback();\n      return minDelayPromise(promise, fallbackMinDelayMs);\n    } else {\n      return value;\n    }\n  });\n}\n\n/**\n * Applies an async operation to a promise returning a new one.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Composition\n *\n * @param {Promise} acc A promise.\n * @param {Function} onfulfilled Fulfilled callback.\n * @param {Function} onrejected Rejected callback.\n * @return {Promise} A new promise.\n */\nexport const applyAsync = (acc, onfulfilled, onrejected) => {\n  return typeof onrejected !== \"undefined\"\n    ? acc.then(onfulfilled, onrejected)\n    : acc.then(onfulfilled);\n};\n\n/**\n * Composes functions which are run subsequently\n * (sequential composition) using promises.\n *\n * This function is useful when a chain of operations is known ahead of time\n * and they must be executed subsequently.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Composition\n *\n * @param {...(Function|Array)} funcs The functions (fulfilled callbacks). An array can be given and it MUST have\n *                                    the fulfilled callback at index 0 and the reject callback at index 1.\n * @return {Function} A new function that accepts an initial value to be passed through the composition pipeline.\n *                    If the returned function is called, it will return a Promise which represents the chain formed\n *                    by the promises composed subsequently.\n */\nexport const composeAsync = (...funcs) => x => {\n  return funcs.reduce((acc, func) => {\n    let promise;\n    if (isArray(func)) {\n      // Item at index 0 is the fulfilled callback,\n      // while the item at index 1 is the reject callback.\n      promise = applyAsync(acc, func[0], func[1]);\n    } else {\n      promise = applyAsync(acc, func);\n    }\n    return promise;\n  }, Promise.resolve(x));\n};\n\n/**\n * Returns a promise which resolves as soon as at least some of the promises given as parameter are fulfilled,\n * and rejects if the minimum number of resolved promises (\"minNumberOfFulfilledPromises\") is not reached after all the given promises are settled.\n *\n * @param {Promise[]} promises An array of promises. If an empty array is given, then the returned promise will never resolve (will remain in pending state forever).\n * @param {number} minNumberOfFulfilledPromises The minimum number of the given promises that must be fulfilled to consider the returned promise fulfilled\n *                                              (e.g. at least 3 of the given promises must be fulfilled).\n *                                              Defaults to 1.\n *                                              If \"minNumberOfFulfilledPromises\" is less than 0, then it is treated as if it was 1.\n *                                              If \"minNumberOfFulfilledPromises\" is greater than the number of the given promises \"promises\",\n *                                              then \"minNumberOfFulfilledPromises\" is treated as if it was \"promises.length\".\n * @return {Promise} A new promise. The promise either fulfills or rejects with an object having the following properties:\n *\n *                       - fulfilled: An array, each element being an object having the following properties:\n *\n *                           - promise: The fulfilled promise of the array of promises \"promises\";\n *                           - value: The value that the promise has resolved with;\n *                           - index: The positional index of the given array of promises \"promises\";\n *\n *                       - rejected: An array, each element being an object having the following properties:\n *\n *                           - promise: The rejected promise of the array of promises \"promises\";\n *                           - reason: The reason that the promise has rejected with;\n *                           - index: The positional index of the given array of promises \"promises\";\n *\n *                   The \"fulfilled\" array will have \"minNumberOfFulfilledPromises\" elements.\n */\nexport const asSoonAtLeastSomeFulfilled = (\n  promises,\n  minNumberOfFulfilledPromises = 1\n) => {\n  const length = promises.length;\n  const unresolvablePromise = new Promise(noOpFn);\n  let promiseToReturn = unresolvablePromise;\n  if (minNumberOfFulfilledPromises < 0) {\n    minNumberOfFulfilledPromises = 1;\n  } else if (minNumberOfFulfilledPromises > length) {\n    minNumberOfFulfilledPromises = length;\n  }\n  if (length > 0) {\n    let settledCount = 0;\n    let isPromiseSettled = false;\n    promiseToReturn = new Promise((resolve, reject) => {\n      const fulfilled = [];\n      const rejected = [];\n      promises.map((promise, index) => {\n        let isFulfilled = false;\n        promise\n          .then(value => {\n            if (!isPromiseSettled) {\n              isFulfilled = true;\n              settledCount++;\n              fulfilled.push({\n                promise,\n                index,\n                value,\n              });\n              if (fulfilled.length === minNumberOfFulfilledPromises) {\n                isPromiseSettled = true;\n                resolve({ fulfilled, rejected });\n              }\n            }\n          })\n          .catch(reason => {\n            if (!isPromiseSettled) {\n              if (!isFulfilled) {\n                settledCount++;\n                rejected.push({ promise, index, reason });\n                if (settledCount === length) {\n                  isPromiseSettled = true;\n                  reject({ fulfilled, rejected });\n                }\n              }\n            }\n          });\n      });\n    });\n  }\n  return promiseToReturn;\n};\n"],"file":"promise.js"}